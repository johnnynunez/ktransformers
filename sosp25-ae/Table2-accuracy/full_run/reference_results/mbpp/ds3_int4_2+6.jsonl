{"idx": 0, "completion": "def remove_Occ(s, ch):\n    first_occurrence = s.find(ch)\n    if first_occurrence == -1:\n        return s\n    last_occurrence = s.rfind(ch)\n    if first_occurrence == last_occurrence:\n        return s[:first_occurrence] + s[first_occurrence+1:]\n    else:\n        return s[:first_occurrence] + s[first_occurrence+1:last_occurrence] + s[last_occurrence+1:]\n[DONE]"}
{"idx": 1, "completion": "def sort_matrix(matrix):\n    matrix.sort(key=lambda row: sum(row))\n    return matrix\n[DONE]"}
{"idx": 2, "completion": "from collections import Counter\ndef count_common(words):\n    counts = Counter(words)\n    return counts.most_common()\n[DONE]"}
{"idx": 3, "completion": "def find_Volume(l, w, h):\n    return (l * w * h) // 2\n[DONE]"}
{"idx": 4, "completion": "def split_lowerstring(test_str):\n    res = []\n    for i in test_str:\n        if i.islower():\n            res.append(i)\n    return res\n[DONE]"}
{"idx": 5, "completion": "import re\ndef text_lowercase_underscore(text):\n    pattern = '^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 6, "completion": "def square_perimeter(side): \n    perimeter = 4 * side\n    return perimeter\n[DONE]"}
{"idx": 7, "completion": "def remove_dirty_chars(str1, str2):\n    result = [char for char in str1 if char not in str2]\n    return ''.join(result)\n[DONE]"}
{"idx": 8, "completion": "def test_duplicate(array):\n    if len(array) == len(set(array)):\n        return False\n    else:\n        return True\n[DONE]"}
{"idx": 9, "completion": "def is_woodall(n):\n    if n < 1:\n        return False\n    k = 1\n    while True:\n        woodall = k * (2 ** k) - 1\n        if woodall == n:\n            return True\n        if woodall > n:\n            return False\n        k += 1\n[DONE]"}
{"idx": 10, "completion": "def multiples_of_num(m, n):\n    res = [n * i for i in range(1, m+1)]\n    return res\n[DONE]"}
{"idx": 11, "completion": "def find_first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n[DONE]"}
{"idx": 12, "completion": "def maximum_Sum(lists):\n    max_sum = 0\n    for lst in lists:\n        current_sum = sum(lst)\n        if current_sum > max_sum:\n            max_sum = current_sum\n    return max_sum\n[DONE]"}
{"idx": 13, "completion": "def binary_to_decimal(binary):\n    decimal = 0\n    power = 0\n    while binary > 0:\n        last_digit = binary % 10\n        decimal += last_digit * (2 ** power)\n        binary = binary // 10\n        power += 1\n    return decimal\n[DONE]"}
{"idx": 14, "completion": "from collections import Counter\n\ndef find_Product(arr, n):\n    element_count = Counter(arr)\n    product = 1\n    for num in element_count:\n        if element_count[num] == 1:\n            product *= num\n    return product\n[DONE]"}
{"idx": 15, "completion": "def check_k_elements(test_list, k):\n    for t in test_list:\n        for elem in t:\n            if elem != k:\n                return False\n    return True\n[DONE]"}
{"idx": 16, "completion": "def remove(list1):\n    new_list = []\n    for string in list1:\n        new_string = ''.join([i for i in string if not i.isdigit()])\n        new_list.append(new_string)\n    return new_list\n[DONE]"}
{"idx": 17, "completion": "import math\ndef binomial_Coeff(n, k):\n    return math.comb(n, k)\n[DONE]"}
{"idx": 18, "completion": "def get_Odd_Occurrence(arr, n):\n    for i in range(0, n):\n        count = 0\n        for j in range(0, n):\n            if arr[i] == arr[j]:\n                count += 1\n        if (count % 2 != 0):\n            return arr[i]\n    return -1\n[DONE]"}
{"idx": 19, "completion": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n[DONE]"}
{"idx": 20, "completion": "import heapq\nfrom collections import defaultdict\n\ndef func(lists, k):\n    frequency = defaultdict(int)\n    for lst in lists:\n        for num in lst:\n            frequency[num] += 1\n    heap = []\n    for num, count in frequency.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (count, num))\n        else:\n            if count > heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (count, num))\n    result = [num for (count, num) in sorted(heap, key=lambda x: (-x[0], x[1]))]\n    return result\n[DONE]"}
{"idx": 21, "completion": "import math\ndef max_Prime_Factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n[DONE]"}
{"idx": 22, "completion": "def decimal_To_Binary(n):\n    return int(bin(n).replace(\"0b\", \"\"))\n[DONE]"}
{"idx": 23, "completion": "def find_missing(arr, n):\n    for i in range(1, n + 1):\n        if i not in arr:\n            return i\n    return -1\n[DONE]"}
{"idx": 24, "completion": "def find_rect_num(n):\n    return n * (n + 1)\n[DONE]"}
{"idx": 25, "completion": "def find_Nth_Digit(num, den, n):\n    fraction = num / den\n    decimal_part = str(fraction).split('.')[1]\n    return int(decimal_part[n-1])\n[DONE]"}
{"idx": 26, "completion": "def sort_mixed_list(mixed_list):\n    nums = [x for x in mixed_list if isinstance(x, int)]\n    words = [x for x in mixed_list if isinstance(x, str)]\n    nums.sort()\n    words.sort()\n    return nums + words\n[DONE]"}
{"idx": 27, "completion": "def div_even_odd(nums):\n    even = None\n    odd = None\n    for num in nums:\n        if num % 2 == 0 and even is None:\n            even = num\n        if num % 2 != 0 and odd is None:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even / odd\n[DONE]"}
{"idx": 28, "completion": "from collections import Counter\nimport heapq\n\ndef rearange_string(s):\n    count = Counter(s)\n    heap = [(-value, key) for key, value in count.items()]\n    heapq.heapify(heap)\n    result = []\n    prev = None\n    while heap:\n        current = heapq.heappop(heap)\n        result.append(current[1])\n        if prev and prev[0] < -1:\n            heapq.heappush(heap, (prev[0] + 1, prev[1]))\n        prev = (current[0] + 1, current[1]) if current[0] + 1 < 0 else None\n    if len(result) != len(s):\n        return \"\"\n    return ''.join(result)\n[DONE]"}
{"idx": 29, "completion": "from collections import Counter\ndef freq_element(test_list):\n    res = dict(Counter(i for j in test_list for i in j))\n    return res\n[DONE]"}
{"idx": 30, "completion": "def filter_evennumbers(nums):\n    even_nums = list(filter(lambda x: (x % 2 == 0), nums))\n    return even_nums\n[DONE]"}
{"idx": 31, "completion": "def find_Sum(arr, n):\n    sum_val = 0\n    for i in range(n):\n        if arr.count(arr[i]) > 1:\n            sum_val += arr[i]\n    return sum_val // 2\n[DONE]"}
{"idx": 32, "completion": "import re\ndef text_match(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 33, "completion": "import re\ndef text_match_string(text):\n    if re.search(r'^\\w+', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 34, "completion": "import math\nfrom functools import reduce\n\ndef get_gcd(arr):\n    x = reduce(math.gcd, arr)\n    return x\n[DONE]"}
{"idx": 35, "completion": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 36, "completion": "def compute_Last_Digit(a, b):\n    if a == 0:\n        a = 1\n    if b == 0:\n        b = 1\n    if a >= 5:\n        return 0\n    if b >= 5:\n        return 0\n    fact_a = 1\n    for i in range(1, a + 1):\n        fact_a *= i\n    fact_b = 1\n    for i in range(1, b + 1):\n        fact_b *= i\n    if fact_b == 0:\n        return 0\n    return (fact_b // fact_a) % 10\n[DONE]"}
{"idx": 37, "completion": "def odd_bit_set_number(n):\n    mask = 0x55555555  # This is a 32-bit mask with all odd bits set (0x55555555 in hex)\n    return n | mask\n[DONE]"}
{"idx": 38, "completion": "def specified_element(lst, n):\n    res = [i[n] for i in lst]\n    return res\n[DONE]"}
{"idx": 39, "completion": "def min_length_list(lists):\n    min_list = min(lists, key=lambda x: len(x))\n    return (len(min_list), min_list)\n[DONE]"}
{"idx": 40, "completion": "def check_equilateral(x,y,z):\n    if x == y == z:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 41, "completion": "def parallelogram_area(b, h):\n    area = b * h\n    return area\n[DONE]"}
{"idx": 42, "completion": "def check_Equality(str1):\n    if len(str1) == 0:\n        return \"Not Equal\"\n    if str1[0] == str1[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"\n[DONE]"}
{"idx": 43, "completion": "def counting_sort(arr):\n    if not arr:\n        return []\n    max_val = max(arr)\n    min_val = min(arr)\n    count = [0] * (max_val - min_val + 1)\n    for num in arr:\n        count[num - min_val] += 1\n    sorted_arr = []\n    for i in range(len(count)):\n        while count[i] > 0:\n            sorted_arr.append(i + min_val)\n            count[i] -= 1\n    return sorted_arr\n[DONE]"}
{"idx": 44, "completion": "def tn_gp(a1, a2, n):\n    r = a2 / a1\n    an = a1 * (r ** (n - 1))\n    return an\n[DONE]"}
{"idx": 45, "completion": "def check(n):\n    reversed_n = int(str(n)[::-1])\n    if 2 * reversed_n - 1 == n:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 46, "completion": "def find_Max_Num(arr, n):\n    arr.sort(reverse=True)\n    num = 0\n    for i in range(n):\n        num = num * 10 + arr[i]\n    return num\n[DONE]"}
{"idx": 47, "completion": "def opposite_Signs(x,y):\n    return (x * y) < 0\n[DONE]"}
{"idx": 48, "completion": "def is_octagonal(n):\n    return n * (3 * n - 2)\n[DONE]"}
{"idx": 49, "completion": "def max_len_sub(arr, n):\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n[DONE]"}
{"idx": 50, "completion": "def count_Substrings(s, n):\n    count = 0\n    for i in range(n):\n        sum_digits = 0\n        for j in range(i, n):\n            sum_digits += int(s[j])\n            length = j - i + 1\n            if sum_digits == length:\n                count += 1\n    return count\n[DONE]"}
{"idx": 51, "completion": "def smallest_num(list1):\n    min = list1[0]\n    for a in list1:\n        if a < min:\n            min = a\n    return min\n[DONE]"}
{"idx": 52, "completion": "def max_difference(test_list):\n    max_diff = 0\n    for t in test_list:\n        diff = abs(t[0] - t[1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n[DONE]"}
{"idx": 53, "completion": "def subject_marks(subject_data):\n    subject_data.sort(key = lambda x: x[1])\n    return subject_data\n[DONE]"}
{"idx": 54, "completion": "def recursive_list_sum(data):\n    total = 0\n    for element in data:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total\n[DONE]"}
{"idx": 55, "completion": "def pos_count(list1):\n    count = 0\n    for num in list1:\n        if num > 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 56, "completion": "def bell_number(n):\n    if n == 0:\n        return 1\n    # Create a Bell triangle as a 2D array\n    bell = [[0 for _ in range(n+1)] for _ in range(n+1)]\n    bell[0][0] = 1  # B(0) is 1\n    for i in range(1, n+1):\n        # The first element of each row is the last element of the previous row\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            # Each subsequent element is the sum of the previous element and the element from the previous row, j-1\n            bell[i][j] = bell[i][j-1] + bell[i-1][j-1]\n    return bell[n-1][n-1]\n[DONE]"}
{"idx": 57, "completion": "def is_Monotonic(A):\n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1)))\n[DONE]"}
{"idx": 58, "completion": "def is_sublist(main_list, sublist):\n    n = len(sublist)\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n[DONE]"}
{"idx": 59, "completion": "def get_equal(test_tup, length):\n    for t in test_tup:\n        if len(t) != length:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'\n[DONE]"}
{"idx": 60, "completion": "def comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n    return arr\n[DONE]"}
{"idx": 61, "completion": "def dif_Square(n):\n    if n % 2 != 0 or (n % 4 == 0 and n != 4):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 62, "completion": "import re\ndef multiple_split(string):\n    return re.split('[\\n*]', string)\n[DONE]"}
{"idx": 63, "completion": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True\n[DONE]"}
{"idx": 64, "completion": "def find_tuples(lst, k):\n    result = [tup for tup in lst if all(x % k == 0 for x in tup)]\n    return str(result)\n[DONE]"}
{"idx": 65, "completion": "def count_Squares(n, m):\n    if n < 1 or m < 1:\n        return 0\n    total = 0\n    for i in range(1, min(n, m) + 1):\n        total += (n - i + 1) * (m - i + 1)\n    return total\n[DONE]"}
{"idx": 66, "completion": "def is_Diff(n):\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        num = int(digit)\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n    diff = abs(even_sum - odd_sum)\n    if diff % 11 == 0:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 67, "completion": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 68, "completion": "def word_len(word):\n    return len(word) % 2 != 0\n[DONE]"}
{"idx": 69, "completion": "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n[DONE]"}
{"idx": 70, "completion": "def zip_tuples(tup1, tup2):\n    max_len = max(len(tup1), len(tup2))\n    tup1_cycle = (tup1 * ((max_len // len(tup1)) + 1))[:max_len]\n    tup2_cycle = (tup2 * ((max_len // len(tup2)) + 1))[:max_len]\n    return list(zip(tup1_cycle, tup2_cycle))\n[DONE]"}
{"idx": 71, "completion": "import math\ndef volume_sphere(r):\n    volume = (4/3) * math.pi * (r ** 3)\n    return volume\n[DONE]"}
{"idx": 72, "completion": "def get_Char(str1):\n    total = 0\n    for c in str1:\n        total += ord(c)\n    total = total % 26\n    total = total + ord('a')\n    return chr(total)\n[DONE]"}
{"idx": 73, "completion": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    a, b = 1, 1\n    for i in range(3, n + 1):\n        c = b + a\n        a = b\n        b = c\n    return b\n[DONE]"}
{"idx": 74, "completion": "import math\ndef surfacearea_sphere(r):\n    return 4 * math.pi * r * r\n[DONE]"}
{"idx": 75, "completion": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1\n[DONE]"}
{"idx": 76, "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict\n[DONE]"}
{"idx": 77, "completion": "def freq_count(list1):\n    freq = {}\n    for item in list1:\n        if (item in freq):\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n[DONE]"}
{"idx": 78, "completion": "def closest_num(n):\n    return (n - 1)\n[DONE]"}
{"idx": 79, "completion": "def len_log(list1):\n    max_len = 0\n    for word in list1:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len\n[DONE]"}
{"idx": 80, "completion": "def find_substring(list1, sub):\n    for s in list1:\n        if sub in s:\n            return True\n    return False\n[DONE]"}
{"idx": 81, "completion": "def is_undulating(n):\n    if len(n) < 2:\n        return False\n    if len(n) == 2 and n[0] == n[1]:\n        return False\n    for i in range(2, len(n)):\n        if n[i] != n[i-2]:\n            return False\n    return True\n[DONE]"}
{"idx": 82, "completion": "def power(a, b):\n    return a ** b\n[DONE]"}
{"idx": 83, "completion": "def index_minimum(lst):\n    min_val = float('inf')\n    min_name = \"\"\n    for name, value in lst:\n        if value < min_val:\n            min_val = value\n            min_name = name\n    return min_name\n[DONE]"}
{"idx": 84, "completion": "def Find_Min_Length(test_list):\n    min_length = min(len(sublist) for sublist in test_list)\n    return min_length\n[DONE]"}
{"idx": 85, "completion": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 86, "completion": "def frequency_lists(list1):\n    frequency_dict = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict\n[DONE]"}
{"idx": 87, "completion": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n[DONE]"}
{"idx": 88, "completion": "def decimal_to_binary(n):\n    if n == 0:\n        return '0'\n    binary = ''\n    while n > 0:\n        binary = str(n % 2) + binary\n        n = n // 2\n    return binary\n[DONE]"}
{"idx": 89, "completion": "def next_smallest_palindrome(num):\n    num += 1\n    while True:\n        if str(num) == str(num)[::-1]:\n            return num\n        num += 1\n[DONE]"}
{"idx": 90, "completion": "def kth_element(arr, n, k):\n    arr.sort()\n    return arr[k-1]\n[DONE]"}
{"idx": 91, "completion": "def snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return ''.join(x.title() for x in components)\n[DONE]"}
{"idx": 92, "completion": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n[DONE]"}
{"idx": 93, "completion": "def sort_sublists(l):\n    return [sorted(sublist, key=lambda x: x) for sublist in l]\n[DONE]"}
{"idx": 94, "completion": "def count(lst):\n    return sum(1 for x in lst if x)\n[DONE]"}
{"idx": 95, "completion": "def add_lists(test_list, test_tup):\n    res = test_tup + tuple(test_list)\n    return res\n[DONE]"}
{"idx": 96, "completion": "def count_Hexadecimal(l, r):\n    count = 0\n    for num in range(l, r + 1):\n        if num < 0:\n            continue\n        s = hex(num)\n        if '0x' in s and len(s) == 3 and s[2] in 'abcdef':\n            count += 1\n    return count\n[DONE]"}
{"idx": 97, "completion": "import heapq\n\ndef merge_sorted_list(list1, list2, list3):\n    merged = []\n    heap = []\n    \n    # Push the first element of each list into the heap with their list index\n    if list1:\n        heapq.heappush(heap, (list1[0], 0, list1))\n    if list2:\n        heapq.heappush(heap, (list2[0], 0, list2))\n    if list3:\n        heapq.heappush(heap, (list3[0], 0, list3))\n    \n    while heap:\n        val, idx, lst = heapq.heappop(heap)\n        merged.append(val)\n        if idx + 1 < len(lst):\n            next_val = lst[idx + 1]\n            heapq.heappush(heap, (next_val, idx + 1, lst))\n    \n    return merged\n[DONE]"}
{"idx": 98, "completion": "def odd_Equivalent(s, n):\n    count = 0\n    for i in range(n):\n        if int(s, 2) % 2 != 0:\n            count += 1\n        s = s[-1] + s[:-1]\n    return count\n[DONE]"}
{"idx": 99, "completion": "def extract_missing(ranges, start, end):\n    missing_ranges = []\n    # Process the start to the first range's start\n    if ranges:\n        first_start = ranges[0][0]\n        if start < first_start:\n            missing_ranges.append((start, first_start))\n    else:\n        if start < end:\n            missing_ranges.append((start, end))\n        return missing_ranges\n\n    # Process between ranges\n    for i in range(len(ranges) - 1):\n        current_end = ranges[i][1]\n        next_start = ranges[i+1][0]\n        if current_end < next_start:\n            missing_ranges.append((current_end, next_start))\n\n    # Process the last range's end to the end\n    if ranges:\n        last_end = ranges[-1][1]\n        if last_end < end:\n            missing_ranges.append((last_end, end))\n\n    # Also, if any range's start is greater than the next range's start, we need to handle it\n    # But the problem's test cases seem to have ranges that are not in order, so we need to sort first\n    # So first, we need to sort the ranges based on their start\n    sorted_ranges = sorted(ranges, key=lambda x: x[0])\n    missing_ranges = []\n    # Now, process the start to the first range's start\n    if sorted_ranges:\n        first_start = sorted_ranges[0][0]\n        if start < first_start:\n            missing_ranges.append((start, first_start))\n    else:\n        if start < end:\n            missing_ranges.append((start, end))\n        return missing_ranges\n\n    # Process between ranges\n    for i in range(len(sorted_ranges) - 1):\n        current_end = sorted_ranges[i][1]\n        next_start = sorted_ranges[i+1][0]\n        if current_end < next_start:\n            missing_ranges.append((current_end, next_start))\n\n    # Process the last range's end to the end\n    if sorted_ranges:\n        last_end = sorted_ranges[-1][1]\n        if last_end < end:\n            missing_ranges.append((last_end, end))\n\n    return missing_ranges\n[DONE]"}
{"idx": 100, "completion": "def common_in_nested_lists(nested_list):\n    if not nested_list:\n        return []\n    common_elements = set(nested_list[0])\n    for lst in nested_list[1:]:\n        common_elements.intersection_update(lst)\n    return sorted(common_elements, reverse=True)\n[DONE]"}
{"idx": 101, "completion": "import math\ndef perimeter(r, h):\n    perimeter = 2 * math.pi * r * h\n    return perimeter\n[DONE]"}
{"idx": 102, "completion": "def check_integer(string):\n    if string.isdigit():\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 103, "completion": "from collections import defaultdict\n\ndef assign_freq(test_list):\n    freq = defaultdict(int)\n    for t in test_list:\n        freq[t] += 1\n    result = []\n    for t in test_list:\n        if t in freq:\n            new_t = t + (freq[t],)\n            result.append(new_t)\n            del freq[t]\n    return str(result)\n[DONE]"}
{"idx": 104, "completion": "def empty_dit(list1):\n    for d in list1:\n        if d:\n            return False\n    return True\n[DONE]"}
{"idx": 105, "completion": "def tuple_to_int(tup):\n    res = int(''.join(map(str, tup)))\n    return res\n[DONE]"}
{"idx": 106, "completion": "def list_to_float(test_list):\n    converted = []\n    for tup in test_list:\n        new_tup = []\n        for elem in tup:\n            try:\n                new_elem = float(elem)\n            except ValueError:\n                new_elem = elem\n            new_tup.append(new_elem)\n        converted.append(tuple(new_tup))\n    return str(converted)\n[DONE]"}
{"idx": 107, "completion": "def string_to_list(string):\n    res = list(string.split(\" \"))\n    return res\n[DONE]"}
{"idx": 108, "completion": "def search(arr, n):\n    for i in range(0, n, 2):\n        if i == n - 1 or arr[i] != arr[i + 1]:\n            return arr[i]\n    return -1\n[DONE]"}
{"idx": 109, "completion": "def max_product_tuple(list1):\n    max_product = 0\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product > max_product:\n            max_product = product\n    return max_product\n[DONE]"}
{"idx": 110, "completion": "def check_triplet(arr, n, sum, i):\n    if i == 0:\n        if sum == 0:\n            return True\n        else:\n            return False\n    if n == 0:\n        return False\n    if arr[n-1] > sum:\n        return check_triplet(arr, n-1, sum, i)\n    return check_triplet(arr, n-1, sum, i) or check_triplet(arr, n-1, sum-arr[n-1], i-1)\n[DONE]"}
{"idx": 111, "completion": "def smartNumber(n):\n    count = 0\n    num = 1\n    while True:\n        temp = num\n        factors = set()\n        for i in [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,"}
{"idx": 112, "completion": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        if num < 2:\n            return 0\n        sum_div = 1\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                if i == num // i:\n                    sum_div += i\n                else:\n                    sum_div += i + num // i\n        return sum_div\n\n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = sum_proper_divisors(a)\n        if a != b and a == sum_proper_divisors(b) and a < b:\n            amicable_sum += a + b\n    return amicable_sum\n[DONE]"}
{"idx": 113, "completion": "import cmath\ndef angle_complex(x, y):\n    z = x + y\n    return cmath.phase(z)\n[DONE]"}
{"idx": 114, "completion": "def find_length(bin_str, n):\n    max_diff = 0\n    for i in range(n):\n        for j in range(i, n):\n            substring = bin_str[i:j+1]\n            count0 = substring.count('0')\n            count1 = substring.count('1')\n            current_diff = abs(count0 - count1)\n            if current_diff > max_diff:\n                max_diff = current_diff\n    return max_diff\n[DONE]"}
{"idx": 115, "completion": "def sum(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    def get_common_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_divisors = get_common_divisors(gcd(a, b))\n    return sum(common_divisors)\n[DONE]"}
{"idx": 116, "completion": "def multiply_int(a, b):\n    result = 0\n    for _ in range(abs(b)):\n        result += a\n    return result if b > 0 else -result\n[DONE]"}
{"idx": 117, "completion": "def long_words(n, str):\n    word_list = str.split()\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list\n[DONE]"}
{"idx": 118, "completion": "def magic_square_test(square):\n    n = len(square)\n    magic_constant = n * (n**2 + 1) // 2\n\n    # Check rows\n    for row in square:\n        if sum(row) != magic_constant:\n            return False\n\n    # Check columns\n    for j in range(n):\n        if sum(square[i][j] for i in range(n)) != magic_constant:\n            return False\n\n    # Check main diagonal\n    if sum(square[i][i] for i in range(n)) != magic_constant:\n        return False\n\n    # Check secondary diagonal\n    if sum(square[i][n - 1 - i] for i in range(n)) != magic_constant:\n        return False\n\n    return True\n[DONE]"}
{"idx": 119, "completion": "from collections import Counter\ndef max_occurrences(nums):\n    count = Counter(nums)\n    max_count = max(count.values())\n    max_num = [num for num, cnt in count.items() if cnt == max_count][0]\n    return (max_num, max_count)\n[DONE]"}
{"idx": 120, "completion": "def reverse_vowels(s):\n    vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    s_list = list(s)\n    vowel_indices = [i for i, char in enumerate(s_list) if char in vowels]\n    vowel_chars = [s_list[i] for i in vowel_indices]\n    vowel_chars.reverse()\n    for i, index in enumerate(vowel_indices):\n        s_list[index] = vowel_chars[i]\n    return ''.join(s_list)\n[DONE]"}
{"idx": 121, "completion": "def tup_string(tup):\n    return ''.join(tup)\n[DONE]"}
{"idx": 122, "completion": "def sum_negativenum(nums):\n    negative_nums = list(filter(lambda x: x < 0, nums))\n    return sum(negative_nums)\n[DONE]"}
{"idx": 123, "completion": "def check_last(arr, n, p):\n    for _ in range(p):\n        for i in range(n-1):\n            arr[i] = arr[i] + arr[i+1]\n    if arr[-1] % 2 == 0:\n        return \"EVEN\"\n    else:\n        return \"ODD\"\n[DONE]"}
{"idx": 124, "completion": "def hexagonal_num(n):\n    return n * (2 * n - 1)\n[DONE]"}
{"idx": 125, "completion": "def cal_electbill(units):\n    if units <= 50:\n        bill = units * 2.5\n    elif units <= 150:\n        bill = 50 * 2.5 + (units - 50) * 3.5\n    elif units <= 250:\n        bill = 50 * 2.5 + 100 * 3.5 + (units - 150) * 4.5\n    else:\n        bill = 50 * 2.5 + 100 * 3.5 + 100 * 4.5 + (units - 250) * 5.5\n    return bill\n[DONE]"}
{"idx": 126, "completion": "def zero_count(nums):\n    count = nums.count(0)\n    ratio = round(count / len(nums), 2)\n    return ratio\n[DONE]"}
{"idx": 127, "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0:\n        return False\n    while n > 0:\n        if n % 2 == 1 and (n // 2) % 2 == 1:\n            return False\n        n = n // 2\n    return True\n[DONE]"}
{"idx": 128, "completion": "import math\ndef circle_circumference(radius):\n    circumference = 2 * math.pi * radius\n    return circumference\n[DONE]"}
{"idx": 129, "completion": "def extract_singly(test_list):\n    res = []\n    for tup in test_list:\n        for ele in tup:\n            if ele not in res:\n                res.append(ele)\n    return res\n[DONE]"}
{"idx": 130, "completion": "def pancake_sort(arr):\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_idx = arr.index(max(arr[:size]))\n        if max_idx != size - 1:\n            arr[:max_idx + 1] = reversed(arr[:max_idx + 1])\n            arr[:size] = reversed(arr[:size])\n    return arr\n[DONE]"}
{"idx": 131, "completion": "def count_samepair(list1,list2,list3):\n    ctr = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            ctr += 1\n    return ctr\n[DONE]"}
{"idx": 132, "completion": "def find_lists(tuple1):\n    count = 0\n    for element in tuple1:\n        if isinstance(element, list):\n            count += 1\n    return count\n[DONE]"}
{"idx": 133, "completion": "def sum_Pairs(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += abs(arr[i] - arr[j])\n    return sum\n[DONE]"}
{"idx": 134, "completion": "def max_Abs_Diff(arr, n):\n    max_diff = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff\n[DONE]"}
{"idx": 135, "completion": "def ascii_value_string(s):\n    total = 0\n    for char in s:\n        total += ord(char)\n    return total\n[DONE]"}
{"idx": 136, "completion": "def max_path_sum(triangle, row, col):\n    for i in range(row - 1, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n[DONE]"}
{"idx": 137, "completion": "def sum_digits_twoparts(n):\n    s = str(n)\n    max_sum = 0\n    for i in range(1, len(s)):\n        part1 = int(s[:i])\n        part2 = int(s[i:])\n        current_sum = sum(int(d) for d in str(part1)) + sum(int(d) for d in str(part2))\n        if current_sum > max_sum:\n            max_sum = current_sum\n    if len(s) == 1:\n        return n\n    return max_sum\n[DONE]"}
{"idx": 138, "completion": "def longest_subseq_with_diff_one(arr, n):\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if (arr[i] == arr[j] + 1) or (arr[i] == arr[j] - 1):\n                if dp[i] < dp[j] + 1:\n                    dp[i] = dp[j] + 1\n    return max(dp)\n[DONE]"}
{"idx": 139, "completion": "def does_Contain_B(a, b, c):\n    if (b - a) % c == 0 and (b - a) // c >= 0:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 140, "completion": "import math\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1\n[DONE]"}
{"idx": 141, "completion": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    return arr\n[DONE]"}
{"idx": 142, "completion": "def parabola_vertex(a, b, c):\n    x = -b / (2 * a)\n    y = (4 * a * c - b**2) / (4 * a)\n    return (x, y)\n[DONE]"}
{"idx": 143, "completion": "def specified_element(lst, n):\n    res = [i[n] for i in lst]\n    return res\n[DONE]"}
{"idx": 144, "completion": "def even_bit_toggle_number(n):\n    mask = 0xAAAAAAAA  # This is a 32-bit mask where even bits are set (bits 0, 2, 4, ... are 0; bits 1, 3, 5, ... are 1)\n    return n ^ mask\n[DONE]"}
{"idx": 145, "completion": "def tuple_int_str(tuple1):\n    result = tuple(tuple(int(x) for x in inner) for inner in tuple1)\n    return result\n[DONE]"}
{"idx": 146, "completion": "def encode_list(s):\n    if not s:\n        return []\n    result = []\n    current = s[0]\n    count = 1\n    for item in s[1:]:\n        if item == current:\n            count += 1\n        else:\n            result.append([count, current])\n            current = item\n            count = 1\n    result.append([count, current])\n    return result\n[DONE]"}
{"idx": 147, "completion": "def min_Ops(arr, n, k):\n    if n == 0:\n        return 0\n    arr = sorted(arr)\n    median = arr[n // 2]\n    operations = 0\n    for num in arr:\n        diff = abs(num - median)\n        if diff % k != 0:\n            return -1\n        operations += diff // k\n    return operations\n[DONE]"}
{"idx": 148, "completion": "def month_season(month, day):\n    if month in ('January', 'February', 'March'):\n        season = 'winter'\n    elif month in ('April', 'May', 'June'):\n        season = 'spring'\n    elif month in ('July', 'August', 'September'):\n        season = 'summer'\n    else:\n        season = 'autumn'\n    if (month == 'March') and (day > 19):\n        season = 'spring'\n    elif (month == 'June') and (day > 20):\n        season = 'summer'\n    elif (month == 'September') and (day > 21):\n        season = 'autumn'\n    elif (month == 'December') and (day > 20):\n        season = 'winter'\n    return season\n[DONE]"}
{"idx": 149, "completion": "def solution(a, b, n):\n    for x in range(0, n + 1):\n        for y in range(0, n + 1):\n            if (a * x) + (b * y) == n:\n                return ('x = ', x, ', y = ', y)\n    return 'No solution'\n[DONE]"}
{"idx": 150, "completion": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n[DONE]"}
{"idx": 151, "completion": "def sum_series(n):\n    sum = 0\n    while n > 0:\n        sum += n\n        n -= 2\n    return sum\n[DONE]"}
{"idx": 152, "completion": "import math\ndef area_polygon(n, s):\n    area = (n * s ** 2) / (4 * math.tan(math.pi / n))\n    return area\n[DONE]"}
{"idx": 153, "completion": "import math\ndef areEquivalent(a, b):\n    def sum_divisors(n):\n        if n == 1:\n            return 1\n        total = 1\n        for i in range(2, int(math.sqrt(n)) + 1):\n            if n % i == 0:\n                if i == n // i:\n                    total += i\n                else:\n                    total += i + n // i\n        return total\n    return sum_divisors(a) == sum_divisors(b)\n[DONE]"}
{"idx": 154, "completion": "def count_char_position(str1):\n    count = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('A')) or (i == ord(str1[i]) - ord('a'))):\n            count += 1\n    return count\n[DONE]"}
{"idx": 155, "completion": "def find_even_Pair(A, n):\n    count = 0\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if (A[i] ^ A[j]) % 2 == 0:\n                count += 1\n    return count\n[DONE]"}
{"idx": 156, "completion": "def next_Power_Of_2(n): \n    if n == 0:\n        return 1\n    count = 0\n    while n != 0:\n        n >>= 1\n        count += 1\n    return 1 << count\n[DONE]"}
{"idx": 157, "completion": "def frequency(arr, num):\n    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count\n[DONE]"}
{"idx": 158, "completion": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            c = 2 * b + a\n            a, b = b, c\n        return b\n[DONE]"}
{"idx": 159, "completion": "def sum_range_list(list1, start, end):\n    sum_range = 0\n    for i in range(start, end+1):\n        sum_range += list1[i]\n    return sum_range\n[DONE]"}
{"idx": 160, "completion": "def perimeter_pentagon(a):\n    perimeter = 5 * a\n    return perimeter\n[DONE]"}
{"idx": 161, "completion": "def count_occurance(string):\n    count = 0\n    for i in range(len(string) - 2):\n        if string[i] == 's' and string[i+1] == 't' and string[i+2] == 'd':\n            count += 1\n    return count\n[DONE]"}
{"idx": 162, "completion": "import re\ndef remove_splchar(string):\n    return re.sub(r'[^a-zA-Z0-9]', '', string)\n[DONE]"}
{"idx": 163, "completion": "def group_keyvalue(test_list):\n    res = {}\n    for key, val in test_list:\n        res.setdefault(key, []).append(val)\n    return res\n[DONE]"}
{"idx": 164, "completion": "def is_valid_parenthese(str1):\n    stack = []\n    pchar = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n    for parenthese in str1:\n        if parenthese in pchar:\n            stack.append(parenthese)\n        elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\n            return False\n    return len(stack) == 0\n[DONE]"}
{"idx": 165, "completion": "def perimeter_triangle(a, b, c):\n    perimeter = a + b + c\n    return perimeter\n[DONE]"}
{"idx": 166, "completion": "import math\n\ndef answer(l, r):\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            lcm = (a * b) // math.gcd(a, b)\n            if l <= lcm <= r:\n                return (a, b)\n    return (l, l + 1)\n[DONE]"}
{"idx": 167, "completion": "def string_literals(needles, haystack):\n    for needle in needles:\n        if needle in haystack:\n            return \"Matched!\"\n    return \"Not Matched!\"\n[DONE]"}
{"idx": 168, "completion": "def is_num_keith(n):\n    if n < 10:\n        return False\n    digits = [int(d) for d in str(n)]\n    k = len(digits)\n    sequence = digits.copy()\n    while sequence[-1] < n:\n        next_num = sum(sequence[-k:])\n        sequence.append(next_num)\n    return sequence[-1] == n\n[DONE]"}
{"idx": 169, "completion": "import math\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    R = 6371.0\n    distance = R * c\n    return distance * 1000\n[DONE]"}
{"idx": 170, "completion": "def common_prefix(arr, n):\n    if not arr:\n        return \"\"\n    min_len = min(len(s) for s in arr)\n    prefix = \"\"\n    for i in range(min_len):\n        char = arr[0][i]\n        for s in arr[1:]:\n            if i >= len(s) or s[i] != char:\n                return prefix\n        prefix += char\n    return prefix\n[DONE]"}
{"idx": 171, "completion": "import re\ndef find_character(test_str):\n    up_char = re.findall(r'[A-Z]', test_str)\n    low_char = re.findall(r'[a-z]', test_str)\n    num = re.findall(r'[0-9]', test_str)\n    special = re.findall(r'[^A-Za-z0-9]', test_str)\n    return (up_char, low_char, num, special)\n[DONE]"}
{"idx": 172, "completion": "def count_pairs(arr, n, k):\n    count = 0\n    arr = list(set(arr))\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            if abs(arr[i] - arr[j]) == k:\n                count += 1\n    return count\n[DONE]"}
{"idx": 173, "completion": "def greater_specificnum(nums, x):\n    for num in nums:\n        if num > x:\n            return True\n    return False\n[DONE]"}
{"idx": 174, "completion": "def parabola_focus(a, b, c):\n    x = -b / (2 * a)\n    y = (4 * a * c - b**2) / (4 * a)\n    return (x, y)\n[DONE]"}
{"idx": 175, "completion": "import re\ndef check_literals(text, patterns):\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return 'Matched!'\n    return 'Not Matched!'\n[DONE]"}
{"idx": 176, "completion": "def longest_common_subsequence(s1, s2, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n[DONE]"}
{"idx": 177, "completion": "import math\n\ndef prod_Square(n):\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % (i * i) == 0:\n            quotient = n // (i * i)\n            if (math.isqrt(quotient) ** 2) == quotient:\n                return True\n    return False\n[DONE]"}
{"idx": 178, "completion": "def first_Missing_Positive(nums, n):\n    for i in range(1, n + 2):\n        if i not in nums:\n            return i\n    return -1\n[DONE]"}
{"idx": 179, "completion": "def count_Intgral_Points(x1, y1, x2, y2):\n    return (abs(x2 - x1) - 1) * (abs(y2 - y1) - 1)\n[DONE]"}
{"idx": 180, "completion": "def check_monthnumber(month):\n    thirty_days_months = [\"April\", \"June\", \"September\", \"November\"]\n    return month in thirty_days_months\n[DONE]"}
{"idx": 181, "completion": "def check_String(test_str):\n    res = any(chr.isalpha() for chr in test_str) and any(chr.isdigit() for chr in test_str)\n    return (res)\n[DONE]"}
{"idx": 182, "completion": "def remove_tuple(test_tup):\n    res = []\n    for ele in test_tup:\n        if ele not in res:\n            res.append(ele)\n    return tuple(res)\n[DONE]"}
{"idx": 183, "completion": "def octal_To_Decimal(n):\n    return int(str(n), 8)\n[DONE]"}
{"idx": 184, "completion": "def first(arr, low, high, x, n):\n    if high >= low:\n        mid = (low + high) // 2\n        if (mid == 0 or x > arr[mid - 1]) and arr[mid] == x:\n            return mid\n        elif x > arr[mid]:\n            return first(arr, (mid + 1), high, x, n)\n        else:\n            return first(arr, low, (mid - 1), x, n)\n    return -1\n\ndef first(arr, x, n):\n    return first(arr, 0, n - 1, x, n)\n[DONE]"}
{"idx": 185, "completion": "def remove_tuples(test_list, K):\n    res = [ele for ele in test_list if len(ele) != K]\n    return (res)\n[DONE]"}
{"idx": 186, "completion": "def find_exponentio(test_tup1, test_tup2):\n    res = tuple(pow(a, b) for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 187, "completion": "import math\ndef largest_triangle(a, b):\n    area = (3 * math.sqrt(3) * a * b) / 4\n    return area\n[DONE]"}
{"idx": 188, "completion": "import math\ndef highest_Power_of_2(n):\n    power = 0\n    while 2 ** (power + 1) <= n:\n        power += 1\n    return 2 ** power\n[DONE]"}
{"idx": 189, "completion": "def position_max(nums):\n    max_val = max(nums)\n    positions = [i for i, x in enumerate(nums) if x == max_val]\n    return positions\n[DONE]"}
{"idx": 190, "completion": "def chkList(lst):\n    return all(x == lst[0] for x in lst)\n[DONE]"}
{"idx": 191, "completion": "def remove_even(test_str):\n    res = \"\"\n    for i in range(len(test_str)):\n        if i % 2 != 0:\n            res = res + test_str[i]\n    return res\n[DONE]"}
{"idx": 192, "completion": "def hamming_Distance(x, y):\n    return bin(x^y).count('1')\n[DONE]"}
{"idx": 193, "completion": "def count(str1,str2): \n    res = 0\n    for i in range(len(str1)): \n        if str1[i] == str2: \n            res += 1\n    return res\n[DONE]"}
{"idx": 194, "completion": "def inversion_elements(test_tup):\n    res = tuple(-x - 1 for x in test_tup)\n    return res\n[DONE]"}
{"idx": 195, "completion": "def concatenate_elements(test_tup):\n    res = tuple(test_tup[i] + test_tup[i + 1] for i in range(len(test_tup) - 1))\n    return res\n[DONE]"}
{"idx": 196, "completion": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == s[j - 1] and i != j:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][n]\n[DONE]"}
{"idx": 197, "completion": "import re\ndef is_decimal(num):\n    pattern = re.compile(r'^\\d+\\.\\d{2}$')\n    return bool(pattern.match(num))\n[DONE]"}
{"idx": 198, "completion": "import heapq\ndef heap_replace(heap, item):\n    if not heap:\n        return []\n    heapq.heapify(heap)\n    heapq.heappop(heap)\n    heapq.heappush(heap, item)\n    return heap\n[DONE]"}
{"idx": 199, "completion": "import re\ndef is_allowed_specific_char(string):\n    pattern = re.compile(r'[^a-zA-Z0-9]')\n    if pattern.search(string):\n        return False\n    else:\n        return True\n[DONE]"}
{"idx": 200, "completion": "def count_Num(n):\n    count = 0\n    for i in range(1, 2**n):\n        if (i & (1 << 0)) and (i & (1 << (n-1))):\n            count += 1\n    return count\n[DONE]"}
{"idx": 201, "completion": "def fourth_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**4\n    return sum\n[DONE]"}
{"idx": 202, "completion": "def concatenate_strings(test_tup1, test_tup2):\n    res = tuple(a + b for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 203, "completion": "import math\ndef degree_radian(degree):\n    radian = degree * (180 / math.pi)\n    return radian\n[DONE]"}
{"idx": 204, "completion": "def decode_list(encoded_list):\n    decoded_list = []\n    for element in encoded_list:\n        if isinstance(element, list) and len(element) == 2:\n            count, value = element\n            decoded_list.extend([value] * count)\n        else:\n            decoded_list.append(element)\n    return decoded_list\n[DONE]"}
{"idx": 205, "completion": "def check_subset_list(test_list, sub_list):\n    for lst in sub_list:\n        if lst not in test_list:\n            return False\n    return True\n[DONE]"}
{"idx": 206, "completion": "def first_Repeated_Char(str1):\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return '\\0'\n[DONE]"}
{"idx": 207, "completion": "def min_Operations(x, y):\n    if x == y:\n        return 0\n    if x > y:\n        return x - y\n    if y % 2 == 1:\n        return 1 + min_Operations(x, y + 1)\n    else:\n        return 1 + min_Operations(x, y // 2)\n[DONE]"}
{"idx": 208, "completion": "def extract_min_max(test_tup, K):\n    sorted_tup = sorted(test_tup)\n    min_k = tuple(sorted_tup[:K])\n    max_k = tuple(sorted_tup[-K:])\n    result = min_k + max_k\n    return result\n[DONE]"}
{"idx": 209, "completion": "import re\ndef replace_max_specialchar(string, n):\n    # Replace up to n occurrences of spaces, commas, or dots with a colon\n    pattern = r'[ ,.]'\n    # Find all matches\n    matches = re.findall(pattern, string)\n    # Replace the first n matches\n    count = 0\n    result = []\n    for char in string:\n        if re.match(pattern, char) and count < n:\n            result.append(':')\n            count += 1\n        else:\n            result.append(char)\n    return ''.join(result)\n[DONE]"}
{"idx": 210, "completion": "def first_even(lst):\n    for num in lst:\n        if num % 2 == 0:\n            return num\n    return None\n[DONE]"}
{"idx": 211, "completion": "def check_type(test_tup):\n    if len(test_tup) == 0:\n        return True\n    first_type = type(test_tup[0])\n    for element in test_tup[1:]:\n        if type(element) != first_type:\n            return False\n    return True\n[DONE]"}
{"idx": 212, "completion": "def is_majority(arr, n, x):\n    first = 0\n    last = n - 1\n    while first <= last:\n        mid = (first + last) // 2\n        if arr[mid] == x:\n            if mid + n // 2 < n and arr[mid + n // 2] == x:\n                return True\n            else:\n                return False\n        elif arr[mid] < x:\n            first = mid + 1\n        else:\n            last = mid - 1\n    return False\n[DONE]"}
{"idx": 213, "completion": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        n &= n - 1\n        count += 1\n    return count\n[DONE]"}
{"idx": 214, "completion": "def find_Min(arr, low, high):\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < high and arr[mid+1] < arr[mid]:\n        return arr[mid+1]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid-1)\n    return find_Min(arr, mid+1, high)\n[DONE]"}
{"idx": 215, "completion": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result\n[DONE]"}
{"idx": 216, "completion": "def min_of_three(x, y, z):\n    if x <= y and x <= z:\n        return x\n    elif y <= x and y <= z:\n        return y\n    else:\n        return z\n[DONE]"}
{"idx": 217, "completion": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    for i in range(l, r+1):\n        if (n & (1 << (i-1))) != 0:\n            return False\n    return True\n[DONE]"}
{"idx": 218, "completion": "def re_arrange_array(arr, n):\n    j = 0\n    for i in range(n):\n        if arr[i] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    return arr\n[DONE]"}
{"idx": 219, "completion": "def replace_blank(string, char):\n    return string.replace(' ', char)\n[DONE]"}
{"idx": 220, "completion": "def max_sum(triangle, size):\n    for i in range(size - 2, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n[DONE]"}
{"idx": 221, "completion": "def larg_nnum(list1, n):\n    list1.sort()\n    list1 = list1[-n:]\n    list1.reverse()\n    return list1\n[DONE]"}
{"idx": 222, "completion": "import math\ndef lateralsuface_cylinder(r, h):\n    return 2 * math.pi * r * h\n[DONE]"}
{"idx": 223, "completion": "def volume_cube(side):\n    return side ** 3\n[DONE]"}
{"idx": 224, "completion": "def even_bit_set_number(number):\n    mask = 0xAAAAAAAA  # Binary: 10101010101010101010101010101010 (32 bits)\n    result = number | mask\n    return result\n[DONE]"}
{"idx": 225, "completion": "def No_of_Triangle(N, K):\n    if K > N:\n        return -1\n    if K == 1:\n        return (N * (N + 1)) // 2\n    if K == N:\n        return 1\n    return (N - K + 1) * (N - K + 2) // 2\n[DONE]"}
{"idx": 226, "completion": "def check_occurences(test_list):\n    freq_dict = {}\n    for tup in test_list:\n        sorted_tup = tuple(sorted(tup))\n        if sorted_tup in freq_dict:\n            freq_dict[sorted_tup] += 1\n        else:\n            freq_dict[sorted_tup] = 1\n    return freq_dict\n[DONE]"}
{"idx": 227, "completion": "def number_of_substrings(str):\n    n = len(str)\n    return int(n * (n + 1) / 2)\n[DONE]"}
{"idx": 228, "completion": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m\n    count = 0\n    for i in range(1, m//(2**(n-1)) + 1):\n        count += get_total_number_of_sequences(m, n-1)\n    return count\n[DONE]"}
{"idx": 229, "completion": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1\n[DONE]"}
{"idx": 230, "completion": "def array_3d(x, y, z):\n    array = []\n    for i in range(z):\n        array_2d = []\n        for j in range(y):\n            array_1d = []\n            for k in range(x):\n                array_1d.append('*')\n            array_2d.append(array_1d)\n        array.append(array_2d)\n    return array\n[DONE]"}
{"idx": 231, "completion": "def count_charac(string):\n    return len(string)\n[DONE]"}
{"idx": 232, "completion": "from collections import defaultdict\n\ndef sort_on_occurence(lst):\n    d = defaultdict(list)\n    for key, value in lst:\n        d[key].append(value)\n    result = []\n    for key in d:\n        values = d[key]\n        count = len(values)\n        if count > 1:\n            result.append((key, *values, count))\n        else:\n            result.append((key, values[0], count))\n    return result\n[DONE]"}
{"idx": 233, "completion": "import math\ndef next_Perfect_Square(N):\n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN\n[DONE]"}
{"idx": 234, "completion": "def max_sum(arr, n):\n    # Create two arrays to store the increasing and decreasing sequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Initialize the first element for both arrays\n    inc[0] = arr[0]\n    dec[n-1] = arr[n-1]\n    \n    # Compute the increasing sequence from left to right\n    for i in range(1, n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Compute the decreasing sequence from right to left\n    for i in range(n-2, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n-1, i, -1):\n            if arr[j] < arr[i] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum sum of inc[i] + dec[i] - arr[i]\n    max_sum = 0\n    for i in range(n):\n        current_sum = inc[i] + dec[i] - arr[i]\n        if current_sum > max_sum:\n            max_sum = current_sum\n    \n    return max_sum\n[DONE]"}
{"idx": 235, "completion": "def babylonian_squareroot(number):\n    if number == 0:\n        return 0\n    guess = number / 2.0\n    while True:\n        new_guess = (guess + number / guess) / 2\n        if abs(new_guess - guess) < 1e-10:  # Very small difference\n            break\n        guess = new_guess\n    return new_guess\n[DONE]"}
{"idx": 236, "completion": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n[DONE]"}
{"idx": 237, "completion": "def harmonic_sum(n):\n    total = 0.0\n    for i in range(1, n + 1):\n        total += 1 / i\n    return total\n[DONE]"}
{"idx": 238, "completion": "def intersection_array(arr1, arr2):\n    result = list(filter(lambda x: x in arr1, arr2))\n    return result\n[DONE]"}
{"idx": 239, "completion": "def count_X(tup, X):\n    count = 0\n    for elem in tup:\n        if elem == X:\n            count += 1\n    return count\n[DONE]"}
{"idx": 240, "completion": "def insert_element(original_list, element):\n    new_list = []\n    for item in original_list:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list\n[DONE]"}
{"idx": 241, "completion": "import cmath\ndef convert(n):\n    cn = complex(n,0)\n    polar = cmath.polar(cn)\n    return (polar[0], polar[1])\n[DONE]"}
{"idx": 242, "completion": "def count_integer(list1):\n    count = 0\n    for ele in list1:\n        if isinstance(ele, int) and not isinstance(ele, bool):\n            count += 1\n    return count\n[DONE]"}
{"idx": 243, "completion": "def words_ae(test_str):\n    res = []\n    for word in test_str.split():\n        if word[0] in ['a', 'e']:\n            res.append(word)\n    return res\n[DONE]"}
{"idx": 244, "completion": "from itertools import combinations_with_replacement\ndef combinations_colors(colors, r):\n    return list(combinations_with_replacement(colors, r))\n[DONE]"}
{"idx": 245, "completion": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    is_prime = [True] * n\n    is_prime[0] = is_prime[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if is_prime[i]:\n            for j in range(i * i, n, i):\n                is_prime[j] = False\n    return sum(is_prime)\n[DONE]"}
{"idx": 246, "completion": "def swap_numbers(a, b):\n    return (b, a)\n[DONE]"}
{"idx": 247, "completion": "def count_odd(nums):\n    count_odd = len(list(filter(lambda x: (x%2 != 0) , nums)))\n    return count_odd\n[DONE]"}
{"idx": 248, "completion": "def maximize_elements(test_tup1, test_tup2):\n    res = tuple(tuple(max(a, b) for a, b in zip(t1, t2)) for t1, t2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 249, "completion": "def newman_prime(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    a, b = 1, 1\n    for _ in range(2, n + 1):\n        a, b = b, 2 * b + a\n    return b\n[DONE]"}
{"idx": 250, "completion": "def division_elements(test_tup1, test_tup2):\n    res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 251, "completion": "def split_two_parts(lst, n):\n    return (lst[:n], lst[n:])\n[DONE]"}
{"idx": 252, "completion": "def merge_dict(dict1, dict2):\n    res = {**dict1, **dict2}\n    return res\n[DONE]"}
{"idx": 253, "completion": "def dog_age(age):\n    if age <= 2:\n        dog_age = age * 10.5\n    else:\n        dog_age = 21 + (age - 2) * 4\n    return int(dog_age)\n[DONE]"}
{"idx": 254, "completion": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result\n[DONE]"}
{"idx": 255, "completion": "def lateralsurface_cube(l):\n    return 4 * (l ** 2)\n[DONE]"}
{"idx": 256, "completion": "def square_Sum(n):\n    sum = 0\n    for i in range(1, 2 * n, 2):\n        sum += i ** 2\n    return sum\n[DONE]"}
{"idx": 257, "completion": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1\n[DONE]"}
{"idx": 258, "completion": "def ascii_value(char):\n    return ord(char)\n[DONE]"}
{"idx": 259, "completion": "def sum_even_and_even_index(arr, n):\n    sum = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum += arr[i]\n    return sum\n[DONE]"}
{"idx": 260, "completion": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 5\n    return sum\n[DONE]"}
{"idx": 261, "completion": "def rear_extract(lst):\n    return [t[-1] for t in lst]\n[DONE]"}
{"idx": 262, "completion": "def substract_elements(test_tup1, test_tup2):\n    res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 263, "completion": "def even_binomial_Coeff_Sum(n):\n    return 2 ** (n - 1)\n[DONE]"}
{"idx": 264, "completion": "def get_Position(arr, n, k):\n    for i in range(n):\n        if arr[i] == k:\n            return i + 1\n    return -1\n[DONE]"}
{"idx": 265, "completion": "import math\ndef volume_cylinder(r, h):\n    volume = math.pi * r * r * h\n    return volume\n[DONE]"}
{"idx": 266, "completion": "def dict_filter(dict1, n):\n    new_dict = {k: v for k, v in dict1.items() if v >= n}\n    return new_dict\n[DONE]"}
{"idx": 267, "completion": "def count_first_elements(test_tup):\n    count = 0\n    for element in test_tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count\n[DONE]"}
{"idx": 268, "completion": "def is_num_decagonal(n):\n    return 4 * n * n - 3 * n\n[DONE]"}
{"idx": 269, "completion": "def sequential_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return (True, i)\n    return (False, -1)\n[DONE]"}
{"idx": 270, "completion": "def all_unique(lst):\n    return len(lst) == len(set(lst))\n[DONE]"}
{"idx": 271, "completion": "def sub_list(lst1, lst2):\n    res = list(map(lambda x, y: x - y, lst1, lst2))\n    return res\n[DONE]"}
{"idx": 272, "completion": "def validate(n):\n    s = str(n)\n    for d in s:\n        if s.count(d) > int(d):\n            return False\n    return True\n[DONE]"}
{"idx": 273, "completion": "def check_element(lst, element):\n    for item in lst:\n        if item != element:\n            return False\n    return True\n[DONE]"}
{"idx": 274, "completion": "import re\ndef text_match_two_three(text):\n    if re.search(r'ab{2,3}', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 275, "completion": "def max_sub_array_sum_repeated(a, n, k):\n    max_kadane = kadane(a)\n    if k == 1:\n        return max_kadane\n    max_wrap = 0\n    for i in range(n):\n        max_wrap += a[i]\n    if max_wrap <= 0:\n        return max_kadane\n    else:\n        return max(max_kadane, max_wrap * (k - 2) + kadane_start(a) + kadane_end(a))\n\ndef kadane(a):\n    n = len(a)\n    max_so_far = -float('inf')\n    max_ending_here = 0\n    for i in range(n):\n        max_ending_here = max_ending_here + a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far\n\ndef kadane_start(a):\n    n = len(a)\n    max_so_far = -float('inf')\n    max_ending_here = 0\n    for i in range(n):\n        max_ending_here = max_ending_here + a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n    return max_so_far\n\ndef kadane_end(a):\n    n = len(a)\n    max_so_far = -float('inf')\n    max_ending_here = 0\n    for i in range(n - 1, -1, -1):\n        max_ending_here = max_ending_here + a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n    return max_so_far\n[DONE]"}
{"idx": 276, "completion": "def square_Sum(n):\n    sum_sq = 0\n    for i in range(1, n+1):\n        sum_sq += (2 * i) ** 2\n    return sum_sq\n[DONE]"}
{"idx": 277, "completion": "def modular_inverse(arr, n, p):\n    count = 0\n    for num in arr:\n        if (num * num) % p == 1:\n            count += 1\n    return count\n[DONE]"}
{"idx": 278, "completion": "def odd_Days(year):\n    return (year + (year // 4)) % 7\n[DONE]"}
{"idx": 279, "completion": "def max_length(list1):\n    max_len = 0\n    max_list = []\n    for lst in list1:\n        if len(lst) > max_len:\n            max_len = len(lst)\n            max_list = lst\n    return (max_len, max_list)\n[DONE]"}
{"idx": 280, "completion": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    diff = k * (k - 1)\n    for i in range(3, n + 1):\n        same, diff = diff, (same + diff) * (k - 1)\n    return same + diff\n[DONE]"}
{"idx": 281, "completion": "def find(a, b):\n    return a // b\n[DONE]"}
{"idx": 282, "completion": "import math\ndef otherside_rightangle(a, b):\n    c = math.sqrt(a**2 + b**2)\n    return c\n[DONE]"}
{"idx": 283, "completion": "def max_val(list_val):\n    max_val = max(i for i in list_val if isinstance(i, int))\n    return max_val\n[DONE]"}
{"idx": 284, "completion": "def sum_div(number):\n    sum = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum += i\n    return sum\n[DONE]"}
{"idx": 285, "completion": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count\n[DONE]"}
{"idx": 286, "completion": "def flatten_list(nested_list):\n    flat_list = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flat_list.extend(flatten_list(element))\n        else:\n            flat_list.append(element)\n    return flat_list\n[DONE]"}
{"idx": 287, "completion": "def intersection_nested_lists(l1, l2):\n    result = []\n    for sublist in l2:\n        intersection = [item for item in sublist if item in l1]\n        result.append(intersection)\n    return result\n[DONE]"}
{"idx": 288, "completion": "def max_aggregate(students):\n    from collections import defaultdict\n    aggregates = defaultdict(int)\n    for name, score in students:\n        aggregates[name] += score\n    max_name, max_score = max(aggregates.items(), key=lambda x: x[1])\n    return (max_name, max_score)\n[DONE]"}
{"idx": 289, "completion": "import math\ndef count_binary_seq(n):\n    if n == 0:\n        return 1.0\n    total = 0\n    for k in range(0, n+1):\n        c = math.comb(n, k)\n        total += c * c\n    return float(total)\n[DONE]"}
{"idx": 290, "completion": "def dict_depth(d, depth=1):\n    if not isinstance(d, dict) or not d:\n        return depth\n    return max(dict_depth(v, depth + 1) for k, v in d.items())\n[DONE]"}
{"idx": 291, "completion": "def set_Bit_Number(n):\n    if n == 0:\n        return 0\n    msb = 1\n    while (n >> 1) != 0:\n        n = n >> 1\n        msb = msb << 1\n    return msb\n[DONE]"}
{"idx": 292, "completion": "def solve(arr, n):\n    count1 = 0\n    count2 = 0\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            count1 += 1\n    for i in range(n - 1):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                count2 += 1\n    return count1 == count2\n[DONE]"}
{"idx": 293, "completion": "def find_Element(arr, ranges, rotations, index):\n    for i in range(rotations):\n        left, right = ranges[i % len(ranges)]\n        arr = arr[left:right+1] + arr[:left] + arr[right+1:]\n    return arr[index]\n[DONE]"}
{"idx": 294, "completion": "def start_withp(words):\n    p_words = []\n    for phrase in words:\n        for word in phrase.split():\n            if word.startswith('P') or word.startswith('p'):\n                p_words.append(word)\n    if len(p_words) >= 2:\n        return (p_words[0], p_words[1])\n    else:\n        return (None, None)\n[DONE]"}
{"idx": 295, "completion": "def max_sum_increasing_subseq(arr, n, i, k):\n    if i >= k or k >= n:\n        return 0\n    max_sum = 0\n    for j in range(i + 1):\n        if arr[j] < arr[k]:\n            current_sum = max_sum_increasing_subseq(arr, n, j, i) + arr[k]\n            if current_sum > max_sum:\n                max_sum = current_sum\n    return max_sum\n[DONE]"}
{"idx": 296, "completion": "def colon_tuplex(tup, index, value):\n    tup_list = list(tup)\n    tup_list[index] = [value]\n    return tuple(tup_list)\n[DONE]"}
{"idx": 297, "completion": "def large_product(list1, list2, N):\n    products = [x * y for x in list1 for y in list2]\n    products = sorted(products, reverse=True)\n    return products[:N]\n[DONE]"}
{"idx": 298, "completion": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n[DONE]"}
{"idx": 299, "completion": "def string_to_tuple(str1):\n    return tuple(str1)\n[DONE]"}
{"idx": 300, "completion": "def set_left_most_unset_bit(n):\n    if n == 0:\n        return 1\n    unset_bit = ~n\n    if unset_bit == 0:\n        return n\n    left_most_unset_bit = (unset_bit & -unset_bit)\n    return n | left_most_unset_bit\n[DONE]"}
{"idx": 301, "completion": "import math\ndef volume_cone(r, h):\n    return (1/3) * math.pi * r**2 * h\n[DONE]"}
{"idx": 302, "completion": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i, end=\",\")\n    return\n[DONE]"}
{"idx": 303, "completion": "def max_sum_rectangular_grid(grid, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return max(grid[0][0], grid[1][0])\n    \n    # Initialize dp arrays for the two rows\n    dp0 = [0] * n\n    dp1 = [0] * n\n    \n    dp0[0] = grid[0][0]\n    dp1[0] = grid[1][0]\n    \n    if n > 1:\n        dp0[1] = max(grid[0][1], dp0[0])\n        dp1[1] = max(grid[1][1], dp1[0])\n    \n    for i in range(2, n):\n        dp0[i] = max(dp0[i-1], dp0[i-2] + grid[0][i])\n        dp1[i] = max(dp1[i-1], dp1[i-2] + grid[1][i])\n    \n    return max(dp0[-1], dp1[-1])\n[DONE]"}
{"idx": 304, "completion": "def find_Max_Len_Even(test_str):\n    words = test_str.split()\n    max_len = 0\n    max_word = \"-1\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_word = word\n    return max_word\n[DONE]"}
{"idx": 305, "completion": "def find_last_occurrence(arr, x):\n    index = -1\n    for i in range(len(arr)):\n        if arr[i] == x:\n            index = i\n    return index\n[DONE]"}
{"idx": 306, "completion": "from itertools import groupby\ndef modified_encode(lst):\n    result = []\n    for key, group in groupby(lst):\n        count = len(list(group))\n        if count > 1:\n            result.append([count, key])\n        else:\n            result.append(key)\n    return result\n[DONE]"}
{"idx": 307, "completion": "def max_volume(s):\n    max_vol = 0\n    for a in range(1, s-1):\n        for b in range(1, s - a):\n            c = s - a - b\n            vol = a * b * c\n            if vol > max_vol:\n                max_vol = vol\n    return max_vol\n[DONE]"}
{"idx": 308, "completion": "import re\ndef find_long_word(test_str):\n    res = re.findall(r'\\b\\w{5}\\b', test_str)\n    return res\n[DONE]"}
{"idx": 309, "completion": "def sum_difference(n):\n    sum_squares = 0\n    square_sum = 0\n    for i in range(1, n+1):\n        sum_squares += i**2\n        square_sum += i\n    square_sum = square_sum**2\n    return square_sum - sum_squares\n[DONE]"}
{"idx": 310, "completion": "def find_demlo(n):\n    s = str(n)\n    length = len(s)\n    demlo = ''.join(str(i) for i in range(1, length + 1)) + ''.join(str(i) for i in range(length - 1, 0, -1))\n    return demlo\n[DONE]"}
{"idx": 311, "completion": "def position_min(inp):\n    min_val = min(inp)\n    positions = [i for i, x in enumerate(inp) if x == min_val]\n    return positions\n[DONE]"}
{"idx": 312, "completion": "def re_arrange(arr, n):\n    # Separate positive and negative numbers\n    pos = [x for x in arr if x >= 0]\n    neg = [x for x in arr if x < 0]\n    \n    # Initialize the result list\n    result = []\n    i = j = 0\n    \n    # Merge the two lists in alternating fashion\n    while i < len(neg) and j < len(pos):\n        result.append(neg[i])\n        result.append(pos[j])\n        i += 1\n        j += 1\n    \n    # Add remaining elements from negative list\n    while i < len(neg):\n        result.append(neg[i])\n        i += 1\n    \n    # Add remaining elements from positive list\n    while j < len(pos):\n        result.append(pos[j])\n        j += 1\n    \n    return result\n[DONE]"}
{"idx": 313, "completion": "def sum_of_alternates(test_tup):\n    sum1 = 0\n    sum2 = 0\n    for i in range(0, len(test_tup), 2):\n        sum1 += test_tup[i]\n    for j in range(1, len(test_tup), 2):\n        sum2 += test_tup[j]\n    return (sum1, sum2)\n[DONE]"}
{"idx": 314, "completion": "import math\ndef get_Min_Squares(n):\n    if n <= 3:\n        return n\n    res = n\n    for x in range(1, n + 1):\n        temp = x * x\n        if temp > n:\n            break\n        else:\n            res = min(res, 1 + get_Min_Squares(n - temp))\n    return res\n[DONE]"}
{"idx": 315, "completion": "from collections import Counter\n\ndef most_occurrences(strings):\n    words = []\n    for s in strings:\n        words.extend(s.split())\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(1)\n    return most_common[0][0]\n[DONE]"}
{"idx": 316, "completion": "def check_isosceles(x,y,z):\n    if (x == y or y == z or x == z) and (x + y > z and x + z > y and y + z > x):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 317, "completion": "def rotate_left(nums, k, n):\n    return nums[k:] + nums[:k] + nums[:n]\n[DONE]"}
{"idx": 318, "completion": "def neg_count(list1):\n    count = 0\n    for num in list1:\n        if num < 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 319, "completion": "import re\ndef find_char(test_str):\n    res = re.findall(r'\\b\\w{3,5}\\b', test_str)\n    return res\n[DONE]"}
{"idx": 320, "completion": "def count_unset_bits(n):\n    binary = bin(n)[2:]\n    return binary.count('0')\n[DONE]"}
{"idx": 321, "completion": "def char_frequency(str1):\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if n in keys:\n            dict[n] += 1\n        else:\n            dict[n] = 1\n    return dict\n[DONE]"}
{"idx": 322, "completion": "def Sort(sub_li):\n    sub_li.sort(key = lambda x: x[1])\n    return sub_li\n[DONE]"}
{"idx": 323, "completion": "def check_Validity(a, b, c):\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 324, "completion": "def ap_sum(a1, an, d):\n    n = ((an - a1) // d) + 1\n    return (n * (a1 + an)) // 2\n[DONE]"}
{"idx": 325, "completion": "def check_monthnum(month):\n    if month == \"February\":\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 326, "completion": "import re\ndef text_match_word(text):\n    pattern = r'\\b\\w+\\W*$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 327, "completion": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n[DONE]"}
{"idx": 328, "completion": "def find_Divisor(a, b):\n    if a == b:\n        return a\n    else:\n        return 2\n[DONE]"}
{"idx": 329, "completion": "def sum_three_smallest_nums(lst):\n    positive_nums = [x for x in lst if x > 0]\n    positive_nums_sorted = sorted(positive_nums)\n    return sum(positive_nums_sorted[:3])\n[DONE]"}
{"idx": 330, "completion": "def set_to_tuple(input_set):\n    return tuple(sorted(input_set))\n[DONE]"}
{"idx": 331, "completion": "import heapq\n\ndef find_minimum_range(arrays):\n    min_heap = []\n    max_val = -float('inf')\n    range_start, range_end = -float('inf'), float('inf')\n    \n    # Initialize the heap with the first element of each array\n    for i in range(len(arrays)):\n        if not arrays[i]:\n            return (0, 0)  # Handle empty arrays if necessary\n        val = arrays[i][0]\n        heapq.heappush(min_heap, (val, i, 0))\n        max_val = max(max_val, val)\n    \n    # Now process the heap\n    while True:\n        min_val, arr_idx, elem_idx = heapq.heappop(min_heap)\n        # Check if current range is smaller than the previous\n        if max_val - min_val < range_end - range_start:\n            range_start, range_end = min_val, max_val\n        \n        # If we've exhausted one of the arrays, break\n        if elem_idx + 1 >= len(arrays[arr_idx]):\n            break\n        \n        # Get the next element from the same array\n        next_val = arrays[arr_idx][elem_idx + 1]\n        heapq.heappush(min_heap, (next_val, arr_idx, elem_idx + 1))\n        max_val = max(max_val, next_val)\n    \n    return (range_start, range_end)\n[DONE]"}
{"idx": 332, "completion": "def dig_let(string):\n    letters = 0\n    digits = 0\n    for char in string:\n        if char.isalpha():\n            letters += 1\n        elif char.isdigit():\n            digits += 1\n    return (letters, digits)\n[DONE]"}
{"idx": 333, "completion": "import math\ndef count_Odd_Squares(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        sqrt_num = math.sqrt(num)\n        if sqrt_num.is_integer() and int(sqrt_num) % 2 != 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 334, "completion": "def diff_consecutivenums(nums):\n    res = []\n    for i in range(1, len(nums)):\n        res.append(nums[i] - nums[i-1])\n    return res\n[DONE]"}
{"idx": 335, "completion": "def zigzag(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if k < 0 or k > n:\n        return 0\n    return zigzag(n, k - 1) + zigzag(n - 1, n - k)\n[DONE]"}
{"idx": 336, "completion": "def count_Squares(n, m):\n    if n < 1 or m < 1:\n        return 0\n    total = 0\n    for i in range(1, min(n, m) + 1):\n        total += (n - i + 1) * (m - i + 1)\n    return total\n[DONE]"}
{"idx": 337, "completion": "def find_ways(n):\n    if n % 2 != 0:\n        return 0\n    n = n // 2\n    def catalan(n):\n        if n <= 1:\n            return 1\n        res = 0\n        for i in range(n):\n            res += catalan(i) * catalan(n - i - 1)\n        return res\n    return catalan(n)\n[DONE]"}
{"idx": 338, "completion": "def check(string):\n    s = set(string)\n    if s == {'0', '1'} or s == {'0'} or s == {'1'}:\n        return \"Yes\"\n    else:\n        return \"No\"\n[DONE]"}
{"idx": 339, "completion": "def minimum_Length(s):\n    if len(s) == 0:\n        return 0\n    left = 0\n    right = len(s) - 1\n    while left < right and s[left] == s[right]:\n        char = s[left]\n        while left <= right and s[left] == char:\n            left += 1\n        while right >= left and s[right] == char:\n            right -= 1\n    return right - left + 1\n[DONE]"}
{"idx": 340, "completion": "def first_Element(arr, n, k):\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for num in arr:\n        if freq[num] == k:\n            return num\n    return -1\n[DONE]"}
{"idx": 341, "completion": "def unique_Characters(s):\n    return len(s) == len(set(s))\n[DONE]"}
{"idx": 342, "completion": "def remove_column(list1, n):\n    for i in range(len(list1)):\n        list1[i] = list1[i][0:n] + list1[i][n+1:]\n    return list1\n[DONE]"}
{"idx": 343, "completion": "def tn_ap(a1, d, n):\n    return a1 + (n - 1) * d\n[DONE]"}
{"idx": 344, "completion": "def count_Rectangles(r):\n    count = 0\n    for a in range(1, 2 * r + 1):\n        for b in range(1, 2 * r + 1):\n            if a * a + b * b <= 4 * r * r:\n                count += 1\n    return count\n[DONE]"}
{"idx": 345, "completion": "def find_angle(angle1, angle2):\n    angle3 = 180 - (angle1 + angle2)\n    return angle3\n[DONE]"}
{"idx": 346, "completion": "def find_max(test_tup):\n    max_val = 0\n    for t in test_tup:\n        current_max = max(t)\n        if current_max > max_val:\n            max_val = current_max\n    return max_val\n[DONE]"}
{"idx": 347, "completion": "def moddiv_list(nums1, nums2):\n    res = list(map(lambda x, y: x % y, nums1, nums2))\n    return res\n[DONE]"}
{"idx": 348, "completion": "def Check_Solution(a, b, c):\n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return \"No\"\n    root1 = (-b + (discriminant)**0.5) / (2*a)\n    root2 = (-b - (discriminant)**0.5) / (2*a)\n    if (root1 == 2 * root2) or (root2 == 2 * root1):\n        return \"Yes\"\n    else:\n        return \"No\"\n[DONE]"}
{"idx": 349, "completion": "def get_carol(n):\n    return (2**n - 1)**2 - 2\n[DONE]"}
{"idx": 350, "completion": "def remove_empty(lst):\n    result = [x for x in lst if x != []]\n    return result\n[DONE]"}
{"idx": 351, "completion": "from collections import Counter\ndef max_occurrences(nums):\n    nums = list(nums)\n    d = Counter(nums)\n    ans = []\n    for k in d:\n        if d[k] == max(d.values()):\n            ans.append(k)\n    if len(ans) == 1:\n        return ans[0]\n    else:\n        return tuple(ans)\n[DONE]"}
{"idx": 352, "completion": "def add_K_element(test_list, K):\n    res = [tuple(j + K for j in sub) for sub in test_list]\n    return res\n[DONE]"}
{"idx": 353, "completion": "def min_flip_to_make_string_alternate(bin_str):\n    flip1 = 0  # starts with '0'\n    flip2 = 0  # starts with '1'\n    for i in range(len(bin_str)):\n        current_char = bin_str[i]\n        if i % 2 == 0:\n            if current_char != '0':\n                flip1 += 1\n            if current_char != '1':\n                flip2 += 1\n        else:\n            if current_char != '1':\n                flip1 += 1\n            if current_char != '0':\n                flip2 += 1\n    return min(flip1, flip2)\n[DONE]"}
{"idx": 354, "completion": "def count_Digit(n):\n    return len(str(n))\n[DONE]"}
{"idx": 355, "completion": "def adjacent_num_product(list1):\n    max_product = 0\n    for i in range(len(list1)-1):\n        product = list1[i] * list1[i+1]\n        if product > max_product:\n            max_product = product\n    return max_product\n[DONE]"}
{"idx": 356, "completion": "def is_tree_balanced(root):\n    if not root:\n        return True\n    left = get_height(root.left)\n    right = get_height(root.right)\n    if abs(left - right) > 1:\n        return False\n    return is_tree_balanced(root.left) and is_tree_balanced(root.right)\n\ndef get_height(root):\n    if not root:\n        return 0\n    return 1 + max(get_height(root.left), get_height(root.right))\n[DONE]"}
{"idx": 357, "completion": "def repeat_tuples(test_tup, n):\n    res = (test_tup,) * n\n    return res\n[DONE]"}
{"idx": 358, "completion": "def lateralsurface_cuboid(l, w, h):\n    return 2 * (l + w) * h\n[DONE]"}
{"idx": 359, "completion": "def float_sort(tuples):\n    tuples.sort(key=lambda x: float(x[1]), reverse=True)\n    return tuples\n[DONE]"}
{"idx": 360, "completion": "def smallest_missing(nums, left, right):\n    if left > right:\n        return left\n    mid = (left + right) // 2\n    if nums[mid] == mid:\n        return smallest_missing(nums, mid + 1, right)\n    else:\n        return smallest_missing(nums, left, mid - 1)\n[DONE]"}
{"idx": 361, "completion": "import heapq\ndef heap_assending(nums):\n    heapq.heapify(nums)\n    res = []\n    while nums:\n        res.append(heapq.heappop(nums))\n    return res\n[DONE]"}
{"idx": 362, "completion": "def volume_cuboid(l, w, h):\n    return l * w * h\n[DONE]"}
{"idx": 363, "completion": "from itertools import permutations\n\ndef permute_string(s):\n    perms = [''.join(p) for p in permutations(s)]\n    return perms\n[DONE]"}
{"idx": 364, "completion": "def round_num(number, multiple):\n    return multiple * round(number / multiple)\n[DONE]"}
{"idx": 365, "completion": "def remove_replica(test_tup):\n    seen = {}\n    result = []\n    for num in test_tup:\n        if num in seen:\n            result.append('MSP')\n        else:\n            result.append(num)\n            seen[num] = True\n    return tuple(result)\n[DONE]"}
{"idx": 366, "completion": "def remove_Char(s, c):\n    return s.replace(c, '')\n[DONE]"}
{"idx": 367, "completion": "def move_first(lst):\n    if len(lst) > 0:\n        lst.insert(0, lst.pop())\n    return lst\n[DONE]"}
{"idx": 368, "completion": "def surfacearea_cuboid(l, w, h):\n    return 2 * (l * w + w * h + l * h)\n[DONE]"}
{"idx": 369, "completion": "def multi_list(row, col):\n    res = []\n    for i in range(row):\n        inner = []\n        for j in range(col):\n            inner.append(i * j)\n        res.append(inner)\n    return res\n[DONE]"}
{"idx": 370, "completion": "def index_on_inner_list(list1, n):\n    list1.sort(key = lambda x: x[n])\n    return list1\n[DONE]"}
{"idx": 371, "completion": "def find_rotation_count(arr):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    while low <= high:\n        if arr[low] <= arr[high]:\n            return low\n        mid = (low + high) // 2\n        next = (mid + 1) % n\n        prev = (mid - 1 + n) % n\n        if arr[mid] <= arr[next] and arr[mid] <= arr[prev]:\n            return mid\n        elif arr[mid] <= arr[high]:\n            high = mid - 1\n        elif arr[mid] >= arr[low]:\n            low = mid + 1\n    return 0\n[DONE]"}
{"idx": 372, "completion": "def even_bit_toggle_number(n):\n    mask = 0x55555555  # This is a 32-bit mask with all odd bits set to 1 (binary 0101...)\n    return n ^ mask\n[DONE]"}
{"idx": 373, "completion": "def frequency_Of_Smallest(n, arr):\n    min_val = min(arr)\n    count = arr.count(min_val)\n    return count\n[DONE]"}
{"idx": 374, "completion": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n[DONE]"}
{"idx": 375, "completion": "def swap_count(s):\n    count = 0\n    balance = 0\n    for char in s:\n        if char == '[':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            count += 1\n            balance += 2\n    return count\n[DONE]"}
{"idx": 376, "completion": "def even_or_odd(hex_num):\n    num = int(hex_num, 16)\n    return \"Even\" if num % 2 == 0 else \"Odd\"\n[DONE]"}
{"idx": 377, "completion": "def highest_Power_of_2(n):\n    res = 1\n    while res * 2 <= n:\n        res *= 2\n    return res\n[DONE]"}
{"idx": 378, "completion": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n+1):\n        a, b = b, a + b\n    return b\n[DONE]"}
{"idx": 379, "completion": "def add_string(list_, format_string):\n    return [format_string.format(item) for item in list_]\n[DONE]"}
{"idx": 380, "completion": "def convert_list_dictionary(keys, values1, values2):\n    result = []\n    for k, v1, v2 in zip(keys, values1, values2):\n        result.append({k: {v1: v2}})\n    return result\n[DONE]"}
{"idx": 381, "completion": "def get_max_sum(n):\n    if n == 0 or n == 1:\n        return n\n    return max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))\n[DONE]"}
{"idx": 382, "completion": "def max_length_list(list1):\n    max_length = max(len(x) for x in list1)\n    max_list = max(list1, key=lambda i: len(i))\n    return (max_length, max_list)\n[DONE]"}
{"idx": 383, "completion": "def check_distinct(test_tup):\n    if len(test_tup) == len(set(test_tup)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 384, "completion": "def first_non_repeating_character(s):\n    for i in s:\n        if s.count(i) == 1:\n            return i\n    return None\n[DONE]"}
{"idx": 385, "completion": "import re\ndef check_char(string):\n    if re.match(r'^(.).*\\1$', string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n[DONE]"}
{"idx": 386, "completion": "def median_numbers(a, b, c):\n    if a > b:\n        if a < c:\n            median = a\n        elif b > c:\n            median = b\n        else:\n            median = c\n    else:\n        if a > c:\n            median = a\n        elif b < c:\n            median = b\n        else:\n            median = c\n    return float(median)\n[DONE]"}
{"idx": 387, "completion": "def sum_of_digits(nums):\n    total = 0\n    for num in nums:\n        if isinstance(num, int) and num >= 0:\n            for digit in str(num):\n                total += int(digit)\n        elif isinstance(num, int) and num < 0:\n            for digit in str(abs(num)):\n                total += int(digit)\n    return total\n[DONE]"}
{"idx": 388, "completion": "def bitwise_xor(tuple1, tuple2):\n    result = tuple(a ^ b for a, b in zip(tuple1, tuple2))\n    return result\n[DONE]"}
{"idx": 389, "completion": "def extract_freq(test_list):\n    unique_tuples = set()\n    for t in test_list:\n        unique_tuples.add(t)\n    return len(unique_tuples)\n[DONE]"}
{"idx": 390, "completion": "def add_nested_tuples(tuple1, tuple2):\n    result = tuple(\n        tuple(a + b for a, b in zip(t1, t2))\n        for t1, t2 in zip(tuple1, tuple2)\n    )\n    return result\n[DONE]"}
{"idx": 391, "completion": "def ncr_modp(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    # Precompute the factorials and inverse of factorials modulo p\n    fact = [1] * (n + 1)\n    for i in range(1, n + 1):\n        fact[i] = (fact[i - 1] * i) % p\n    # Compute inverse of fact[r] and fact[n - r] mod p using Fermat's little theorem\n    inv_r = pow(fact[r], p - 2, p)\n    inv_nr = pow(fact[n - r], p - 2, p)\n    # The result is (fact[n] * inv_r * inv_nr) % p\n    return (fact[n] * inv_r * inv_nr) % p\n[DONE]"}
{"idx": 392, "completion": "import re\ndef is_valid_URL(url):\n    regex = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})' # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return re.match(regex, url) is not None\n[DONE]"}
{"idx": 393, "completion": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b\n[DONE]"}
{"idx": 394, "completion": "def check_tuplex(tuplex, element):\n    return element in tuplex\n[DONE]"}
{"idx": 395, "completion": "def find_Parity(x):\n    if x % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n[DONE]"}
{"idx": 396, "completion": "import itertools\n\ndef rearrange_bigger(n):\n    digits = list(str(n))\n    for perm in itertools.permutations(sorted(digits)):\n        num = int(''.join(perm))\n        if num > n:\n            return num\n    return False\n[DONE]"}
{"idx": 397, "completion": "import heapq\n\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    \n    heap = []\n    for n1 in nums1:\n        for n2 in nums2:\n            heapq.heappush(heap, (n1 + n2, [n1, n2]))\n    \n    result = []\n    for _ in range(min(k, len(heap))):\n        result.append(heapq.heappop(heap)[1])\n    \n    return result\n[DONE]"}
{"idx": 398, "completion": "def min_product_tuple(list1):\n    min_val = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_val:\n            min_val = product\n    return min_val\n[DONE]"}
{"idx": 399, "completion": "def min_val(list1):\n    min_val = None\n    for element in list1:\n        if isinstance(element, int):\n            if min_val is None or element < min_val:\n                min_val = element\n    return min_val\n[DONE]"}
{"idx": 400, "completion": "import re\ndef snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    camel_case = components[0].title() + ''.join(x.title() for x in components[1:])\n    return camel_case\n[DONE]"}
{"idx": 401, "completion": "def remove_odd(nums):\n    result = [x for x in nums if x % 2 == 0]\n    return result\n[DONE]"}
{"idx": 402, "completion": "def extract_nth_element(list1, n):\n    result = [x[n] for x in list1]\n    return result\n[DONE]"}
{"idx": 403, "completion": "def overlapping(list1,list2):\n    for x in list1:\n        if x in list2:\n            return True\n    return False\n[DONE]"}
{"idx": 404, "completion": "def max_Product(arr):\n    arr.sort()\n    n = len(arr)\n    if (arr[0] * arr[1]) > (arr[n-1] * arr[n-2]):\n        return (arr[0], arr[1])\n    else:\n        return (arr[n-2], arr[n-1])\n[DONE]"}
{"idx": 405, "completion": "def breakSum(n):\n    if n == 0 or n == 1:\n        return n\n    return max(n, breakSum(n//2) + breakSum(n//3) + breakSum(n//4))\n[DONE]"}
{"idx": 406, "completion": "def group_tuples(tuples_list):\n    from collections import defaultdict\n    grouped = defaultdict(list)\n    for t in tuples_list:\n        key = t[0]\n        grouped[key].extend(t[1:])\n    result = []\n    for key in grouped:\n        new_tuple = (key,) + tuple(grouped[key])\n        result.append(new_tuple)\n    return result\n[DONE]"}
{"idx": 407, "completion": "def Find_Max(l):\n    return max(l, key=len)\n[DONE]"}
{"idx": 408, "completion": "def round_and_sum(nums):\n    rounded_nums = [round(num) for num in nums]\n    total = sum(rounded_nums) * len(rounded_nums)\n    return total\n[DONE]"}
{"idx": 409, "completion": "def cube_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 3\n    return sum\n[DONE]"}
{"idx": 410, "completion": "def concatenate_tuple(test_tup):\n    delimiter = '-'\n    concatenated = delimiter.join([str(ele) for ele in test_tup])\n    return concatenated\n[DONE]"}
{"idx": 411, "completion": "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i ** 3\n    average = sum_of_cubes / n\n    return average\n[DONE]"}
{"idx": 412, "completion": "def get_maxgold(gold, m, n):\n    for j in range(n-2, -1, -1):\n        for i in range(m):\n            if i == 0:\n                right_up = 0\n            else:\n                right_up = gold[i-1][j+1]\n            if i == m-1:\n                right_down = 0\n            else:\n                right_down = gold[i+1][j+1]\n            right = gold[i][j+1]\n            gold[i][j] = gold[i][j] + max(right, right_up, right_down)\n    res = gold[0][0]\n    for i in range(1, m):\n        res = max(res, gold[i][0])\n    return res\n[DONE]"}
{"idx": 413, "completion": "def extract_rear(test_tup):\n    res = [sub[-1] for sub in test_tup]\n    return res\n[DONE]"}
{"idx": 414, "completion": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n[DONE]"}
{"idx": 415, "completion": "def filter_oddnumbers(nums):\n    odd_nums = list(filter(lambda x: x % 2 != 0, nums))\n    return odd_nums\n[DONE]"}
{"idx": 416, "completion": "import re\ndef change_date_format(dt):\n    return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\n[DONE]"}
{"idx": 417, "completion": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\n[DONE]"}
{"idx": 418, "completion": "def and_tuples(test_tup1, test_tup2):\n    res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 419, "completion": "def parabola_directrix(a, b, c):\n    directrix = - (b**2) - (4 * a * c)\n    return directrix\n[DONE]"}
{"idx": 420, "completion": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return None\n[DONE]"}
{"idx": 421, "completion": "def median_trapezium(a, b, c):\n    median = (a + b) / 2\n    return median\n[DONE]"}
{"idx": 422, "completion": "def check_greater(arr, num):\n    if all(num > x for x in arr):\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, entered number is less than those in the array\"\n[DONE]"}
{"idx": 423, "completion": "import re\ndef text_match_one(text):\n    pattern = 'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 424, "completion": "def last_Digit(n):\n    return n % 10\n[DONE]"}
{"idx": 425, "completion": "def neg_nos(list1):\n    neg_list = [num for num in list1 if num < 0]\n    return tuple(neg_list)\n[DONE]"}
{"idx": 426, "completion": "def remove_odd(str1):\n    result = \"\"\n    for i in range(len(str1)):\n        if i % 2 != 0:\n            result = result + str1[i]\n    return result\n[DONE]"}
{"idx": 427, "completion": "def count_bidirectional(test_list):\n    count = 0\n    for i in range(len(test_list)):\n        for j in range(i + 1, len(test_list)):\n            if (test_list[i][0] == test_list[j][1] and test_list[i][1] == test_list[j][0]):\n                count += 1\n    return str(count)\n[DONE]"}
{"idx": 428, "completion": "def multiple_to_single(l):\n    s = ''.join(map(str, l))\n    return int(s)\n[DONE]"}
{"idx": 429, "completion": "import re\ndef find_adverb_position(sentence):\n    match = re.search(r'\\b\\w+ly\\b', sentence)\n    if match:\n        start = match.start()\n        end = match.end()\n        adverb = match.group()\n        return (start, end, adverb)\n    else:\n        return None\n[DONE]"}
{"idx": 430, "completion": "def surfacearea_cube(side):\n    return 6 * (side ** 2)\n[DONE]"}
{"idx": 431, "completion": "def positive_count(nums):\n    positive = 0\n    for num in nums:\n        if num > 0:\n            positive += 1\n    ratio = round(positive / len(nums), 2)\n    return ratio\n[DONE]"}
{"idx": 432, "completion": "def largest_neg(list1): \n    neg_nums = [num for num in list1 if num < 0]\n    if not neg_nums:\n        return None\n    return max(neg_nums)\n[DONE]"}
{"idx": 433, "completion": "def trim_tuple(test_list, k):\n    res = [tup[k:-k] for tup in test_list]\n    return str(res)\n[DONE]"}
{"idx": 434, "completion": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(tuple(a * b for a, b in zip(t1, t2)) for t1, t2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 435, "completion": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in tup:\n        if element in lst:\n            count += 1\n    return count\n[DONE]"}
{"idx": 436, "completion": "def cube_nums(nums):\n    cube_nums = list(map(lambda x: x ** 3, nums))\n    return cube_nums\n[DONE]"}
{"idx": 437, "completion": "def cal_sum(n):\n    if n == 0:\n        return 3\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n    a, b, c = 3, 0, 2\n    sum_p = a + b + c\n    for i in range(3, n + 1):\n        d = a + b\n        sum_p += d\n        a, b, c = b, c, d\n    return sum_p\n[DONE]"}
{"idx": 438, "completion": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the area of the triangle\n    area = 0.5 * abs((x1*(y2 - y3) + x2*(y3 - y1) + x3*(y1 - y2)))\n    if area == 0:\n        return 'No'\n    else:\n        return 'Yes'\n[DONE]"}
{"idx": 439, "completion": "def extract_string(str_list, length):\n    result = [x for x in str_list if len(x) >= length]\n    return result\n[DONE]"}
{"idx": 440, "completion": "import re\ndef remove_whitespaces(string):\n    pattern = r'\\s+'\n    return re.sub(pattern, '', string)\n[DONE]"}
{"idx": 441, "completion": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None\n[DONE]"}
{"idx": 442, "completion": "def sumofFactors(n):\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even\n[DONE]"}
{"idx": 443, "completion": "import re\ndef text_match_wordz(text):\n    pattern = r'\\b\\w*z\\w*\\b'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 444, "completion": "def check_monthnumb_number(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 445, "completion": "def reverse_string_list(string_list):\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list\n[DONE]"}
{"idx": 446, "completion": "def Find_Min(lst):\n    min_length = min(len(x) for x in lst)\n    min_sublist = next(x for x in lst if len(x) == min_length)\n    return min_sublist\n[DONE]"}
{"idx": 447, "completion": "def rectangle_area(length, width):\n    return length * width\n[DONE]"}
{"idx": 448, "completion": "import re\ndef remove_uppercase(str1):\n    return re.sub('[A-Z]', '', str1)\n[DONE]"}
{"idx": 449, "completion": "def Extract(lst):\n    return [item[0] for item in lst]\n[DONE]"}
{"idx": 450, "completion": "def upper_ctr(string):\n    count = 0\n    for char in string:\n        if char.isupper():\n            count += 1\n    return count\n[DONE]"}
{"idx": 451, "completion": "from itertools import combinations\n\ndef combinations_list(lst):\n    result = []\n    for i in range(0, len(lst)+1):\n        temp = [list(x) for x in combinations(lst, i)]\n        if len(temp)>0:\n            result.extend(temp)\n    return result\n[DONE]"}
{"idx": 452, "completion": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    max_product = current_max = current_min = arr[0]\n    for num in arr[1:]:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        max_product = max(max_product, current_max)\n    return max_product\n[DONE]"}
{"idx": 453, "completion": "def check_value(dictionary, value):\n    return all(v == value for v in dictionary.values())\n[DONE]"}
{"idx": 454, "completion": "def drop_empty(dict1):\n    new_dict = {k: v for k, v in dict1.items() if v is not None}\n    return new_dict\n[DONE]"}
{"idx": 455, "completion": "def find_peak(arr, n):\n    if (n == 1):\n        return 0\n    if (arr[0] >= arr[1]):\n        return 0\n    if (arr[n - 1] >= arr[n - 2]):\n        return n - 1\n    for i in range(1, n - 1):\n        if (arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]):\n            return i\n    return -1\n[DONE]"}
{"idx": 456, "completion": "def decimal_to_Octal(decimal_num):\n    octal_num = 0\n    i = 1\n    while (decimal_num != 0):\n        octal_num = octal_num + (decimal_num % 8) * i\n        decimal_num = int(decimal_num / 8)\n        i = i * 10\n    return octal_num\n[DONE]"}
{"idx": 457, "completion": "def max_product(arr, n):\n    max_prod = 1\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[j] > arr[i]:\n                max_prod = max(max_prod, arr[i] * arr[j])\n    return max_prod\n[DONE]"}
{"idx": 458, "completion": "def max_profit(prices, k):\n    n = len(prices)\n    if n == 0:\n        return 0\n    profit = [[0 for _ in range(n)] for _ in range(k+1)]\n    for i in range(1, k+1):\n        prev_diff = -prices[0]\n        for j in range(1, n):\n            prev_diff = max(prev_diff, profit[i-1][j-1] - prices[j-1])\n            profit[i][j] = max(profit[i][j-1], prices[j] + prev_diff)\n    return profit[k][n-1]\n[DONE]"}
{"idx": 459, "completion": "def add_pairwise(tup):\n    res = []\n    for i in range(len(tup)-1):\n        res.append(tup[i] + tup[i+1])\n    return tuple(res)\n[DONE]"}
{"idx": 460, "completion": "def find_remainder(arr, n, num):\n    product = 1\n    for i in range(n):\n        product = (product * arr[i]) % num\n    return product\n[DONE]"}
{"idx": 461, "completion": "def check_Consecutive(l):\n    if len(l) < 1:\n        return False\n    min_val = min(l)\n    max_val = max(l)\n    if max_val - min_val + 1 == len(l):\n        for i in range(len(l)):\n            if l[i] - min_val != i:\n                return False\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 462, "completion": "def tuple_intersection(tuple_list1, tuple_list2):\n    set1 = {tuple(sorted(t)) for t in tuple_list1}\n    set2 = {tuple(sorted(t)) for t in tuple_list2}\n    intersection = set1 & set2\n    return intersection\n[DONE]"}
{"idx": 463, "completion": "def replace_char(string, old_char, new_char):\n    new_string = string.replace(old_char, new_char)\n    return new_string\n[DONE]"}
{"idx": 464, "completion": "def sort_counter(counter):\n    sorted_counter = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counter\n[DONE]"}
{"idx": 465, "completion": "def big_sum(nums):\n    return max(nums) + min(nums)\n[DONE]"}
{"idx": 466, "completion": "def is_lower(string):\n    return string.lower()\n[DONE]"}
{"idx": 467, "completion": "def remove_lowercase(s):\n    result = \"\"\n    for char in s:\n        if not char.islower():\n            result += char\n    return result\n[DONE]"}
{"idx": 468, "completion": "def first_Digit(n):\n    n = abs(n)\n    while n >= 10:\n        n = n // 10\n    return n\n[DONE]"}
{"idx": 469, "completion": "from collections import Counter\n\ndef get_max_occuring_char(string):\n    char_count = Counter(string)\n    max_char = max(char_count, key=char_count.get)\n    return max_char\n[DONE]"}
{"idx": 470, "completion": "def is_subset_sum(arr, n, sum):\n    if sum == 0:\n        return True\n    if n == 0 and sum != 0:\n        return False\n    if arr[n-1] > sum:\n        return is_subset_sum(arr, n-1, sum)\n    return is_subset_sum(arr, n-1, sum) or is_subset_sum(arr, n-1, sum-arr[n-1])\n[DONE]"}
{"idx": 471, "completion": "import re\ndef match(string):\n    if re.search(r'[A-Z][a-z]+', string):\n        return 'Yes'\n    else:\n        return 'No'\n[DONE]"}
{"idx": 472, "completion": "import math\ndef first_Factorial_Divisible_Number(x):\n    n = 1\n    while True:\n        if math.factorial(n) % x == 0:\n            return n\n        n += 1\n[DONE]"}
{"idx": 473, "completion": "def remove_matching_tuple(test_tup1, test_tup2):\n    res = [ele for ele in test_tup1 if ele not in test_tup2]\n    return (res)\n[DONE]"}
{"idx": 474, "completion": "def largest_palindrome(arr, n):\n    max_palindrome = -1\n    for num in arr:\n        if str(num) == str(num)[::-1] and num > max_palindrome:\n            max_palindrome = num\n    return max_palindrome\n[DONE]"}
{"idx": 475, "completion": "import math\ndef binomial_probability(n, x, p):\n    return math.comb(n, x) * (p ** x) * ((1 - p) ** (n - x))\n[DONE]"}
{"idx": 476, "completion": "def sort_tuple(tuples):\n    def get_last_element(tuple_item):\n        return tuple_item[-1]\n    sorted_tuples = sorted(tuples, key=get_last_element)\n    return sorted_tuples\n[DONE]"}
{"idx": 477, "completion": "import math\ndef area_pentagon(a):\n    area = (5 * a * a) / (4 * math.tan(math.pi / 5))\n    return area\n[DONE]"}
{"idx": 478, "completion": "def frequency_Of_Largest(n, arr):\n    max_val = max(arr)\n    count = arr.count(max_val)\n    return count\n[DONE]"}
{"idx": 479, "completion": "def extract_symmetric(test_list):\n    res = set()\n    for pair in test_list:\n        if (pair[1], pair[0]) in test_list and pair[0] != pair[1]:\n            res.add(tuple(sorted(pair)))\n    return res\n[DONE]"}
{"idx": 480, "completion": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) / (1 - r)\n[DONE]"}
{"idx": 481, "completion": "def binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return True\n    return False\n[DONE]"}
{"idx": 482, "completion": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    polygons = []\n    for x in range(startx, endx + 1, radius * 2):\n        for y in range(starty, endy + 1, int(radius * math.sqrt(3))):\n            hexagon = []\n            for i in range(6):\n                angle_deg = 60 * i - 30\n                angle_rad = math.pi / 180 * angle_deg\n                hex_x = x + radius * math.cos(angle_rad)\n                hex_y = y + radius * math.sin(angle_rad)\n                hexagon.append((hex_x, hex_y))\n            hexagon.append(hexagon[0])  # Close the hexagon\n            polygons.append(hexagon)\n    return polygons\n[DONE]"}
{"idx": 483, "completion": "def binary_to_integer(bin_tuple):\n    binary_str = ''.join(map(str, bin_tuple))\n    decimal_num = int(binary_str, 2)\n    return str(decimal_num)\n[DONE]"}
{"idx": 484, "completion": "import re\ndef remove_lowercase(string):\n    pattern = r'[^a-z]'\n    result = re.findall(pattern, string)\n    return ''.join(result)\n[DONE]"}
{"idx": 485, "completion": "import heapq\ndef heap_queue_smallest(nums,n):\n    return heapq.nsmallest(n, nums)\n[DONE]"}
{"idx": 486, "completion": "import math\ndef surfacearea_cone(r, h):\n    l = math.sqrt(r**2 + h**2)\n    return math.pi * r * (r + l)\n[DONE]"}
{"idx": 487, "completion": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n[DONE]"}
{"idx": 488, "completion": "def diameter_circle(r):\n    return 2 * r\n[DONE]"}
{"idx": 489, "completion": "def concatenate_elements(list_data):\n    result = '  ' + ' '.join(list_data)\n    return result\n[DONE]"}
{"idx": 490, "completion": "import math\ndef num_comm_div(x, y):\n    def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n    g = gcd(x, y)\n    count = 0\n    for i in range(1, int(math.sqrt(g)) + 1):\n        if g % i == 0:\n            if i * i == g:\n                count += 1\n            else:\n                count += 2\n    return count\n[DONE]"}
{"idx": 491, "completion": "def find(a, b):\n    return a % b\n[DONE]"}
{"idx": 492, "completion": "def add_consecutive_nums(nums):\n    res = []\n    for i in range(len(nums)-1):\n        res.append(nums[i] + nums[i+1])\n    return res\n[DONE]"}
{"idx": 493, "completion": "def sum_Of_Series(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n    return sum\n[DONE]"}
{"idx": 494, "completion": "def re_order(arr):\n    non_zeros = [x for x in arr if x != 0]\n    zeros = [0] * (len(arr) - len(non_zeros))\n    return non_zeros + zeros\n[DONE]"}
{"idx": 495, "completion": "def permutation_coefficient(n, k):\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    return result\n[DONE]"}
{"idx": 496, "completion": "def remove_words(list1, words):\n    for word in words:\n        if word in list1:\n            list1.remove(word)\n    return list1\n[DONE]"}
{"idx": 497, "completion": "def same_order(l1, l2):\n    common1 = [x for x in l1 if x in l2]\n    common2 = [x for x in l2 if x in l1]\n    return common1 == common2\n[DONE]"}
{"idx": 498, "completion": "def average_Odd(n):\n    sum_odd = 0\n    count_odd = 0\n    for i in range(1, n+1, 2):\n        sum_odd += i\n        count_odd += 1\n    return sum_odd // count_odd\n[DONE]"}
{"idx": 499, "completion": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0] * (n + 1) for _ in range(k + 1)]\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            if arr[j - 1] <= i and arr[j - 1] > 0:\n                dp[i][j] = dp[i // arr[j - 1]][j - 1] + dp[i][j - 1] + 1\n            else:\n                dp[i][j] = dp[i][j - 1]\n    return dp[k][n]\n[DONE]"}
