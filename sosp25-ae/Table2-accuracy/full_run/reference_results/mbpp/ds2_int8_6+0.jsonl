{"idx": 0, "completion": "def remove_Occ(s, char):\n    first_index = s.find(char)\n    if first_index != -1:\n        s = s[:first_index] + s[first_index+1:]\n    last_index = s.rfind(char)\n    if last_index != -1:\n        s = s[:last_index] + s[last_index+1:]\n    return s\n[DONE]"}
{"idx": 1, "completion": "def sort_matrix(matrix):\n    matrix.sort(key=lambda row: sum(row))\n    return matrix\n[DONE]"}
{"idx": 2, "completion": "from collections import Counter\ndef count_common(words):\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(4)\n    return most_common\n[DONE]"}
{"idx": 3, "completion": "def find_Volume(a, b, h):\n    volume = (a * b * h) / 2\n    return volume\n[DONE]"}
{"idx": 4, "completion": "def split_lowerstring(s):\n    result = []\n    for char in s:\n        if char.islower():\n            result.append(char)\n    return result\n[DONE]"}
{"idx": 5, "completion": "import re\ndef text_lowercase_underscore(text):\n    if re.search('^[a-z]+_[a-z]+$', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 6, "completion": "def square_perimeter(side_length):\n    return side_length * 4\n[DONE]"}
{"idx": 7, "completion": "def remove_dirty_chars(str1, str2):\n    return ''.join([char for char in str1 if char not in str2])\n[DONE]"}
{"idx": 8, "completion": "def test_duplicate(arr):\n    return len(arr) != len(set(arr))\n[DONE]"}
{"idx": 9, "completion": "def is_woodall(n):\n    if n < 1:\n        return False\n    for i in range(1, int(n**0.5) + 1):\n        if i * (2**i) - 1 == n:\n            return True\n    return False\n[DONE]"}
{"idx": 10, "completion": "def multiples_of_num(m, n):\n    multiples = [i * n for i in range(1, m + 1)]\n    return multiples\n[DONE]"}
{"idx": 11, "completion": "def find_first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n[DONE]"}
{"idx": 12, "completion": "def maximum_Sum(lst):\n    max_sum = max(sum(sublist) for sublist in lst)\n    return max_sum\n[DONE]"}
{"idx": 13, "completion": "def binary_to_decimal(binary):\n    decimal = 0\n    binary = str(binary)\n    for digit in binary:\n        decimal = decimal * 2 + int(digit)\n    return decimal\n[DONE]"}
{"idx": 14, "completion": "def find_Product(arr, n):\n    unique_elements = set(arr)\n    product = 1\n    for element in unique_elements:\n        product *= element\n    return product\n[DONE]"}
{"idx": 15, "completion": "def check_k_elements(tuples, k):\n    for t in tuples:\n        for element in t:\n            if element != k:\n                return False\n    return True\n[DONE]"}
{"idx": 16, "completion": "import re\ndef remove(strings):\n    return [re.sub(r'\\d', '', s) for s in strings]\n[DONE]"}
{"idx": 17, "completion": "def binomial_Coeff(n, k):\n    if k > n:\n        return 0\n    if k == 0 or k == n:\n        return 1\n    return binomial_Coeff(n-1, k-1) + binomial_Coeff(n-1, k)\n[DONE]"}
{"idx": 18, "completion": "def get_Odd_Occurrence(arr, arr_size):\n    for i in range(0, arr_size):\n        count = 0\n        for j in range(0, arr_size):\n            if arr[i] == arr[j]:\n                count += 1\n        if (count % 2 != 0):\n            return arr[i]\n    return -1\n[DONE]"}
{"idx": 19, "completion": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n[DONE]"}
{"idx": 20, "completion": "import heapq\nfrom collections import Counter\n\ndef func(lists, k):\n    combined = [item for sublist in lists for item in sublist]\n    counter = Counter(combined)\n    most_common = heapq.nlargest(k, counter.items(), key=lambda x: x[1])\n    return [item[0] for item in most_common]\n[DONE]"}
{"idx": 21, "completion": "def max_Prime_Factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n = n // 2\n    p = 3\n    while p * p <= n:\n        while n % p == 0:\n            max_prime = p\n            n = n // p\n        p += 2\n    if n > 2:\n        max_prime = n\n    return max_prime\n[DONE]"}
{"idx": 22, "completion": "def decimal_To_Binary(n):\n    return int(bin(n).replace(\"0b\", \"\"))\n[DONE]"}
{"idx": 23, "completion": "def find_missing(arr, n):\n    expected_sum = n * (n + 1) // 2\n    actual_sum = sum(arr)\n    missing_number = expected_sum - actual_sum\n    return missing_number\n[DONE]"}
{"idx": 24, "completion": "def find_rect_num(n):\n    return n * (n + 1)\n[DONE]"}
{"idx": 25, "completion": "def find_Nth_Digit(numerator, denominator, n):\n    fraction = str(numerator / denominator)\n    if '.' in fraction:\n        digits = fraction.split('.')[1]\n        if n <= len(digits):\n            return int(digits[n-1])\n    return None\n[DONE]"}
{"idx": 26, "completion": "def sort_mixed_list(lst):\n    return sorted(lst, key=lambda x: (isinstance(x, str), x))\n[DONE]"}
{"idx": 27, "completion": "def div_even_odd(lst):\n    even = next(x for x in lst if x % 2 == 0)\n    odd = next(x for x in lst if x % 2 != 0)\n    return even // odd\n[DONE]"}
{"idx": 28, "completion": "from collections import Counter\n\ndef rearange_string(s):\n    s = list(s)\n    count = Counter(s)\n    sorted_chars = sorted(count.keys(), key=lambda x: count[x], reverse=True)\n    \n    if count[sorted_chars[0]] > (len(s) + 1) // 2:\n        return None\n    \n    res = [None] * len(s)\n    idx = 0\n    \n    for char in sorted_chars:\n        for _ in range(count[char]):\n            if idx >= len(s):\n                idx = 1\n            res[idx] = char\n            idx += 2\n    \n    return ''.join(res)\n[DONE]"}
{"idx": 29, "completion": "from collections import Counter\ndef freq_element(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    return dict(Counter(flat_list))\n[DONE]"}
{"idx": 30, "completion": "def filter_evennumbers(nums):\n    even_nums = list(filter(lambda x: x % 2 == 0, nums))\n    return even_nums\n[DONE]"}
{"idx": 31, "completion": "def find_Sum(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] == arr[j]:\n                sum += arr[i]\n    return sum\n[DONE]"}
{"idx": 32, "completion": "import re\ndef text_match(text):\n    if re.search(r'^[a-z]+_[a-z]+$', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 33, "completion": "import re\ndef text_match_string(text):\n    if re.match(r\"^\\bpython\\b\", text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 34, "completion": "import math\nfrom functools import reduce\n\ndef get_gcd(arr):\n    return reduce(math.gcd, arr)\n[DONE]"}
{"idx": 35, "completion": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 36, "completion": "def compute_Last_Digit(a, b):\n    if a == b:\n        return 1\n    elif a > b:\n        return 0\n    else:\n        result = 1\n        for i in range(a + 1, b + 1):\n            result = (result * i) % 10\n        return result\n[DONE]"}
{"idx": 37, "completion": "def odd_bit_set_number(n):\n    result = 0\n    count = 0\n    while n > 0:\n        if count % 2 == 0:\n            result += 2 ** count\n        n = n // 2\n        count += 1\n    return result\n[DONE]"}
{"idx": 38, "completion": "def specified_element(lst, index):\n    return [sublst[index] for sublst in lst]\n[DONE]"}
{"idx": 39, "completion": "def min_length_list(input_list):\n    min_len = min(map(lambda x: len(x), input_list))\n    min_list = list(filter(lambda x: len(x) == min_len, input_list))[0]\n    return (min_len, min_list)\n[DONE]"}
{"idx": 40, "completion": "def check_equilateral(a, b, c):\n    if a == b == c:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 41, "completion": "def parallelogram_area(base, height):\n    return base * height\n[DONE]"}
{"idx": 42, "completion": "def check_Equality(s):\n    if s[0] == s[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"\n[DONE]"}
{"idx": 43, "completion": "def counting_sort(arr):\n    if not arr:\n        return arr\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for num in arr:\n        count[num] += 1\n    sorted_arr = []\n    for i in range(len(count)):\n        sorted_arr.extend([i] * count[i])\n    return sorted_arr\n[DONE]"}
{"idx": 44, "completion": "def tn_gp(a, r, n):\n    tn = a * (r ** (n - 1))\n    return tn\n[DONE]"}
{"idx": 45, "completion": "def check(num):\n    reversed_num = int(str(num)[::-1])\n    return num == 2 * reversed_num - 1\n[DONE]"}
{"idx": 46, "completion": "def find_Max_Num(nums, n):\n    nums.sort(reverse=True)\n    max_num = int(''.join(map(str, nums)))\n    return max_num\n[DONE]"}
{"idx": 47, "completion": "def opposite_Signs(x, y):\n    return (x < 0 and y > 0) or (x > 0 and y < 0)\n[DONE]"}
{"idx": 48, "completion": "def is_octagonal(n):\n    return n * (3 * n - 2)\n[DONE]"}
{"idx": 49, "completion": "def max_len_sub(arr, n):\n    max_len = 1\n    current_len = 1\n    for i in range(1, n):\n        if arr[i] - arr[i - 1] == 1:\n            current_len += 1\n            if current_len > max_len:\n                max_len = current_len\n        else:\n            current_len = 1\n    return max_len\n[DONE]"}
{"idx": 50, "completion": "def count_Substrings(s, n):\n    count = 0\n    for i in range(n):\n        sum_digits = 0\n        for j in range(i, n):\n            sum_digits += int(s[j])\n            if sum_digits == (j - i + 1):\n                count += 1\n    return count\n[DONE]"}
{"idx": 51, "completion": "def smallest_num(list):\n    return min(list)\n[DONE]"}
{"idx": 52, "completion": "def max_difference(tuples_list):\n    max_diff = 0\n    for pair in tuples_list:\n        diff = abs(pair[0] - pair[1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n[DONE]"}
{"idx": 53, "completion": "def subject_marks(marks):\n    marks.sort(key=lambda x: x[1])\n    return marks\n[DONE]"}
{"idx": 54, "completion": "def recursive_list_sum(data_list):\n    total = 0\n    for element in data_list:\n        if type(element) == type([]):\n            total = total + recursive_list_sum(element)\n        else:\n            total = total + element\n    return total\n[DONE]"}
{"idx": 55, "completion": "def pos_count(nums):\n    count = 0\n    for num in nums:\n        if num > 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 56, "completion": "def bell_number(n):\n    bell = [[0 for i in range(n+1)] for j in range(n+1)]\n    bell[0][0] = 1\n    for i in range(1, n+1):\n        bell[i][0] = bell[i-1][i-1]\n        for j in range(1, i+1):\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]\n    return bell[n][0]\n[DONE]"}
{"idx": 57, "completion": "def is_Monotonic(arr):\n    increasing = decreasing = True\n    for i in range(1, len(arr)):\n        if arr[i] > arr[i - 1]:\n            decreasing = False\n        elif arr[i] < arr[i - 1]:\n            increasing = False\n    return increasing or decreasing\n[DONE]"}
{"idx": 58, "completion": "def is_sublist(lst, sublst):\n    n = len(lst)\n    m = len(sublst)\n    for i in range(n - m + 1):\n        if lst[i:i+m] == sublst:\n            return True\n    return False\n[DONE]"}
{"idx": 59, "completion": "def get_equal(test_list, length):\n    result = 'All tuples have same length'\n    for tup in test_list:\n        if len(tup) != length:\n            result = 'All tuples do not have same length'\n            break\n    return result\n[DONE]"}
{"idx": 60, "completion": "def comb_sort(nums):\n    gap = len(nums)\n    shrink = 1.3\n    sorted = False\n\n    while not sorted:\n        gap = int(gap / shrink)\n        if gap <= 1:\n            gap = 1\n            sorted = True\n\n        for i in range(len(nums) - gap):\n            if nums[i] > nums[i + gap]:\n                nums[i], nums[i + gap] = nums[i + gap], nums[i]\n                sorted = False\n\n    return nums\n[DONE]"}
{"idx": 61, "completion": "def dif_Square(n):\n    for i in range(1, int(n**0.5) + 1):\n        for j in range(i + 1, int(n**0.5) + 1):\n            if j**2 - i**2 == n:\n                return True\n    return False\n[DONE]"}
{"idx": 62, "completion": "import re\ndef multiple_split(string):\n    split_string = re.split(r'[\\n*]', string)\n    return split_string\n[DONE]"}
{"idx": 63, "completion": "def is_samepatterns(words, patterns):\n    if len(words) != len(patterns):\n        return False\n    word_to_pattern = {}\n    pattern_to_word = {}\n    for word, pattern in zip(words, patterns):\n        if word in word_to_pattern:\n            if word_to_pattern[word] != pattern:\n                return False\n        else:\n            word_to_pattern[word] = pattern\n        if pattern in pattern_to_word:\n            if pattern_to_word[pattern] != word:\n                return False\n        else:\n            pattern_to_word[pattern] = word\n    return True\n[DONE]"}
{"idx": 64, "completion": "def find_tuples(tuples_list, k):\n    result = [tup for tup in tuples_list if all(elem % k == 0 for elem in tup)]\n    return str(result)\n[DONE]"}
{"idx": 65, "completion": "def count_Squares(a, b):\n    return (a * b * (a + 1) * (b + 1)) // 4\n[DONE]"}
{"idx": 66, "completion": "def is_Diff(num):\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return even_sum != odd_sum\n[DONE]"}
{"idx": 67, "completion": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 68, "completion": "def word_len(word):\n    return len(word) % 2 != 0\n[DONE]"}
{"idx": 69, "completion": "def tetrahedral_number(n):\n    return n * (n + 1) * (n + 2) / 6\n[DONE]"}
{"idx": 70, "completion": "def zip_tuples(tup1, tup2):\n    zipped = []\n    for i in range(len(tup1)):\n        zipped.append((tup1[i], tup2[i % len(tup2)]))\n    return zipped\n[DONE]"}
{"idx": 71, "completion": "import math\ndef volume_sphere(radius):\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume\n[DONE]"}
{"idx": 72, "completion": "def get_Char(s):\n    total = 0\n    for char in s:\n        total += ord(char)\n    return chr(total % 26 + 97)\n[DONE]"}
{"idx": 73, "completion": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    seq = [0, 1, 1]\n    for i in range(3, n + 1):\n        next_val = seq[seq[i - 1]] + seq[i - seq[i - 1]]\n        seq.append(next_val)\n    return seq[n]\n[DONE]"}
{"idx": 74, "completion": "import math\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * (radius ** 2)\n[DONE]"}
{"idx": 75, "completion": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1\n[DONE]"}
{"idx": 76, "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = {**dict1, **dict2, **dict3}\n    return merged_dict\n[DONE]"}
{"idx": 77, "completion": "from collections import Counter\ndef freq_count(lst):\n    return dict(Counter(lst))\n[DONE]"}
{"idx": 78, "completion": "def closest_num(n):\n    return n - 1\n[DONE]"}
{"idx": 79, "completion": "def len_log(words):\n    return max(len(word) for word in words)\n[DONE]"}
{"idx": 80, "completion": "def find_substring(str_list, substr):\n    for string in str_list:\n        if substr in string:\n            return True\n    return False\n[DONE]"}
{"idx": 81, "completion": "def is_undulating(n):\n    if len(n) < 3:\n        return False\n    for i in range(2, len(n)):\n        if n[i] != n[i % 2]:\n            return False\n    return True\n[DONE]"}
{"idx": 82, "completion": "def power(a, b):\n    return a ** b\n[DONE]"}
{"idx": 83, "completion": "def index_minimum(test_list):\n    min_index = test_list.index(min(test_list, key=lambda x: x[1]))\n    return test_list[min_index][0]\n[DONE]"}
{"idx": 84, "completion": "def Find_Min_Length(lst):\n    min_length = min(len(sublist) for sublist in lst)\n    return min_length\n[DONE]"}
{"idx": 85, "completion": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 86, "completion": "from collections import Counter\n\ndef frequency_lists(list_of_lists):\n    flat_list = [item for sublist in list_of_lists for item in sublist]\n    frequency_count = dict(Counter(flat_list))\n    return frequency_count\n[DONE]"}
{"idx": 87, "completion": "def multiply_num(nums):\n    product = 1\n    for num in nums:\n        product *= num\n    return product / len(nums)\n[DONE]"}
{"idx": 88, "completion": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n[DONE]"}
{"idx": 89, "completion": "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef next_smallest_palindrome(num):\n    num += 1\n    while not is_palindrome(num):\n        num += 1\n    return num\n[DONE]"}
{"idx": 90, "completion": "def kth_element(arr, n, k):\n    arr.sort()\n    return arr[k-1]\n[DONE]"}
{"idx": 91, "completion": "def snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0].capitalize() + ''.join(x.capitalize() for x in components[1:])\n[DONE]"}
{"idx": 92, "completion": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n[DONE]"}
{"idx": 93, "completion": "def sort_sublists(list_of_lists):\n    sorted_list = [sorted(sublist, key=lambda x: x.lower()) for sublist in list_of_lists]\n    return sorted_list\n[DONE]"}
{"idx": 94, "completion": "def count(booleans):\n    return booleans.count(True)\n[DONE]"}
{"idx": 95, "completion": "def add_lists(lst, tup):\n    return tup + tuple(lst)\n[DONE]"}
{"idx": 96, "completion": "def count_Hexadecimal(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        if all(c in '0123456789ABCDEF' for c in hex(num)[2:].upper()):\n            count += 1\n    return count\n[DONE]"}
{"idx": 97, "completion": "import heapq\n\ndef merge_sorted_list(lists):\n    merged_list = []\n    heap = []\n    for i, lst in enumerate(lists):\n        if lst:\n            heapq.heappush(heap, (lst[0], i, 0))\n    while heap:\n        val, list_idx, elem_idx = heapq.heappop(heap)\n        merged_list.append(val)\n        if elem_idx + 1 < len(lists[list_idx]):\n            next_tuple = (lists[list_idx][elem_idx + 1], list_idx, elem_idx + 1)\n            heapq.heappush(heap, next_tuple)\n    return merged_list\n[DONE]"}
{"idx": 98, "completion": "def odd_Equivalent(s, n):\n    count = 0\n    for i in range(n):\n        if s[i] == '1':\n            count += 1\n    if count % 2 == 1:\n        return n\n    else:\n        return 0\n[DONE]"}
{"idx": 99, "completion": "def extract_missing(ranges, start, end):\n    missing_ranges = []\n    current_end = start\n\n    for r in ranges:\n        if r[0] > current_end:\n            missing_ranges.append((current_end, r[0]))\n        if r[1] > current_end:\n            current_end = r[1]\n\n    if current_end < end:\n        missing_ranges.append((current_end, end))\n\n    return missing_ranges\n[DONE]"}
{"idx": 100, "completion": "def common_in_nested_lists(nested_lists):\n    if not nested_lists:\n        return []\n    common_elements = set(nested_lists[0])\n    for lst in nested_lists[1:]:\n        common_elements.intersection_update(lst)\n    return sorted(common_elements)\n[DONE]"}
{"idx": 101, "completion": "import math\ndef perimeter(height, radius):\n    perimeter = 2 * math.pi * radius + 2 * height\n    return perimeter\n[DONE]"}
{"idx": 102, "completion": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False\n[DONE]"}
{"idx": 103, "completion": "from collections import Counter\n\ndef assign_freq(test_list):\n    freq = Counter(test_list)\n    res = []\n    for tup in test_list:\n        if freq[tup] > 0:\n            res.append(tup + (freq[tup],))\n            freq[tup] = 0\n    return str(res)\n[DONE]"}
{"idx": 104, "completion": "def empty_dit(dicts):\n    if isinstance(dicts, list):\n        return all(not d for d in dicts)\n    elif isinstance(dicts, dict):\n        return not dicts\n    else:\n        return False\n[DONE]"}
{"idx": 105, "completion": "def tuple_to_int(num_tuple):\n    return int(''.join(map(str, num_tuple)))\n[DONE]"}
{"idx": 106, "completion": "def list_to_float(lst):\n    converted_list = []\n    for pair in lst:\n        converted_pair = []\n        for element in pair:\n            try:\n                converted_element = float(element)\n            except ValueError:\n                converted_element = element\n            converted_pair.append(converted_element)\n        converted_list.append(tuple(converted_pair))\n    return str(converted_list)\n[DONE]"}
{"idx": 107, "completion": "def string_to_list(s):\n    return s.split()\n[DONE]"}
{"idx": 108, "completion": "def search(arr, n):\n    low = 0\n    high = n - 1\n    while low <= high:\n        mid = (low + high) // 2\n        if mid % 2 == 0:\n            if arr[mid] == arr[mid + 1]:\n                low = mid + 2\n            else:\n                high = mid - 1\n        else:\n            if arr[mid] == arr[mid - 1]:\n                low = mid + 1\n            else:\n                high = mid - 1\n    return arr[low]\n[DONE]"}
{"idx": 109, "completion": "def max_product_tuple(tuples_list):\n    max_product = max(map(lambda x: x[0] * x[1], tuples_list))\n    return max_product\n[DONE]"}
{"idx": 110, "completion": "def check_triplet(arr, a, b, c):\n    for i in range(len(arr)):\n        for j in range(i + 1, len(arr)):\n            for k in range(j + 1, len(arr)):\n                if arr[i] == a and arr[j] == b and arr[k] == c:\n                    return True\n    return False\n[DONE]"}
{"idx": 111, "completion": "def smartNumber(n):\n    count = 0\n    num = 30\n    while True:\n        if num % 2 == 0 and num % 3 == 0 and num % 5 == 0:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n[DONE]"}
{"idx": 112, "completion": "def sum_of_divisors(n):\n    total = 1\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            total += i\n            if i != n // i:\n                total += n // i\n    return total\n\ndef amicable_numbers_sum(limit):\n    amicable_sum = 0\n    for a in range(1, limit + 1):\n        b = sum_of_divisors(a)\n        if b > a and sum_of_divisors(b) == a:\n            amicable_sum += a + b\n    return amicable_sum\n[DONE]"}
{"idx": 113, "completion": "import cmath\ndef angle_complex(real, imag):\n    complex_num = complex(real, imag)\n    angle = cmath.phase(complex_num)\n    return angle\n[DONE]"}
{"idx": 114, "completion": "def find_length(s, n):\n    max_diff = 0\n    current_diff = 0\n    for char in s:\n        if char == '0':\n            current_diff += 1\n        else:\n            current_diff -= 1\n        if current_diff < 0:\n            current_diff = 0\n        max_diff = max(max_diff, current_diff)\n    return max_diff\n[DONE]"}
{"idx": 115, "completion": "def sum_common_divisors(a, b):\n    def get_divisors(n):\n        divisors = set()\n        for i in range(1, n + 1):\n            if n % i == 0:\n                divisors.add(i)\n        return divisors\n\n    divisors_a = get_divisors(a)\n    divisors_b = get_divisors(b)\n    common_divisors = divisors_a & divisors_b\n    return sum(common_divisors)\n[DONE]"}
{"idx": 116, "completion": "def multiply_int(a, b):\n    result = 0\n    for _ in range(abs(b)):\n        result += abs(a)\n    if (a < 0 and b > 0) or (a > 0 and b < 0):\n        return -result\n    return result\n[DONE]"}
{"idx": 117, "completion": "def long_words(n, sentence):\n    words = sentence.split()\n    long_words = list(filter(lambda word: len(word) > n, words))\n    return long_words\n[DONE]"}
{"idx": 118, "completion": "def magic_square_test(matrix):\n    n = len(matrix)\n    sum_list = []\n    \n    # Vertical\n    for col in range(n):\n        sum_list.append(sum(row[col] for row in matrix))\n    \n    # Horizontal\n    sum_list.extend([sum(row) for row in matrix])\n    \n    # Diagonals\n    diagonal1 = sum(matrix[i][i] for i in range(n))\n    diagonal2 = sum(matrix[i][n-i-1] for i in range(n))\n    sum_list.append(diagonal1)\n    sum_list.append(diagonal2)\n    \n    if len(set(sum_list)) == 1:\n        return True\n    return False\n[DONE]"}
{"idx": 119, "completion": "from collections import Counter\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    count = Counter(lst)\n    max_item = max(count, key=count.get)\n    return (max_item, count[max_item])\n[DONE]"}
{"idx": 120, "completion": "def reverse_vowels(s):\n    vowels = \"aeiouAEIOU\"\n    s = list(s)\n    left, right = 0, len(s) - 1\n    while left < right:\n        if s[left] in vowels and s[right] in vowels:\n            s[left], s[right] = s[right], s[left]\n            left += 1\n            right -= 1\n        elif s[left] not in vowels:\n            left += 1\n        elif s[right] not in vowels:\n            right -= 1\n    return ''.join(s)\n[DONE]"}
{"idx": 121, "completion": "def tup_string(tup):\n    str = ''.join(tup)\n    return str\n[DONE]"}
{"idx": 122, "completion": "def sum_negativenum(nums):\n    sum_negativenum = sum(filter(lambda x: x < 0, nums))\n    return sum_negativenum\n[DONE]"}
{"idx": 123, "completion": "def check_last(arr, p, q):\n    for _ in range(p):\n        arr[-1] += q\n    return \"EVEN\" if arr[-1] % 2 == 0 else \"ODD\"\n[DONE]"}
{"idx": 124, "completion": "def hexagonal_num(n):\n    return n * (2 * n - 1)\n[DONE]"}
{"idx": 125, "completion": "def cal_electbill(units):\n    if units <= 50:\n        bill = units * 3.50\n    elif units <= 150:\n        bill = 50 * 3.50 + (units - 50) * 4.00\n    elif units <= 250:\n        bill = 50 * 3.50 + 100 * 4.00 + (units - 150) * 5.20\n    else:\n        bill = 50 * 3.50 + 100 * 4.00 + 100 * 5.20 + (units - 250) * 6.50\n    return bill\n[DONE]"}
{"idx": 126, "completion": "def zero_count(arr):\n    count_zero = arr.count(0)\n    ratio = count_zero / len(arr)\n    return round(ratio, 2)\n[DONE]"}
{"idx": 127, "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    while n > 0:\n        if n % 2 != 0:\n            return False\n        n = n // 2\n    return True\n[DONE]"}
{"idx": 128, "completion": "import math\ndef circle_circumference(radius):\n    circumference = 2 * math.pi * radius\n    return circumference\n[DONE]"}
{"idx": 129, "completion": "def extract_singly(tuple_list):\n    from collections import Counter\n    all_elements = [item for sublist in tuple_list for item in sublist]\n    element_counts = Counter(all_elements)\n    singly_occurring_elements = [element for element in all_elements if element_counts[element] == 1]\n    return singly_occurring_elements\n[DONE]"}
{"idx": 130, "completion": "def pancake_sort(arr):\n    def flip(arr, k):\n        return arr[:k][::-1] + arr[k:]\n\n    for i in range(len(arr) - 1, 0, -1):\n        max_idx = arr.index(max(arr[:i + 1]))\n        if max_idx != i:\n            if max_idx != 0:\n                arr = flip(arr, max_idx + 1)\n            arr = flip(arr, i + 1)\n    return arr\n[DONE]"}
{"idx": 131, "completion": "def count_samepair(list1, list2, list3):\n    count = 0\n    for a, b, c in zip(list1, list2, list3):\n        if a == b == c:\n            count += 1\n    return count\n[DONE]"}
{"idx": 132, "completion": "def find_lists(test_tup):\n    count = 0\n    for element in test_tup:\n        if isinstance(element, list):\n            count += 1\n    return count\n[DONE]"}
{"idx": 133, "completion": "def sum_Pairs(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            sum += abs(arr[i] - arr[j])\n    return sum\n[DONE]"}
{"idx": 134, "completion": "def max_Abs_Diff(arr, n):\n    max_diff = arr[1] - arr[0]\n    for i in range(n):\n        for j in range(i+1, n):\n            if (abs(arr[i] - arr[j]) > max_diff):\n                max_diff = abs(arr[i] - arr[j])\n    return max_diff\n[DONE]"}
{"idx": 135, "completion": "def ascii_value_string(s):\n    total = 0\n    for char in s:\n        total += ord(char)\n    return total\n[DONE]"}
{"idx": 136, "completion": "def max_path_sum(tri, m, n):\n    for i in range(m - 1, -1, -1):\n        for j in range(i + 1):\n            if tri[i + 1][j] > tri[i + 1][j + 1]:\n                tri[i][j] += tri[i + 1][j]\n            else:\n                tri[i][j] += tri[i + 1][j + 1]\n    return tri[0][0]\n[DONE]"}
{"idx": 137, "completion": "def sum_digits_twoparts(n):\n    n_str = str(n)\n    part1 = int(n_str[0])\n    part2 = int(n_str[1:])\n    return part1 + part2\n[DONE]"}
{"idx": 138, "completion": "def longest_subseq_with_diff_one(arr, n):\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1:\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n[DONE]"}
{"idx": 139, "completion": "def does_Contain_B(a, b, c):\n    if b < a:\n        return False\n    return (b - a) % c == 0\n[DONE]"}
{"idx": 140, "completion": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef is_coprime(a, b):\n    return gcd(a, b) == 1\n[DONE]"}
{"idx": 141, "completion": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left_half = arr[:mid]\n        right_half = arr[mid:]\n\n        merge_sort(left_half)\n        merge_sort(right_half)\n\n        i = j = k = 0\n\n        while i < len(left_half) and j < len(right_half):\n            if left_half[i] < right_half[j]:\n                arr[k] = left_half[i]\n                i += 1\n            else:\n                arr[k] = right_half[j]\n                j += 1\n            k += 1\n\n        while i < len(left_half):\n            arr[k] = left_half[i]\n            i += 1\n            k += 1\n\n        while j < len(right_half):\n            arr[k] = right_half[j]\n            j += 1\n            k += 1\n\n    return arr\n[DONE]"}
{"idx": 142, "completion": "def parabola_vertex(a, b, c):\n    x = -b / (2 * a)\n    y = a * x ** 2 + b * x + c\n    return (x, y)\n[DONE]"}
{"idx": 143, "completion": "def specified_element(lst, index):\n    return [sublst[index] for sublst in lst]\n[DONE]"}
{"idx": 144, "completion": "def even_bit_toggle_number(n):\n    return n ^ 0b10101010101010101010101010101010\n[DONE]"}
{"idx": 145, "completion": "def tuple_int_str(test_tup):\n    res = tuple((int(x), int(y)) for x, y in test_tup)\n    return res\n[DONE]"}
{"idx": 146, "completion": "def encode_list(lst):\n    if not lst:\n        return []\n    encoded_list = []\n    count = 1\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            count += 1\n        else:\n            encoded_list.append([count, lst[i - 1]])\n            count = 1\n    encoded_list.append([count, lst[-1]])\n    return encoded_list\n[DONE]"}
{"idx": 147, "completion": "def min_Ops(arr, n, k):\n    max_element = max(arr)\n    result = 0\n    for i in range(n):\n        if ((max_element - arr[i]) % k != 0):\n            return -1\n        else:\n            result += (max_element - arr[i]) / k\n    return int(result)\n[DONE]"}
{"idx": 148, "completion": "def month_season(month, day):\n    if month in ('January', 'February'):\n        return 'winter'\n    elif month in ('March', 'April', 'May'):\n        return 'spring'\n    elif month in ('June', 'July', 'August'):\n        return 'summer'\n    elif month in ('September', 'October', 'November'):\n        return 'autumn'\n    elif month == 'December':\n        if day < 21:\n            return 'autumn'\n        else:\n            return 'winter'\n[DONE]"}
{"idx": 149, "completion": "def solution(a, b, n):\n    for x in range(n // a + 1):\n        for y in range(n // b + 1):\n            if a * x + b * y == n:\n                return ('x = ', x, ', y = ', y)\n    return 'No solution'\n[DONE]"}
{"idx": 150, "completion": "def remove_elements(lst, elements_to_remove):\n    return [item for item in lst if item not in elements_to_remove]\n[DONE]"}
{"idx": 151, "completion": "def sum_series(n):\n    total = 0\n    while n > 0:\n        total += n\n        n -= 2\n    return total\n[DONE]"}
{"idx": 152, "completion": "import math\ndef area_polygon(n, s):\n    area = (n * s ** 2) / (4 * math.tan(math.pi / n))\n    return area\n[DONE]"}
{"idx": 153, "completion": "def sum_of_divisors(n):\n    return sum(i for i in range(1, n) if n % i == 0)\n\ndef areEquivalent(num1, num2):\n    return sum_of_divisors(num1) == sum_of_divisors(num2)\n[DONE]"}
{"idx": 154, "completion": "def count_char_position(string):\n    count = 0\n    for i, char in enumerate(string):\n        if (ord(char.lower()) - 97) == i:\n            count += 1\n    return count\n[DONE]"}
{"idx": 155, "completion": "def find_even_Pair(A, N):\n    even = 0\n    odd = 0\n    for i in range(N):\n        if A[i] % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return even * (even - 1) // 2 + odd * (odd - 1) // 2\n[DONE]"}
{"idx": 156, "completion": "def next_Power_Of_2(n):\n    if n == 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n[DONE]"}
{"idx": 157, "completion": "def frequency(arr, num):\n    return arr.count(num)\n[DONE]"}
{"idx": 158, "completion": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, 2 * b + a\n        return b\n[DONE]"}
{"idx": 159, "completion": "def sum_range_list(lst, start, end):\n    return sum(lst[start:end+1])\n[DONE]"}
{"idx": 160, "completion": "def perimeter_pentagon(side_length):\n    return side_length * 5\n[DONE]"}
{"idx": 161, "completion": "def count_occurance(s):\n    return s.count(\"std\")\n[DONE]"}
{"idx": 162, "completion": "import re\ndef remove_splchar(text):\n    return re.sub(r'[\\W_]+', '', text)\n[DONE]"}
{"idx": 163, "completion": "def group_keyvalue(seq):\n    result = {}\n    for key, value in seq:\n        if key in result:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n    return result\n[DONE]"}
{"idx": 164, "completion": "def is_valid_parenthese(string):\n    stack = []\n    mapping = {')': '(', '}': '{', ']': '['}\n    for char in string:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n[DONE]"}
{"idx": 165, "completion": "def perimeter_triangle(a, b, c):\n    return a + b + c\n[DONE]"}
{"idx": 166, "completion": "from math import gcd\n\ndef lcm(x, y):\n    return x * y // gcd(x, y)\n\ndef answer(low, high):\n    for i in range(low, high + 1):\n        for j in range(i + 1, high + 1):\n            if low <= lcm(i, j) <= high:\n                return (i, j)\n    return None\n[DONE]"}
{"idx": 167, "completion": "def string_literals(literals, string):\n    for literal in literals:\n        if literal in string:\n            return 'Matched!'\n    return 'Not Matched!'\n[DONE]"}
{"idx": 168, "completion": "def is_num_keith(num):\n    num_str = str(num)\n    digits = [int(d) for d in num_str]\n    n = len(digits)\n    while True:\n        next_num = sum(digits[-n:])\n        if next_num == num:\n            return True\n        if next_num > num:\n            return False\n        digits.append(next_num)\n[DONE]"}
{"idx": 169, "completion": "import math\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    R = 6371.0\n    lat1 = math.radians(lat1)\n    lon1 = math.radians(lon1)\n    lat2 = math.radians(lat2)\n    lon2 = math.radians(lon2)\n    dlon = lon2 - lon1\n    dlat = lat2 - lat1\n    a = math.sin(dlat / 2)**2 + math.cos(lat1) * math.cos(lat2) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    distance = R * c * 1000\n    return distance\n[DONE]"}
{"idx": 170, "completion": "def common_prefix(strings, n):\n    if not strings:\n        return \"\"\n    min_len = min(len(s) for s in strings)\n    common_prefix = \"\"\n    for i in range(min_len):\n        current_char = strings[0][i]\n        for j in range(1, n):\n            if strings[j][i] != current_char:\n                return common_prefix\n        common_prefix += current_char\n    return common_prefix\n[DONE]"}
{"idx": 171, "completion": "import re\n\ndef find_character(input_string):\n    uppercase_chars = re.findall(r'[A-Z]', input_string)\n    lowercase_chars = re.findall(r'[a-z]', input_string)\n    numeric_chars = re.findall(r'\\d', input_string)\n    special_chars = re.findall(r'[^\\w]', input_string)\n    return (uppercase_chars, lowercase_chars, numeric_chars, special_chars)\n[DONE]"}
{"idx": 172, "completion": "def count_pairs(arr, n, k):\n    count = 0\n    arr.sort()\n    l = 0\n    r = 0\n    while r < n:\n        if arr[r] - arr[l] == k:\n            count += 1\n            l += 1\n            r += 1\n        elif arr[r] - arr[l] > k:\n            l += 1\n        else:\n            r += 1\n    return count\n[DONE]"}
{"idx": 173, "completion": "def greater_specificnum(nums, specified_num):\n    for num in nums:\n        if num > specified_num:\n            return True\n    return False\n[DONE]"}
{"idx": 174, "completion": "def parabola_focus(a, b, c):\n    x_coordinate = -b / (2 * a)\n    y_coordinate = (4 * a * c - b ** 2) / (4 * a)\n    return (x_coordinate, y_coordinate)\n[DONE]"}
{"idx": 175, "completion": "import re\ndef check_literals(text, literals):\n    for literal in literals:\n        if re.search(literal, text):\n            return 'Matched!'\n    return 'Not Matched!'\n[DONE]"}
{"idx": 176, "completion": "def longest_common_subsequence(X, Y, m, n):\n    L = [[0] * (n + 1) for i in range(m + 1)]\n    for i in range(m + 1):\n        for j in range(n + 1):\n            if i == 0 or j == 0:\n                L[i][j] = 0\n            elif X[i - 1] == Y[j - 1]:\n                L[i][j] = L[i - 1][j - 1] + 1\n            else:\n                L[i][j] = max(L[i - 1][j], L[i][j - 1])\n    return L[m][n]\n[DONE]"}
{"idx": 177, "completion": "def prod_Square(n):\n    for i in range(1, int(n**0.5) + 1):\n        if n % i == 0:\n            j = n // i\n            if int(i**0.5)**2 == i and int(j**0.5)**2 == j:\n                return True\n    return False\n[DONE]"}
{"idx": 178, "completion": "def first_Missing_Positive(nums, n):\n    for i in range(1, n + 2):\n        if i not in nums:\n            return i\n[DONE]"}
{"idx": 179, "completion": "def count_Intgral_Points(x1, y1, x2, y2):\n    if x1 == x2 and y1 == y2:\n        return 1\n    elif x1 == x2:\n        return abs(y2 - y1) - 1\n    elif y1 == y2:\n        return abs(x2 - x1) - 1\n    else:\n        return 0\n[DONE]"}
{"idx": 180, "completion": "def check_monthnumber(month):\n    thirty_days_months = [\"April\", \"June\", \"September\", \"November\"]\n    return month in thirty_days_months\n[DONE]"}
{"idx": 181, "completion": "def check_String(s):\n    has_letter = any(c.isalpha() for c in s)\n    has_number = any(c.isdigit() for c in s)\n    return has_letter and has_number\n[DONE]"}
{"idx": 182, "completion": "def remove_tuple(test_tup):\n    res = tuple(set(test_tup))\n    return res\n[DONE]"}
{"idx": 183, "completion": "def octal_To_Decimal(octal_num):\n    decimal_num = int(str(octal_num), 8)\n    return decimal_num\n[DONE]"}
{"idx": 184, "completion": "def first(arr, x, n):\n    low = 0\n    high = n - 1\n    res = -1\n    while (low <= high):\n        mid = (low + high) // 2\n        if arr[mid] > x:\n            high = mid - 1\n        elif arr[mid] < x:\n            low = mid + 1\n        else:\n            res = mid\n            high = mid - 1\n    return res\n[DONE]"}
{"idx": 185, "completion": "def remove_tuples(tuples_list, k):\n    filtered_list = [tup for tup in tuples_list if len(tup) != k]\n    return filtered_list\n[DONE]"}
{"idx": 186, "completion": "def find_exponentio(test_tup1, test_tup2):\n    res = tuple(map(lambda x, y: x ** y, test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 187, "completion": "import math\ndef largest_triangle(a, b):\n    area = 3 * math.sqrt(3) / 4 * (a * b)\n    return area\n[DONE]"}
{"idx": 188, "completion": "def highest_Power_of_2(n):\n    power = 1\n    while (power * 2) <= n:\n        power *= 2\n    return power\n[DONE]"}
{"idx": 189, "completion": "def position_max(lst):\n    max_val = max(lst)\n    positions = [i for i, val in enumerate(lst) if val == max_val]\n    return positions\n[DONE]"}
{"idx": 190, "completion": "def chkList(lst):\n    return all(element == lst[0] for element in lst)\n[DONE]"}
{"idx": 191, "completion": "def remove_even(s):\n    return s[::2]\n[DONE]"}
{"idx": 192, "completion": "def hamming_Distance(n1, n2):\n    xor = n1 ^ n2\n    distance = bin(xor).count('1')\n    return distance\n[DONE]"}
{"idx": 193, "completion": "def count(string, char):\n    return string.count(char)\n[DONE]"}
{"idx": 194, "completion": "def inversion_elements(test_tup):\n    res = tuple(-(x + 1) for x in test_tup)\n    return res\n[DONE]"}
{"idx": 195, "completion": "def concatenate_elements(test_tup):\n    res = tuple(test_tup[i] + test_tup[i + 1] for i in range(len(test_tup) - 1))\n    return res\n[DONE]"}
{"idx": 196, "completion": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    \n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == s[j - 1] and i != j:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    \n    return dp[n][n]\n[DONE]"}
{"idx": 197, "completion": "import re\ndef is_decimal(num):\n    pattern = r'^\\d+\\.\\d{2}$'\n    return bool(re.match(pattern, num))\n[DONE]"}
{"idx": 198, "completion": "import heapq\ndef heap_replace(heap, new_item):\n    heapq.heapreplace(heap, new_item)\n    return heap\n[DONE]"}
{"idx": 199, "completion": "import re\ndef is_allowed_specific_char(string):\n    charRe = re.compile(r'[^a-zA-Z0-9]')\n    string = charRe.search(string)\n    return not bool(string)\n[DONE]"}
{"idx": 200, "completion": "def count_Num(n):\n    count = 0\n    for i in range(1, 1 << n):\n        if (i & 1) and (i & (1 << (n - 1))):\n            count += 1\n    return count\n[DONE]"}
{"idx": 201, "completion": "def fourth_Power_Sum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += i ** 4\n    return sum\n[DONE]"}
{"idx": 202, "completion": "def concatenate_strings(tuple1, tuple2):\n    result = tuple(s1 + s2 for s1, s2 in zip(tuple1, tuple2))\n    return result\n[DONE]"}
{"idx": 203, "completion": "import math\ndef degree_radian(radian):\n    degree = radian * (180 / math.pi)\n    return degree\n[DONE]"}
{"idx": 204, "completion": "def decode_list(encoded_list):\n    decoded_list = []\n    for item in encoded_list:\n        if isinstance(item, list):\n            decoded_list.extend([item[1]] * item[0])\n        else:\n            decoded_list.append(item)\n    return decoded_list\n[DONE]"}
{"idx": 205, "completion": "def check_subset_list(list1, list2):\n    flat_list1 = [item for sublist in list1 for item in sublist]\n    flat_list2 = [item for sublist in list2 for item in sublist]\n    return all(item in flat_list1 for item in flat_list2)\n[DONE]"}
{"idx": 206, "completion": "def first_Repeated_Char(str1):\n    chars = {}\n    for char in str1:\n        if char in chars:\n            return char\n        else:\n            chars[char] = 1\n    return '\\0'\n[DONE]"}
{"idx": 207, "completion": "def min_Operations(x, y):\n    operations = 0\n    while x != y:\n        if x < y:\n            x += 1\n        else:\n            y += 1\n        operations += 1\n    return operations\n[DONE]"}
{"idx": 208, "completion": "def extract_min_max(test_tup, k):\n    sorted_tup = sorted(test_tup)\n    min_elements = sorted_tup[:k]\n    max_elements = sorted_tup[-k:]\n    return tuple(min_elements + max_elements)\n[DONE]"}
{"idx": 209, "completion": "def replace_max_specialchar(text, n):\n    special_chars = [' ', ',', '.']\n    count = 0\n    for i, char in enumerate(text):\n        if char in special_chars:\n            text = text[:i] + ':' + text[i+1:]\n            count += 1\n            if count == n:\n                break\n    return text\n[DONE]"}
{"idx": 210, "completion": "def first_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return num\n    return None\n[DONE]"}
{"idx": 211, "completion": "def check_type(test_tup):\n    return all(isinstance(x, type(test_tup[0])) for x in test_tup)\n[DONE]"}
{"idx": 212, "completion": "def is_majority(arr, n, x):\n    count = arr.count(x)\n    if count > n / 2:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 213, "completion": "def count_Set_Bits(n):\n    return bin(n).count('1')\n[DONE]"}
{"idx": 214, "completion": "def find_Min(arr, low, high):\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = int((low + high)/2)\n    if mid < high and arr[mid+1] < arr[mid]:\n        return arr[mid+1]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid-1)\n    return find_Min(arr, mid+1, high)\n[DONE]"}
{"idx": 215, "completion": "def odd_values_string(s):\n    return s[::2]\n[DONE]"}
{"idx": 216, "completion": "def min_of_three(a, b, c):\n    return min(a, b, c)\n[DONE]"}
{"idx": 217, "completion": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    for i in range(l, r + 1):\n        if n & (1 << (i - 1)):\n            return False\n    return True\n[DONE]"}
{"idx": 218, "completion": "def re_arrange_array(arr, n):\n    j = 0\n    for i in range(n):\n        if arr[i] < 0:\n            temp = arr[i]\n            arr[i] = arr[j]\n            arr[j] = temp\n            j += 1\n    return arr\n[DONE]"}
{"idx": 219, "completion": "def replace_blank(input_string, char):\n    return input_string.replace(\" \", char)\n[DONE]"}
{"idx": 220, "completion": "def max_sum(triangle, n):\n    for i in range(n-2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i+1][j], triangle[i+1][j+1])\n    return triangle[0][0]\n[DONE]"}
{"idx": 221, "completion": "def larg_nnum(list1, n):\n    list1.sort(reverse=True)\n    return list1[:n]\n[DONE]"}
{"idx": 222, "completion": "import math\ndef lateralsuface_cylinder(radius, height):\n    lateral_surface_area = 2 * math.pi * radius * height\n    return lateral_surface_area\n[DONE]"}
{"idx": 223, "completion": "def volume_cube(side_length):\n    return side_length ** 3\n[DONE]"}
{"idx": 224, "completion": "def even_bit_set_number(n):\n    even_bits = n & 0xAAAAAAAA\n    return even_bits\n[DONE]"}
{"idx": 225, "completion": "def No_of_Triangle(n, k):\n    if k > n:\n        return -1\n    return (n - k + 1) * (n - k + 2) // 2\n[DONE]"}
{"idx": 226, "completion": "from collections import defaultdict\n\ndef check_occurences(test_list):\n    count_dict = defaultdict(int)\n    for tup in test_list:\n        sorted_tup = tuple(sorted(tup))\n        count_dict[sorted_tup] += 1\n    return dict(count_dict)\n[DONE]"}
{"idx": 227, "completion": "def number_of_substrings(s):\n    n = len(s)\n    return n * (n + 1) // 2\n[DONE]"}
{"idx": 228, "completion": "def get_total_number_of_sequences(m, n):\n    if n == 0:\n        return 1\n    total = 0\n    for i in range(1, m + 1):\n        total += get_total_number_of_sequences(min(m, 2 * i), n - 1)\n    return total\n[DONE]"}
{"idx": 229, "completion": "def replace_list(lst1, lst2):\n    lst1[-1:] = lst2\n    return lst1\n[DONE]"}
{"idx": 230, "completion": "def array_3d(x, y, z):\n    return [[['*' for _ in range(x)] for _ in range(y)] for _ in range(z)]\n[DONE]"}
{"idx": 231, "completion": "def count_charac(string):\n    return len(string)\n[DONE]"}
{"idx": 232, "completion": "from collections import defaultdict\n\ndef sort_on_occurence(lst):\n    occurence_dict = defaultdict(list)\n    for key, value in lst:\n        occurence_dict[key].append(value)\n    \n    result = []\n    for key, values in sorted(occurence_dict.items(), key=lambda x: len(x[1]), reverse=True):\n        result.append((key, *values, len(values)))\n    \n    return result\n[DONE]"}
{"idx": 233, "completion": "import math\ndef next_Perfect_Square(n):\n    return (math.floor(math.sqrt(n)) + 1) ** 2\n[DONE]"}
{"idx": 234, "completion": "def max_sum(arr, n):\n    # Initialize the increasing and decreasing arrays\n    inc = [0] * n\n    dec = [0] * n\n\n    # Fill the increasing array\n    for i in range(n):\n        inc[i] = arr[i]\n        for j in range(i):\n            if arr[j] < arr[i]:\n                inc[i] = max(inc[i], inc[j] + arr[i])\n\n    # Fill the decreasing array\n    for i in range(n - 1, -1, -1):\n        dec[i] = arr[i]\n        for j in range(n - 1, i, -1):\n            if arr[j] < arr[i]:\n                dec[i] = max(dec[i], dec[j] + arr[i])\n\n    # Find the maximum sum of bi-tonic sub-sequence\n    max_sum = 0\n    for i in range(n):\n        max_sum = max(max_sum, inc[i] + dec[i] - arr[i])\n\n    return max_sum\n[DONE]"}
{"idx": 235, "completion": "def babylonian_squareroot(n):\n    if n < 0:\n        raise ValueError(\"Cannot compute square root of a negative number\")\n    if n == 0:\n        return 0\n    guess = n / 2.0\n    while True:\n        new_guess = (guess + n / guess) / 2.0\n        if abs(new_guess - guess) < 1e-9:\n            return new_guess\n        guess = new_guess\n[DONE]"}
{"idx": 236, "completion": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    \n    for i in range(n):\n        dp[i][i] = 1\n    \n    for cl in range(2, n+1):\n        for i in range(n-cl+1):\n            j = i + cl - 1\n            if s[i] == s[j] and cl == 2:\n                dp[i][j] = 2\n            elif s[i] == s[j]:\n                dp[i][j] = dp[i+1][j-1] + 2\n            else:\n                dp[i][j] = max(dp[i][j-1], dp[i+1][j])\n    \n    return dp[0][n-1]\n[DONE]"}
{"idx": 237, "completion": "def harmonic_sum(n):\n    if n < 2:\n        return 0.0\n    else:\n        return 1.0 / (n - 1) + harmonic_sum(n - 1)\n[DONE]"}
{"idx": 238, "completion": "def intersection_array(arr1, arr2):\n    intersection = list(filter(lambda x: x in arr1, arr2))\n    return intersection\n[DONE]"}
{"idx": 239, "completion": "def count_X(test_tup, X):\n    return test_tup.count(X)\n[DONE]"}
{"idx": 240, "completion": "def insert_element(lst, element):\n    result = []\n    for item in lst:\n        result.append(element)\n        result.append(item)\n    return result\n[DONE]"}
{"idx": 241, "completion": "import cmath\ndef convert(complex_num):\n    return (abs(complex_num), cmath.phase(complex_num))\n[DONE]"}
{"idx": 242, "completion": "def count_integer(lst):\n    count = 0\n    for item in lst:\n        if isinstance(item, int):\n            count += 1\n    return count\n[DONE]"}
{"idx": 243, "completion": "def words_ae(text):\n    words = text.split()\n    result = [word for word in words if word.startswith(('a', 'e'))]\n    return result\n[DONE]"}
{"idx": 244, "completion": "from itertools import combinations_with_replacement\ndef combinations_colors(colors, n):\n    return list(combinations_with_replacement(colors, n))\n[DONE]"}
{"idx": 245, "completion": "def is_prime(n):\n    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if is_prime(i):\n            count += 1\n    return count\n[DONE]"}
{"idx": 246, "completion": "def swap_numbers(a, b):\n    a, b = b, a\n    return (a, b)\n[DONE]"}
{"idx": 247, "completion": "def count_odd(nums):\n    odd_count = len(list(filter(lambda x: x % 2 != 0, nums)))\n    return odd_count\n[DONE]"}
{"idx": 248, "completion": "def maximize_elements(test_tup1, test_tup2):\n    res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2)) for tup1, tup2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 249, "completion": "def newman_prime(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 1\n    else:\n        a, b = 1, 1\n        for _ in range(3, n + 1):\n            a, b = b, 2 * b + a\n        return b\n[DONE]"}
{"idx": 250, "completion": "def division_elements(test_tup1, test_tup2):\n    res = tuple(map(lambda x, y: x // y if x % y == 0 else x / y, test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 251, "completion": "def split_two_parts(lst, length):\n    first_part = lst[:length]\n    second_part = lst[length:]\n    return (first_part, second_part)\n[DONE]"}
{"idx": 252, "completion": "def merge_dict(dict1, dict2):\n    merged_dict = {**dict1, **dict2}\n    return merged_dict\n[DONE]"}
{"idx": 253, "completion": "def dog_age(age):\n    if age <= 0:\n        return 0\n    elif age == 1:\n        return 15\n    elif age == 2:\n        return 24\n    else:\n        return 24 + (age - 2) * 4\n[DONE]"}
{"idx": 254, "completion": "def list_split(lst, n):\n    return [lst[i::n] for i in range(n)]\n[DONE]"}
{"idx": 255, "completion": "def lateralsurface_cube(side):\n    return 4 * side ** 2\n[DONE]"}
{"idx": 256, "completion": "def square_Sum(n):\n    sum = 0\n    for i in range(1, 2 * n, 2):\n        sum += i ** 2\n    return sum\n[DONE]"}
{"idx": 257, "completion": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1\n[DONE]"}
{"idx": 258, "completion": "def ascii_value(char):\n    return ord(char)\n[DONE]"}
{"idx": 259, "completion": "def sum_even_and_even_index(arr, n):\n    sum = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum += arr[i]\n    return sum\n[DONE]"}
{"idx": 260, "completion": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += (2 * i) ** 5\n    return sum\n[DONE]"}
{"idx": 261, "completion": "def rear_extract(records):\n    rear_elements = [record[-1] for record in records]\n    return rear_elements\n[DONE]"}
{"idx": 262, "completion": "def substract_elements(test_tup1, test_tup2):\n    res = tuple(x - y for x, y in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 263, "completion": "def even_binomial_Coeff_Sum(n):\n    sum = 0\n    for i in range(0, n + 1, 2):\n        sum += math.comb(n, i)\n    return sum\n[DONE]"}
{"idx": 264, "completion": "def get_Position(arr, n, k):\n    if k > n:\n        return -1\n    return arr[n - k]\n[DONE]"}
{"idx": 265, "completion": "import math\ndef volume_cylinder(radius, height):\n    volume = math.pi * radius ** 2 * height\n    return volume\n[DONE]"}
{"idx": 266, "completion": "def dict_filter(d, threshold):\n    filtered_dict = {k: v for k, v in d.items() if v > threshold}\n    return filtered_dict\n[DONE]"}
{"idx": 267, "completion": "def count_first_elements(test_tup):\n    count = 0\n    for item in test_tup:\n        if isinstance(item, tuple):\n            break\n        count += 1\n    return count\n[DONE]"}
{"idx": 268, "completion": "def is_num_decagonal(n):\n    return 4 * n * n - 3 * n\n[DONE]"}
{"idx": 269, "completion": "def sequential_search(arr, target):\n    for index, value in enumerate(arr):\n        if value == target:\n            return (True, index)\n    return (False, -1)\n[DONE]"}
{"idx": 270, "completion": "def all_unique(lst):\n    return len(lst) == len(set(lst))\n[DONE]"}
{"idx": 271, "completion": "def sub_list(list1, list2):\n    result = list(map(lambda x, y: x - y, list1, list2))\n    return result\n[DONE]"}
{"idx": 272, "completion": "def validate(num):\n    num_str = str(num)\n    for digit in set(num_str):\n        if num_str.count(digit) > int(digit):\n            return False\n    return True\n[DONE]"}
{"idx": 273, "completion": "def check_element(lst, string):\n    return all(item == string for item in lst)\n[DONE]"}
{"idx": 274, "completion": "import re\ndef text_match_two_three(text):\n    patterns = 'ab{2,3}'\n    if re.search(patterns, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 275, "completion": "def max_sub_array_sum_repeated(arr, n, k):\n    max_sum = float('-inf')\n    current_sum = 0\n    for i in range(n * k):\n        current_sum += arr[i % n]\n        if current_sum > max_sum:\n            max_sum = current_sum\n        if current_sum < 0:\n            current_sum = 0\n    return max_sum\n[DONE]"}
{"idx": 276, "completion": "def square_Sum(n):\n    sum = 0\n    for i in range(1, n + 1):\n        sum += (2 * i) ** 2\n    return sum\n[DONE]"}
{"idx": 277, "completion": "def modular_inverse(arr, n, p):\n    count = 0\n    for i in range(n):\n        for j in range(1, p):\n            if (arr[i] * j) % p == 1:\n                if j == arr[i]:\n                    count += 1\n                break\n    return count\n[DONE]"}
{"idx": 278, "completion": "def odd_Days(year):\n    # Calculate the number of odd days\n    # 100 years = 5 odd days\n    # 200 years = 3 odd days\n    # 300 years = 1 odd day\n    # 400 years = 0 odd days\n    # Every 400 years, the cycle repeats\n\n    # Calculate the number of 400-year cycles\n    cycles = year // 400\n    remaining_years = year % 400\n\n    # Calculate the number of odd days for the remaining years\n    odd_days = (remaining_years // 100) * 5\n    remaining_years = remaining_years % 100\n\n    # Calculate the number of leap years and normal years\n    leap_years = remaining_years // 4\n    normal_years = remaining_years - leap_years\n\n    # Each leap year has 2 odd days, and each normal year has 1 odd day\n    odd_days += leap_years * 2 + normal_years\n\n    # The total number of odd days should be modulo 7\n    odd_days = odd_days % 7\n\n    return odd_days\n[DONE]"}
{"idx": 279, "completion": "def max_length(lst):\n    max_len = max(len(sublist) for sublist in lst)\n    max_sublist = [sublist for sublist in lst if len(sublist) == max_len][0]\n    return (max_len, max_sublist)\n[DONE]"}
{"idx": 280, "completion": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same, diff = k, k * (k - 1)\n    for i in range(3, n + 1):\n        prev_diff = diff\n        diff = (same + diff) * (k - 1)\n        same = prev_diff\n    return same + diff\n[DONE]"}
{"idx": 281, "completion": "def find(num1, num2):\n    return num1 // num2\n[DONE]"}
{"idx": 282, "completion": "import math\ndef otherside_rightangle(side1, side2):\n    if side1 > side2:\n        return math.sqrt(side1**2 - side2**2)\n    else:\n        return math.sqrt(side2**2 - side1**2)\n[DONE]"}
{"idx": 283, "completion": "def max_val(lst):\n    return max(filter(lambda x: isinstance(x, (int, float)), lst))\n[DONE]"}
{"idx": 284, "completion": "def sum_div(n):\n    result = 0\n    for i in range(1, n):\n        if n % i == 0:\n            result += i\n    return result\n[DONE]"}
{"idx": 285, "completion": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] > arr[j]:\n                inv_count += 1\n    return inv_count\n[DONE]"}
{"idx": 286, "completion": "def flatten_list(nested_list):\n    flat_list = []\n    for element in nested_list:\n        if isinstance(element, list):\n            flat_list.extend(element)\n        else:\n            flat_list.append(element)\n    return flat_list\n[DONE]"}
{"idx": 287, "completion": "def intersection_nested_lists(list1, list2):\n    result = []\n    for sublist in list2:\n        intersection = list(set(sublist) & set(list1))\n        result.append(sorted(intersection))\n    return result\n[DONE]"}
{"idx": 288, "completion": "def max_aggregate(lst):\n    total = {}\n    for name, score in lst:\n        if name in total:\n            total[name] += score\n        else:\n            total[name] = score\n    max_name = max(total, key=total.get)\n    return (max_name, total[max_name])\n[DONE]"}
{"idx": 289, "completion": "def count_binary_seq(n):\n    return (2 ** (2 * n) + 2 ** n) / 2\n[DONE]"}
{"idx": 290, "completion": "def dict_depth(d):\n    if isinstance(d, dict):\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\n    return 0\n[DONE]"}
{"idx": 291, "completion": "def set_Bit_Number(n):\n    if n == 0:\n        return 0\n    msb = 0\n    n = int(n)\n    while n > 0:\n        n = int(n / 2)\n        msb += 1\n    return (1 << msb - 1)\n[DONE]"}
{"idx": 292, "completion": "def solve(arr, n):\n    count1 = 0\n    count2 = 0\n    for i in range(n):\n        if arr[i] == 0:\n            count1 += 1\n        elif arr[i] == 1:\n            count2 += 1\n    return count1 == count2\n[DONE]"}
{"idx": 293, "completion": "def find_Element(arr, rotations, index, rotation_index):\n    for i in range(rotation_index + 1):\n        start, end = rotations[i]\n        arr = arr[start:end + 1][::-1] + arr[end + 1:]\n    return arr[index]\n[DONE]"}
{"idx": 294, "completion": "def start_withp(words):\n    for word_pair in words:\n        split_words = word_pair.split()\n        if len(split_words) == 2 and split_words[0].startswith('P') and split_words[1].startswith('P'):\n            return (split_words[0], split_words[1])\n    return None\n[DONE]"}
{"idx": 295, "completion": "def max_sum_increasing_subseq(arr, n, i, k):\n    dp = [0] * n\n    for j in range(i + 1):\n        if j == 0:\n            dp[j] = arr[j]\n        else:\n            dp[j] = max(dp[j - 1], arr[j])\n    if arr[k] > arr[i]:\n        return dp[i] + arr[k]\n    else:\n        return dp[i]\n[DONE]"}
{"idx": 296, "completion": "def colon_tuplex(tup, index, value):\n    tup_list = list(tup)\n    tup_list[index] = [value]\n    return tuple(tup_list)\n[DONE]"}
{"idx": 297, "completion": "def large_product(list1, list2, n):\n    products = [x * y for x, y in zip(list1, list2)]\n    products.sort(reverse=True)\n    return products[:n]\n[DONE]"}
{"idx": 298, "completion": "def maximum(a, b):\n    return max(a, b)\n[DONE]"}
{"idx": 299, "completion": "def string_to_tuple(s):\n    return tuple(s)\n[DONE]"}
{"idx": 300, "completion": "def set_left_most_unset_bit(n):\n    if n & (n + 1) == 0:\n        return n\n    pos = 0\n    temp = n\n    while temp:\n        if not (temp & 1):\n            pos = 0\n        else:\n            pos += 1\n        temp >>= 1\n    return n | (1 << pos)\n[DONE]"}
{"idx": 301, "completion": "import math\ndef volume_cone(radius, height):\n    volume = (1/3) * math.pi * (radius ** 2) * height\n    return volume\n[DONE]"}
{"idx": 302, "completion": "def pos_nos(list1):\n    pos_nos = [num for num in list1 if num > 0]\n    return tuple(pos_nos)\n[DONE]"}
{"idx": 303, "completion": "def max_sum_rectangular_grid(grid, n):\n    dp = [0] * n\n    dp[0] = max(grid[0][0], grid[1][0])\n    if n > 1:\n        dp[1] = max(dp[0], grid[0][1], grid[1][1])\n    for i in range(2, n):\n        dp[i] = max(dp[i-1], dp[i-2] + max(grid[0][i], grid[1][i]))\n    return dp[-1]\n[DONE]"}
{"idx": 304, "completion": "def find_Max_Len_Even(str1):\n    words = str1.split()\n    max_len = -1\n    result = \"-1\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            result = word\n    return result\n[DONE]"}
{"idx": 305, "completion": "def find_last_occurrence(arr, target):\n    for i in range(len(arr) - 1, -1, -1):\n        if arr[i] == target:\n            return i\n    return -1\n[DONE]"}
{"idx": 306, "completion": "def modified_encode(lst):\n    if not lst:\n        return []\n    result = []\n    count = 1\n    for i in range(1, len(lst)):\n        if lst[i] == lst[i - 1]:\n            count += 1\n        else:\n            if count > 1:\n                result.append([count, lst[i - 1]])\n            else:\n                result.append(lst[i - 1])\n            count = 1\n    if count > 1:\n        result.append([count, lst[-1]])\n    else:\n        result.append(lst[-1])\n    return result\n[DONE]"}
{"idx": 307, "completion": "def max_volume(sum_of_sides):\n    if sum_of_sides < 3:\n        return 0\n    a = b = c = sum_of_sides // 3\n    return a * b * c\n[DONE]"}
{"idx": 308, "completion": "import re\ndef find_long_word(s):\n    long_words = re.findall(r'\\b\\w{5}\\b', s)\n    return long_words\n[DONE]"}
{"idx": 309, "completion": "def sum_difference(n):\n    sum_of_squares = sum(i**2 for i in range(1, n+1))\n    square_of_sum = sum(range(1, n+1))**2\n    return square_of_sum - sum_of_squares\n[DONE]"}
{"idx": 310, "completion": "def find_demlo(number):\n    length = len(number)\n    if length % 2 == 0:\n        half = length // 2\n        first_half = number[:half]\n        second_half = number[half:]\n        first_half_num = int(first_half)\n        second_half_num = int(second_half)\n        demlo_num = ''.join(str(i) for i in range(1, first_half_num + 1))\n        demlo_num += demlo_num[-2::-1]\n    else:\n        half = length // 2\n        first_half = number[:half + 1]\n        second_half = number[half + 1:]\n        first_half_num = int(first_half)\n        second_half_num = int(second_half)\n        demlo_num = ''.join(str(i) for i in range(1, first_half_num + 1))\n        demlo_num += demlo_num[-2::-1]\n    return demlo_num\n[DONE]"}
{"idx": 311, "completion": "def position_min(test_list):\n    min_val = min(test_list)\n    return [i for i, val in enumerate(test_list) if val == min_val]\n[DONE]"}
{"idx": 312, "completion": "def re_arrange(arr, n):\n    result = []\n    pos = [x for x in arr if x >= 0]\n    neg = [x for x in arr if x < 0]\n    i, j = 0, 0\n    while i < len(pos) or j < len(neg):\n        if j < len(neg):\n            result.append(neg[j])\n            j += 1\n        if i < len(pos):\n            result.append(pos[i])\n            i += 1\n    return result\n[DONE]"}
{"idx": 313, "completion": "def sum_of_alternates(test_tup):\n    sum1 = sum(test_tup[i] for i in range(0, len(test_tup), 2))\n    sum2 = sum(test_tup[i] for i in range(1, len(test_tup), 2))\n    return (sum1, sum2)\n[DONE]"}
{"idx": 314, "completion": "def get_Min_Squares(n):\n    if n <= 3:\n        return n\n    res = n\n    for x in range(1, n + 1):\n        temp = x * x\n        if temp > n:\n            break\n        else:\n            res = min(res, 1 + get_Min_Squares(n - temp))\n    return res\n[DONE]"}
{"idx": 315, "completion": "from collections import Counter\nimport re\n\ndef most_occurrences(strings_list):\n    words = re.findall(r'\\w+', ' '.join(strings_list).lower())\n    word_counts = Counter(words)\n    return word_counts.most_common(1)[0][0]\n[DONE]"}
{"idx": 316, "completion": "def check_isosceles(a, b, c):\n    if a == b or b == c or a == c:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 317, "completion": "def rotate_left(lst, n, k):\n    for _ in range(k):\n        lst = lst[n:] + lst[:n]\n    return lst\n[DONE]"}
{"idx": 318, "completion": "def neg_count(nums):\n    count = 0\n    for num in nums:\n        if num < 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 319, "completion": "import re\ndef find_char(text):\n    result = re.findall(r'\\b\\w{3,5}\\b', text)\n    return result\n[DONE]"}
{"idx": 320, "completion": "def count_unset_bits(n):\n    binary_representation = bin(n)\n    count = binary_representation.count('0') - 1  # Subtract 1 to exclude the '0b' prefix\n    return count\n[DONE]"}
{"idx": 321, "completion": "def char_frequency(string):\n    frequency = {}\n    for char in string:\n        if char in frequency:\n            frequency[char] += 1\n        else:\n            frequency[char] = 1\n    return frequency\n[DONE]"}
{"idx": 322, "completion": "def Sort(sub_li):\n    sub_li.sort(key = lambda x: x[1])\n    return sub_li\n[DONE]"}
{"idx": 323, "completion": "def check_Validity(a, b, c):\n    if a + b > c and a + c > b and b + c > a:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 324, "completion": "def ap_sum(a, n, d):\n    return n * (2 * a + (n - 1) * d) // 2\n[DONE]"}
{"idx": 325, "completion": "def check_monthnum(month):\n    return month == \"February\"\n[DONE]"}
{"idx": 326, "completion": "import re\ndef text_match_word(text):\n    if re.search(r'\\b\\w+\\.$', text.strip()):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 327, "completion": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i, len(s)):\n            if s[i] == s[j]:\n                count += 1\n    return count\n[DONE]"}
{"idx": 328, "completion": "def find_Divisor(start, end):\n    divisor_count = {}\n    for num in range(start, end + 1):\n        for i in range(1, num + 1):\n            if num % i == 0:\n                if i in divisor_count:\n                    divisor_count[i] += 1\n                else:\n                    divisor_count[i] = 1\n    max_count = max(divisor_count.values())\n    max_divisors = [divisor for divisor, count in divisor_count.items() if count == max_count]\n    return max(max_divisors)\n[DONE]"}
{"idx": 329, "completion": "def sum_three_smallest_nums(nums):\n    positive_nums = [num for num in nums if num > 0]\n    sorted_nums = sorted(positive_nums)\n    return sum(sorted_nums[:3])\n[DONE]"}
{"idx": 330, "completion": "def set_to_tuple(input_set):\n    return tuple(sorted(input_set))\n[DONE]"}
{"idx": 331, "completion": "import heapq\n\ndef find_minimum_range(arrays):\n    heap = []\n    max_val = -float('inf')\n    for i, array in enumerate(arrays):\n        heapq.heappush(heap, (array[0], i, 0))\n        max_val = max(max_val, array[0])\n    \n    min_range = (heap[0][0], max_val)\n    min_range_size = max_val - heap[0][0]\n    \n    while True:\n        val, arr_idx, elem_idx = heapq.heappop(heap)\n        if elem_idx + 1 == len(arrays[arr_idx]):\n            break\n        next_val = arrays[arr_idx][elem_idx + 1]\n        heapq.heappush(heap, (next_val, arr_idx, elem_idx + 1))\n        max_val = max(max_val, next_val)\n        current_min = heap[0][0]\n        if max_val - current_min < min_range_size:\n            min_range = (current_min, max_val)\n            min_range_size = max_val - current_min\n    \n    return min_range\n[DONE]"}
{"idx": 332, "completion": "def dig_let(s):\n    digits = sum(c.isdigit() for c in s)\n    letters = sum(c.isalpha() for c in s)\n    return (letters, digits)\n[DONE]"}
{"idx": 333, "completion": "def count_Odd_Squares(start, end):\n    count = 0\n    for i in range(start, end + 1):\n        if (i ** 0.5) % 1 == 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 334, "completion": "def diff_consecutivenums(nums):\n    diff_list = [nums[i+1] - nums[i] for i in range(len(nums)-1)]\n    return diff_list\n[DONE]"}
{"idx": 335, "completion": "def zigzag(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if k == 0:\n        return 0\n    return zigzag(n, k - 1) + zigzag(n - 1, n - k)\n[DONE]"}
{"idx": 336, "completion": "def count_Squares(a, b):\n    return (a * b * (a + 1) * (b + 1)) // 4\n[DONE]"}
{"idx": 337, "completion": "def find_ways(n):\n    if n % 2 != 0:\n        return 0\n    half = n // 2\n    return (half + 1) * (half + 2) // 2\n[DONE]"}
{"idx": 338, "completion": "def check(string):\n    for char in string:\n        if char not in ('0', '1'):\n            return \"No\"\n    return \"Yes\"\n[DONE]"}
{"idx": 339, "completion": "def minimum_Length(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    min_length = len(s)\n    for char in char_count:\n        current_length = len(s) - char_count[char]\n        if current_length < min_length:\n            min_length = current_length\n    return min_length\n[DONE]"}
{"idx": 340, "completion": "def first_Element(arr, n, k):\n    count_map = {}\n    for i in range(n):\n        if arr[i] in count_map:\n            count_map[arr[i]] += 1\n        else:\n            count_map[arr[i]] = 1\n        if count_map[arr[i]] == k:\n            return arr[i]\n    return -1\n[DONE]"}
{"idx": 341, "completion": "def unique_Characters(s):\n    return len(s) == len(set(s))\n[DONE]"}
{"idx": 342, "completion": "def remove_column(nested_list, column_index):\n    return [row[:column_index] + row[column_index+1:] for row in nested_list]\n[DONE]"}
{"idx": 343, "completion": "def tn_ap(a, d, n):\n    return a + (n - 1) * d\n[DONE]"}
{"idx": 344, "completion": "def count_Rectangles(r):\n    count = 0\n    for x in range(0, r + 1):\n        for y in range(0, r + 1):\n            if x**2 + y**2 <= r**2:\n                count += 1\n    return count\n[DONE]"}
{"idx": 345, "completion": "def find_angle(angle1, angle2):\n    third_angle = 180 - (angle1 + angle2)\n    return third_angle\n[DONE]"}
{"idx": 346, "completion": "def find_max(records):\n    max_element = max(max(record) for record in records)\n    return max_element\n[DONE]"}
{"idx": 347, "completion": "def moddiv_list(list1, list2):\n    moddiv_result = list(map(lambda x, y: x % y, list1, list2))\n    return moddiv_result\n[DONE]"}
{"idx": 348, "completion": "def Check_Solution(a, b, c):\n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return \"No\"\n    sqrt_discriminant = discriminant ** 0.5\n    root1 = (-b + sqrt_discriminant) / (2*a)\n    root2 = (-b - sqrt_discriminant) / (2*a)\n    if root1 == 2 * root2 or root2 == 2 * root1:\n        return \"Yes\"\n    else:\n        return \"No\"\n[DONE]"}
{"idx": 349, "completion": "def get_carol(n):\n    return (2 ** n - 1) ** 2 - 2\n[DONE]"}
{"idx": 350, "completion": "def remove_empty(lst):\n    return [item for item in lst if item != []]\n[DONE]"}
{"idx": 351, "completion": "from collections import Counter\n\ndef max_occurrences(lst):\n    if not lst:\n        return None\n    count = Counter(lst)\n    max_count = max(count.values())\n    return [item for item, freq in count.items() if freq == max_count]\n[DONE]"}
{"idx": 352, "completion": "def add_K_element(tuples, k):\n    result = [tuple(x + k for x in t) for t in tuples]\n    return result\n[DONE]"}
{"idx": 353, "completion": "def min_flip_to_make_string_alternate(binary_string):\n    def count_flips(start_char):\n        flips = 0\n        for char in binary_string:\n            if char != start_char:\n                flips += 1\n            start_char = '1' if start_char == '0' else '0'\n        return flips\n\n    return min(count_flips('0'), count_flips('1'))\n[DONE]"}
{"idx": 354, "completion": "def count_Digit(n):\n    return len(str(n))\n[DONE]"}
{"idx": 355, "completion": "def adjacent_num_product(nums):\n    max_product = 0\n    for i in range(len(nums) - 1):\n        product = nums[i] * nums[i + 1]\n        if product > max_product:\n            max_product = product\n    return max_product\n[DONE]"}
{"idx": 356, "completion": "class TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\n\ndef is_tree_balanced(root):\n    def check(node):\n        if node is None:\n            return 0\n        left = check(node.left)\n        if left == -1:\n            return -1\n        right = check(node.right)\n        if right == -1:\n            return -1\n        if abs(left - right) > 1:\n            return -1\n        return max(left, right) + 1\n\n    return check(root) != -1\n[DONE]"}
{"idx": 357, "completion": "def repeat_tuples(tup, n):\n    return (tup,) * n\n[DONE]"}
{"idx": 358, "completion": "def lateralsurface_cuboid(length, width, height):\n    lateral_surface_area = 2 * height * (length + width)\n    return lateral_surface_area\n[DONE]"}
{"idx": 359, "completion": "def float_sort(items):\n    sorted_items = sorted(items, key=lambda x: float(x[1]), reverse=True)\n    return sorted_items\n[DONE]"}
{"idx": 360, "completion": "def smallest_missing(arr, low, high):\n    for i in range(low, high + 1):\n        if i != arr[i]:\n            return i\n    return high + 1\n[DONE]"}
{"idx": 361, "completion": "import heapq\ndef heap_assending(lst):\n    heapq.heapify(lst)\n    sorted_lst = []\n    while lst:\n        sorted_lst.append(heapq.heappop(lst))\n    return sorted_lst\n[DONE]"}
{"idx": 362, "completion": "def volume_cuboid(length, width, height):\n    return length * width * height\n[DONE]"}
{"idx": 363, "completion": "from itertools import permutations\n\ndef permute_string(s):\n    return [''.join(p) for p in permutations(s)]\n[DONE]"}
{"idx": 364, "completion": "def round_num(n, multiple):\n    remainder = n % multiple\n    if remainder >= multiple / 2:\n        return n + (multiple - remainder)\n    else:\n        return n - remainder\n[DONE]"}
{"idx": 365, "completion": "def remove_replica(test_tup):\n    from collections import Counter\n    count = Counter(test_tup)\n    res = []\n    for elem in test_tup:\n        if count[elem] > 1:\n            res.append('MSP')\n            count[elem] -= 1\n        else:\n            res.append(elem)\n    return tuple(res)\n[DONE]"}
{"idx": 366, "completion": "def remove_Char(s, char):\n    return s.replace(char, '')\n[DONE]"}
{"idx": 367, "completion": "def move_first(lst):\n    if lst:\n        lst.insert(0, lst.pop())\n    return lst\n[DONE]"}
{"idx": 368, "completion": "def surfacearea_cuboid(l, w, h):\n    return 2 * (l * w + w * h + h * l)\n[DONE]"}
{"idx": 369, "completion": "def multi_list(rows, cols):\n    return [[col * row for col in range(cols)] for row in range(rows)]\n[DONE]"}
{"idx": 370, "completion": "def index_on_inner_list(lst, index):\n    return sorted(lst, key=lambda x: x[index])\n[DONE]"}
{"idx": 371, "completion": "def find_rotation_count(arr):\n    low = 0\n    high = len(arr) - 1\n    while low <= high:\n        if arr[low] <= arr[high]:\n            return low\n        mid = (low + high) // 2\n        next = (mid + 1) % len(arr)\n        prev = (mid - 1 + len(arr)) % len(arr)\n        if arr[mid] <= arr[next] and arr[mid] <= arr[prev]:\n            return mid\n        elif arr[mid] <= arr[high]:\n            high = mid - 1\n        elif arr[mid] >= arr[low]:\n            low = mid + 1\n    return -1\n[DONE]"}
{"idx": 372, "completion": "def even_bit_toggle_number(n):\n    return n ^ 0x55555555\n[DONE]"}
{"idx": 373, "completion": "def frequency_Of_Smallest(n,arr):\n    min_val = min(arr)\n    return arr.count(min_val)\n[DONE]"}
{"idx": 374, "completion": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n - 2) + get_perrin(n - 3)\n[DONE]"}
{"idx": 375, "completion": "def swap_count(s):\n    swaps = 0\n    left = 0\n    right = 0\n    for char in s:\n        if char == '[':\n            left += 1\n        elif char == ']':\n            right += 1\n        if right > left:\n            swaps += 1\n            left += 1\n            right -= 1\n    return swaps\n[DONE]"}
{"idx": 376, "completion": "def even_or_odd(hex_num):\n    decimal_num = int(hex_num, 16)\n    if decimal_num % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n[DONE]"}
{"idx": 377, "completion": "def highest_Power_of_2(n):\n    power = 1\n    while (power * 2) <= n:\n        power *= 2\n    return power\n[DONE]"}
{"idx": 378, "completion": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        a, b = 2, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b\n[DONE]"}
{"idx": 379, "completion": "def add_string(list_data, string):\n    return [string.format(item) for item in list_data]\n[DONE]"}
{"idx": 380, "completion": "def convert_list_dictionary(keys, names, values):\n    result = []\n    for key, name, value in zip(keys, names, values):\n        result.append({key: {name: value}})\n    return result\n[DONE]"}
{"idx": 381, "completion": "def get_max_sum(n):\n    def f(n):\n        if n == 0:\n            return 0\n        return max(f(n//2) + f(n//3) + f(n//4) + f(n//5), n)\n    return f(n)\n[DONE]"}
{"idx": 382, "completion": "def max_length_list(input_list):\n    max_len = max(map(lambda x: len(x), input_list))\n    max_list = list(filter(lambda x: len(x) == max_len, input_list))[0]\n    return (max_len, max_list)\n[DONE]"}
{"idx": 383, "completion": "def check_distinct(test_tup):\n    if len(test_tup) == len(set(test_tup)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 384, "completion": "def first_non_repeating_character(s):\n    char_count = {}\n    for char in s:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    for char in s:\n        if char_count[char] == 1:\n            return char\n    return None\n[DONE]"}
{"idx": 385, "completion": "import re\ndef check_char(s):\n    if re.match(r'^(.).*\\1$', s):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n[DONE]"}
{"idx": 386, "completion": "def median_numbers(a, b, c):\n    numbers = [a, b, c]\n    numbers.sort()\n    return float(numbers[1])\n[DONE]"}
{"idx": 387, "completion": "def sum_of_digits(nums):\n    total = 0\n    for num in nums:\n        if isinstance(num, (int, float)):\n            num = abs(int(num))\n            while num > 0:\n                total += num % 10\n                num //= 10\n    return total\n[DONE]"}
{"idx": 388, "completion": "def bitwise_xor(test_tup1, test_tup2):\n    res = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 389, "completion": "def extract_freq(test_list):\n    unique_tuples = set(test_list)\n    return len(unique_tuples)\n[DONE]"}
{"idx": 390, "completion": "def add_nested_tuples(tuple1, tuple2):\n    result = tuple(tuple(a + b for a, b in zip(t1, t2)) for t1, t2 in zip(tuple1, tuple2))\n    return result\n[DONE]"}
{"idx": 391, "completion": "def ncr_modp(n, r, p):\n    if r > n:\n        return 0\n    num = 1\n    for i in range(n, n - r, -1):\n        num = (num * i) % p\n    den = 1\n    for i in range(1, r + 1):\n        den = (den * i) % p\n    return (num * pow(den, p - 2, p)) % p\n[DONE]"}
{"idx": 392, "completion": "import re\ndef is_valid_URL(url):\n    regex = re.compile(\n        r'^(?:http|ftp)s?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+(?:[A-Z]{2,6}\\.?|[A-Z0-9-]{2,}\\.?)|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})'  # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return bool(regex.match(url))\n[DONE]"}
{"idx": 393, "completion": "def minimum(a, b):\n    return a if a < b else b\n[DONE]"}
{"idx": 394, "completion": "def check_tuplex(tuplex, element):\n    return element in tuplex\n[DONE]"}
{"idx": 395, "completion": "def find_Parity(n):\n    if bin(n).count('1') % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n[DONE]"}
{"idx": 396, "completion": "def rearrange_bigger(n):\n    digits = list(str(n))\n    for i in range(len(digits) - 1, 0, -1):\n        if digits[i] > digits[i - 1]:\n            break\n    else:\n        return False\n    for j in range(len(digits) - 1, i - 1, -1):\n        if digits[j] > digits[i - 1]:\n            break\n    digits[i - 1], digits[j] = digits[j], digits[i - 1]\n    digits[i:] = sorted(digits[i:])\n    return int(''.join(digits))\n[DONE]"}
{"idx": 397, "completion": "def k_smallest_pairs(nums1, nums2, k):\n    pairs = []\n    for num1 in nums1:\n        for num2 in nums2:\n            pairs.append([num1, num2])\n    pairs.sort(key=lambda x: x[0] + x[1])\n    return pairs[:k]\n[DONE]"}
{"idx": 398, "completion": "def min_product_tuple(test_list):\n    min_product = min(map(lambda x: x[0] * x[1], test_list))\n    return min_product\n[DONE]"}
{"idx": 399, "completion": "def min_val(lst):\n    return min(filter(lambda x: isinstance(x, int), lst))\n[DONE]"}
{"idx": 400, "completion": "import re\ndef snake_to_camel(snake_str):\n    components = snake_str.split('_')\n    return components[0] + ''.join(x.capitalize() for x in components[1:])\n[DONE]"}
{"idx": 401, "completion": "def remove_odd(nums):\n    return [x for x in nums if x % 2 == 0]\n[DONE]"}
{"idx": 402, "completion": "def extract_nth_element(test_list, n):\n    result = [x[n] for x in test_list]\n    return result\n[DONE]"}
{"idx": 403, "completion": "def overlapping(list1, list2):\n    for x in list1:\n        for y in list2:\n            if x == y:\n                return True\n    return False\n[DONE]"}
{"idx": 404, "completion": "def max_Product(arr):\n    arr.sort()\n    return (arr[-2], arr[-1])\n[DONE]"}
{"idx": 405, "completion": "def breakSum(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    return max(n, breakSum(n//2) + breakSum(n//3) + breakSum(n//4))\n[DONE]"}
{"idx": 406, "completion": "from itertools import groupby\nfrom operator import itemgetter\n\ndef group_tuples(tuples_list):\n    grouped_tuples = []\n    for key, group in groupby(sorted(tuples_list), key=itemgetter(0)):\n        group_list = list(group)\n        grouped_tuple = (key,) + tuple(item[1] for item in group_list)\n        grouped_tuples.append(grouped_tuple)\n    return grouped_tuples\n[DONE]"}
{"idx": 407, "completion": "def Find_Max(lst):\n    max_sublist = max(lst, key=len)\n    return max_sublist\n[DONE]"}
{"idx": 408, "completion": "def round_and_sum(nums):\n    rounded_nums = [round(num) for num in nums]\n    total_sum = sum(rounded_nums)\n    result = total_sum * len(nums)\n    return result\n[DONE]"}
{"idx": 409, "completion": "def cube_Sum(n):\n    even_numbers = [i for i in range(2, 2 * n + 1, 2)]\n    cube_sum = sum(map(lambda x: x ** 3, even_numbers))\n    return cube_sum\n[DONE]"}
{"idx": 410, "completion": "def concatenate_tuple(tup):\n    return '-'.join(map(str, tup))\n[DONE]"}
{"idx": 411, "completion": "def find_Average_Of_Cube(n):\n    sum_of_cubes = sum(i ** 3 for i in range(1, n + 1))\n    average = sum_of_cubes / n\n    return average\n[DONE]"}
{"idx": 412, "completion": "def get_maxgold(gold, m, n):\n    # Create a 2D table to store the maximum gold that can be collected\n    # from each cell (i, j)\n    maxGold = [[0 for i in range(n)] for j in range(m)]\n\n    # Initialize the first column of maxGold with the gold in the first column\n    for i in range(m):\n        maxGold[i][0] = gold[i][0]\n\n    # Fill the maxGold table\n    for col in range(1, n):\n        for row in range(m):\n            # Gold collected if we come from the left cell\n            left = maxGold[row][col - 1]\n            # Gold collected if we come from the top-left cell\n            if row > 0:\n                left_up = maxGold[row - 1][col - 1]\n            else:\n                left_up = 0\n            # Gold collected if we come from the bottom-left cell\n            if row < m - 1:\n                left_down = maxGold[row + 1][col - 1]\n            else:\n                left_down = 0\n            # Maximum gold collected from the three possible directions\n            maxGold[row][col] = gold[row][col] + max(left, left_up, left_down)\n\n    # The maximum gold collected will be the maximum value in the last column\n    max_gold = max(maxGold[i][n - 1] for i in range(m))\n    return max_gold\n[DONE]"}
{"idx": 413, "completion": "def extract_rear(test_tup):\n    res = [x[-1] for x in test_tup]\n    return res\n[DONE]"}
{"idx": 414, "completion": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n[DONE]"}
{"idx": 415, "completion": "def filter_oddnumbers(nums):\n    odd_numbers = list(filter(lambda x: x % 2 != 0, nums))\n    return odd_numbers\n[DONE]"}
{"idx": 416, "completion": "import re\ndef change_date_format(date):\n    return re.sub(r'(\\d{4})-(\\d{2})-(\\d{2})', '\\\\3-\\\\2-\\\\1', date)\n[DONE]"}
{"idx": 417, "completion": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\n[DONE]"}
{"idx": 418, "completion": "def and_tuples(test_tup1, test_tup2):\n    res = tuple(a & b for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 419, "completion": "def parabola_directrix(a, b, c):\n    directrix = - (1 + (4 * a * c - b ** 2)) / (4 * a)\n    return int(directrix)\n[DONE]"}
{"idx": 420, "completion": "def common_element(list1, list2):\n    for x in list1:\n        for y in list2:\n            if x == y:\n                return True\n    return None\n[DONE]"}
{"idx": 421, "completion": "def median_trapezium(a, b, h):\n    median = (a + b) / 2\n    return median\n[DONE]"}
{"idx": 422, "completion": "def check_greater(arr, num):\n    if num > max(arr):\n        return 'Yes, the entered number is greater than those in the array'\n    else:\n        return 'No, entered number is less than those in the array'\n[DONE]"}
{"idx": 423, "completion": "import re\ndef text_match_one(text):\n    if re.search(r'ab+', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 424, "completion": "def last_Digit(num):\n    return num % 10\n[DONE]"}
{"idx": 425, "completion": "def neg_nos(list1):\n    neg_nos = tuple(filter(lambda x: x < 0, list1))\n    return neg_nos\n[DONE]"}
{"idx": 426, "completion": "def remove_odd(s):\n    return s[1::2]\n[DONE]"}
{"idx": 427, "completion": "def count_bidirectional(tuples):\n    seen = set()\n    count = 0\n    for t in tuples:\n        if (t[1], t[0]) in seen:\n            count += 1\n        else:\n            seen.add(t)\n    return str(count)\n[DONE]"}
{"idx": 428, "completion": "def multiple_to_single(nums):\n    if nums[0] < 0:\n        return -int(''.join(map(str, nums[1:])))\n    else:\n        return int(''.join(map(str, nums)))\n[DONE]"}
{"idx": 429, "completion": "import re\ndef find_adverb_position(sentence):\n    adverbs = re.findall(r'\\b\\w+ly\\b', sentence)\n    if adverbs:\n        adverb = adverbs[0]\n        start = sentence.index(adverb)\n        end = start + len(adverb)\n        return (start, end, adverb)\n    return None\n[DONE]"}
{"idx": 430, "completion": "def surfacearea_cube(side):\n    return 6 * (side ** 2)\n[DONE]"}
{"idx": 431, "completion": "def positive_count(arr):\n    positive_numbers = list(filter(lambda x: x > 0, arr))\n    ratio = round(len(positive_numbers) / len(arr), 2)\n    return ratio\n[DONE]"}
{"idx": 432, "completion": "def largest_neg(nums):\n    neg_nums = [num for num in nums if num < 0]\n    if neg_nums:\n        return max(neg_nums)\n    return None\n[DONE]"}
{"idx": 433, "completion": "def trim_tuple(test_list, k):\n    result = [tuple(t[k:-k]) for t in test_list]\n    return str(result)\n[DONE]"}
{"idx": 434, "completion": "def index_multiplication(tuple1, tuple2):\n    result = tuple((a * b, c * d) for (a, c), (b, d) in zip(tuple1, tuple2))\n    return result\n[DONE]"}
{"idx": 435, "completion": "def count_Occurrence(test_tup, test_list):\n    count = 0\n    for i in test_list:\n        count += test_tup.count(i)\n    return count\n[DONE]"}
{"idx": 436, "completion": "def cube_nums(nums):\n    cube_nums = list(map(lambda x: x ** 3, nums))\n    return cube_nums\n[DONE]"}
{"idx": 437, "completion": "def cal_sum(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c = 3, 0, 2\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b\n        return c\n[DONE]"}
{"idx": 438, "completion": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    area = abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2.0)\n    if area == 0:\n        return 'No'\n    else:\n        return 'Yes'\n[DONE]"}
{"idx": 439, "completion": "def extract_string(str_list, size):\n    result = [s for s in str_list if len(s) == size]\n    return result\n[DONE]"}
{"idx": 440, "completion": "import re\ndef remove_whitespaces(input_string):\n    return re.sub(r'\\s+', '', input_string)\n[DONE]"}
{"idx": 441, "completion": "def loss_amount(cost_price, selling_price):\n    if selling_price > cost_price:\n        return selling_price - cost_price\n    else:\n        return None\n[DONE]"}
{"idx": 442, "completion": "def sumofFactors(n):\n    sum = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum += i\n    return sum\n[DONE]"}
{"idx": 443, "completion": "import re\ndef text_match_wordz(text):\n    if re.search(r'\\b\\w*z\\w*\\b', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 444, "completion": "def check_monthnumb_number(month):\n    return month in [1, 3, 5, 7, 8, 10, 12]\n[DONE]"}
{"idx": 445, "completion": "def reverse_string_list(string_list):\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list\n[DONE]"}
{"idx": 446, "completion": "def Find_Min(lst):\n    return min(lst, key=lambda x: len(x))\n[DONE]"}
{"idx": 447, "completion": "def rectangle_area(length, width):\n    return length * width\n[DONE]"}
{"idx": 448, "completion": "import re\ndef remove_uppercase(s):\n    return re.sub('[A-Z]+', '', s)\n[DONE]"}
{"idx": 449, "completion": "def Extract(lst):\n    return [item[0] for item in lst]\n[DONE]"}
{"idx": 450, "completion": "def upper_ctr(str):\n    count = 0\n    for char in str:\n        if char.isupper():\n            count += 1\n    return count\n[DONE]"}
{"idx": 451, "completion": "from itertools import combinations\n\ndef combinations_list(lst):\n    result = []\n    for i in range(len(lst) + 1):\n        for combo in combinations(lst, i):\n            result.append(list(combo))\n    return result\n[DONE]"}
{"idx": 452, "completion": "def max_subarray_product(arr):\n    max_ending_here = min_ending_here = max_so_far = arr[0]\n    for i in range(1, len(arr)):\n        temp = max_ending_here\n        max_ending_here = max(arr[i], max(arr[i] * max_ending_here, arr[i] * min_ending_here))\n        min_ending_here = min(arr[i], min(arr[i] * temp, arr[i] * min_ending_here))\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so_far\n[DONE]"}
{"idx": 453, "completion": "def check_value(dict, value):\n    return all(val == value for val in dict.values())\n[DONE]"}
{"idx": 454, "completion": "def drop_empty(d):\n    return {k: v for k, v in d.items() if v is not None}\n[DONE]"}
{"idx": 455, "completion": "def find_peak(arr, n):\n    if n == 1:\n        return 0\n    if arr[0] >= arr[1]:\n        return 0\n    if arr[n - 1] >= arr[n - 2]:\n        return n - 1\n    for i in range(1, n - 1):\n        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:\n            return i\n[DONE]"}
{"idx": 456, "completion": "def decimal_to_Octal(decimal):\n    octal = 0\n    i = 1\n    while (decimal != 0):\n        octal = octal + (decimal % 8) * i\n        decimal = int(decimal / 8)\n        i = i * 10\n    return octal\n[DONE]"}
{"idx": 457, "completion": "def max_product(arr, n):\n    max_prod = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if arr[i] < arr[j]:\n                for k in range(j + 1, n):\n                    if arr[j] < arr[k]:\n                        max_prod = max(max_prod, arr[i] * arr[j] * arr[k])\n    return max_prod\n[DONE]"}
{"idx": 458, "completion": "def max_profit(prices, k):\n    n = len(prices)\n    if n == 0:\n        return 0\n    profit = [0] * n\n    for t in range(k):\n        max_so_far = -prices[0]\n        for i in range(1, n):\n            max_so_far = max(max_so_far, profit[i] - prices[i])\n            profit[i] = max(profit[i-1], prices[i] + max_so_far)\n    return profit[-1]\n[DONE]"}
{"idx": 459, "completion": "def add_pairwise(tup):\n    result = tuple(x + y for x, y in zip(tup, tup[1:]))\n    return result\n[DONE]"}
{"idx": 460, "completion": "def find_remainder(arr, n, divisor):\n    product = 1\n    for num in arr:\n        product *= num\n    remainder = product % divisor\n    return remainder\n[DONE]"}
{"idx": 461, "completion": "def check_Consecutive(lst):\n    return sorted(lst) == list(range(min(lst), max(lst) + 1))\n[DONE]"}
{"idx": 462, "completion": "def tuple_intersection(list1, list2):\n    set1 = set(tuple(sorted(t)) for t in list1)\n    set2 = set(tuple(sorted(t)) for t in list2)\n    return set1 & set2\n[DONE]"}
{"idx": 463, "completion": "def replace_char(input_string, old_char, new_char):\n    return input_string.replace(old_char, new_char)\n[DONE]"}
{"idx": 464, "completion": "from collections import Counter\ndef sort_counter(counter):\n    sorted_counter = sorted(counter.items(), key=lambda item: item[1], reverse=True)\n    return sorted_counter\n[DONE]"}
{"idx": 465, "completion": "def big_sum(arr):\n    return max(arr) + min(arr)\n[DONE]"}
{"idx": 466, "completion": "def is_lower(s):\n    return s.lower()\n[DONE]"}
{"idx": 467, "completion": "def remove_lowercase(s):\n    result = \"\"\n    for char in s:\n        if not char.islower():\n            result += char\n    return result\n[DONE]"}
{"idx": 468, "completion": "def first_Digit(n):\n    while n >= 10:\n        n = n // 10\n    return n\n[DONE]"}
{"idx": 469, "completion": "def get_max_occuring_char(str1):\n    char_count = {}\n    for char in str1:\n        if char in char_count:\n            char_count[char] += 1\n        else:\n            char_count[char] = 1\n    max_char = max(char_count, key=char_count.get)\n    return max_char\n[DONE]"}
{"idx": 470, "completion": "def is_subset_sum(set, n, sum):\n    if sum == 0:\n        return True\n    if n == 0 and sum != 0:\n        return False\n    if set[n-1] > sum:\n        return is_subset_sum(set, n-1, sum)\n    return is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])\n[DONE]"}
{"idx": 471, "completion": "import re\ndef match(text):\n    pattern = r'[A-Z][a-z]+'\n    if re.search(pattern, text):\n        return 'Yes'\n    else:\n        return 'No'\n[DONE]"}
{"idx": 472, "completion": "def first_Factorial_Divisible_Number(x):\n    i = 1\n    factorial = 1\n    while True:\n        factorial *= i\n        if factorial % x == 0:\n            return i\n        i += 1\n[DONE]"}
{"idx": 473, "completion": "def remove_matching_tuple(tuple_list1, tuple_list2):\n    set2 = set(tuple_list2)\n    result = [item for item in tuple_list1 if item not in set2]\n    return result\n[DONE]"}
{"idx": 474, "completion": "def is_palindrome(n):\n    return str(n) == str(n)[::-1]\n\ndef largest_palindrome(arr, n):\n    max_palindrome = -1\n    for num in arr:\n        if is_palindrome(num) and num > max_palindrome:\n            max_palindrome = num\n    return max_palindrome\n[DONE]"}
{"idx": 475, "completion": "import math\n\ndef binomial_probability(n, k, p):\n    # Calculate the binomial coefficient\n    binomial_coefficient = math.comb(n, k)\n    # Calculate the probability\n    probability = binomial_coefficient * (p ** k) * ((1 - p) ** (n - k))\n    return probability\n[DONE]"}
{"idx": 476, "completion": "def sort_tuple(tuples_list):\n    return sorted(tuples_list, key=lambda x: x[-1])\n[DONE]"}
{"idx": 477, "completion": "import math\ndef area_pentagon(side):\n    area = (1/4) * math.sqrt(5 * (5 + 2 * math.sqrt(5))) * side ** 2\n    return area\n[DONE]"}
{"idx": 478, "completion": "def frequency_Of_Largest(n,arr):\n    max_val = max(arr)\n    return arr.count(max_val)\n[DONE]"}
{"idx": 479, "completion": "def extract_symmetric(tup_list):\n    symmetric_pairs = set()\n    for pair in tup_list:\n        if (pair[1], pair[0]) in symmetric_pairs:\n            symmetric_pairs.add(pair)\n        else:\n            symmetric_pairs.add(pair)\n    return symmetric_pairs\n[DONE]"}
{"idx": 480, "completion": "def sum_gp(a, n, r):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) // (1 - r)\n[DONE]"}
{"idx": 481, "completion": "def binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return True\n    return False\n[DONE]"}
{"idx": 482, "completion": "import math\n\ndef calculate_polygons(radius, num_rows, num_cols, start_x, start_y):\n    polygons = []\n    for row in range(num_rows):\n        y_offset = row * radius * math.sqrt(3)\n        for col in range(num_cols):\n            x_offset = col * radius * 1.5\n            if row % 2 == 1:\n                x_offset += radius * 0.75\n            x = start_x + x_offset\n            y = start_y + y_offset\n            hexagon = [\n                (x, y - radius),\n                (x - radius * 0.5, y - radius * 0.5),\n                (x - radius * 0.5, y + radius * 0.5),\n                (x, y + radius),\n                (x + radius * 0.5, y + radius * 0.5),\n                (x + radius * 0.5, y - radius * 0.5),\n                (x, y - radius)\n            ]\n            polygons.append(hexagon)\n    return polygons\n[DONE]"}
{"idx": 483, "completion": "def binary_to_integer(binary_tuple):\n    binary_str = ''.join(map(str, binary_tuple))\n    integer_value = int(binary_str, 2)\n    return str(integer_value)\n[DONE]"}
{"idx": 484, "completion": "import re\ndef remove_lowercase(s):\n    return re.sub('[a-z]+', '', s)\n[DONE]"}
{"idx": 485, "completion": "import heapq\ndef heap_queue_smallest(nums, n):\n    return heapq.nsmallest(n, nums)\n[DONE]"}
{"idx": 486, "completion": "import math\ndef surfacearea_cone(radius, height):\n    l = math.sqrt(radius**2 + height**2)\n    surface_area = math.pi * radius * (radius + l)\n    return surface_area\n[DONE]"}
{"idx": 487, "completion": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n[DONE]"}
{"idx": 488, "completion": "def diameter_circle(radius):\n    return 2 * radius\n[DONE]"}
{"idx": 489, "completion": "def concatenate_elements(elements):\n    concatenated_string = '  ' + ' '.join(elements)\n    return concatenated_string\n[DONE]"}
{"idx": 490, "completion": "def num_comm_div(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    common_divisors = 0\n    greatest_common_divisor = gcd(a, b)\n    for i in range(1, greatest_common_divisor + 1):\n        if greatest_common_divisor % i == 0:\n            common_divisors += 1\n    return common_divisors\n[DONE]"}
{"idx": 491, "completion": "def find(a, b):\n    return a % b\n[DONE]"}
{"idx": 492, "completion": "def add_consecutive_nums(nums):\n    result = []\n    for i in range(len(nums) - 1):\n        result.append(nums[i] + nums[i + 1])\n    return result\n[DONE]"}
{"idx": 493, "completion": "def sum_Of_Series(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n    return sum\n[DONE]"}
{"idx": 494, "completion": "def re_order(arr):\n    non_zero_elements = [x for x in arr if x != 0]\n    zero_elements = [0] * (len(arr) - len(non_zero_elements))\n    return non_zero_elements + zero_elements\n[DONE]"}
{"idx": 495, "completion": "def permutation_coefficient(n, k):\n    result = 1\n    for i in range(n - k + 1, n + 1):\n        result *= i\n    return result\n[DONE]"}
{"idx": 496, "completion": "def remove_words(list1, remove_words):\n    result = [word for word in list1 if word not in remove_words]\n    return result\n[DONE]"}
{"idx": 497, "completion": "def same_order(list1, list2):\n    common_elements = [element for element in list1 if element in list2]\n    index_in_list2 = [list2.index(element) for element in common_elements]\n    return index_in_list2 == sorted(index_in_list2)\n[DONE]"}
{"idx": 498, "completion": "def average_Odd(n):\n    odd_numbers = [i for i in range(1, n+1) if i % 2 != 0]\n    average = sum(odd_numbers) / len(odd_numbers)\n    return average\n[DONE]"}
{"idx": 499, "completion": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    count = 0\n    for i in range(1, 1 << n):\n        product = 1\n        for j in range(n):\n            if i & (1 << j):\n                product *= arr[j]\n        if product < k:\n            count += 1\n    return count\n[DONE]"}
