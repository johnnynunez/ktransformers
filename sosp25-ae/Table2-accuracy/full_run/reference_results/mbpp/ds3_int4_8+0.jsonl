{"idx": 0, "completion": "def remove_Occ(s, ch):\n    first = s.find(ch)\n    if first == -1:\n        return s\n    last = s.rfind(ch)\n    if first == last:\n        return s[:first] + s[first+1:]\n    else:\n        return s[:first] + s[first+1:last] + s[last+1:]\n[DONE]"}
{"idx": 1, "completion": "def sort_matrix(matrix):\n    matrix.sort(key=lambda row: sum(row))\n    return matrix\n[DONE]"}
{"idx": 2, "completion": "from collections import Counter\ndef count_common(words):\n    word_counts = Counter(words)\n    most_common = word_counts.most_common()\n    return most_common\n[DONE]"}
{"idx": 3, "completion": "def find_Volume(l, w, h):\n    return (l * w * h) / 2\n[DONE]"}
{"idx": 4, "completion": "def split_lowerstring(test_str):\n    res = []\n    for i in test_str:\n        if i.islower():\n            res.append(i)\n    return res\n[DONE]"}
{"idx": 5, "completion": "import re\ndef text_lowercase_underscore(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 6, "completion": "def square_perimeter(side):\n    perimeter = 4 * side\n    return perimeter\n[DONE]"}
{"idx": 7, "completion": "def remove_dirty_chars(str1, str2):\n    set2 = set(str2)\n    result = []\n    for char in str1:\n        if char not in set2:\n            result.append(char)\n    return ''.join(result)\n[DONE]"}
{"idx": 8, "completion": "def test_duplicate(array):\n    if len(array) != len(set(array)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 9, "completion": "def is_woodall(x):\n    if x < 1:\n        return False\n    n = 1\n    while True:\n        woodall = n * (2 ** n) - 1\n        if woodall == x:\n            return True\n        if woodall > x:\n            return False\n        n += 1\n[DONE]"}
{"idx": 10, "completion": "def multiples_of_num(m, n):\n    res = []\n    for i in range(1, m+1):\n        res.append(n * i)\n    return res\n[DONE]"}
{"idx": 11, "completion": "def find_first_duplicate(arr):\n    seen = set()\n    for num in arr:\n        if num in seen:\n            return num\n        seen.add(num)\n    return -1\n[DONE]"}
{"idx": 12, "completion": "def maximum_Sum(lists):\n    max_sum = 0\n    for list in lists:\n        if sum(list) > max_sum:\n            max_sum = sum(list)\n    return max_sum\n[DONE]"}
{"idx": 13, "completion": "def binary_to_decimal(binary):\n    binary_str = str(binary)\n    decimal = 0\n    length = len(binary_str)\n    for i in range(length):\n        if binary_str[i] == '1':\n            decimal += 2 ** (length - 1 - i)\n    return decimal\n[DONE]"}
{"idx": 14, "completion": "from collections import Counter\n\ndef find_Product(arr, n):\n    freq = Counter(arr)\n    product = 1\n    for num in arr:\n        if freq[num] == 1:\n            product *= num\n    return product\n[DONE]"}
{"idx": 15, "completion": "def check_k_elements(test_list, k):\n    for tup in test_list:\n        for elem in tup:\n            if elem != k:\n                return False\n    return True\n[DONE]"}
{"idx": 16, "completion": "def remove(list1):\n    res = []\n    for s in list1:\n        new_s = ''.join([i for i in s if not i.isdigit()])\n        res.append(new_s)\n    return res\n[DONE]"}
{"idx": 17, "completion": "import math\ndef binomial_Coeff(n,k):\n    return math.comb(n, k)\n[DONE]"}
{"idx": 18, "completion": "def get_Odd_Occurrence(arr, arr_size):\n    for i in range(arr_size):\n        count = 0\n        for j in range(arr_size):\n            if arr[i] == arr[j]:\n                count += 1\n        if (count % 2 != 0):\n            return arr[i]\n    return -1\n[DONE]"}
{"idx": 19, "completion": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n[DONE]"}
{"idx": 20, "completion": "import heapq\nfrom collections import defaultdict\n\ndef func(lists, k):\n    frequency = defaultdict(int)\n    for lst in lists:\n        for num in lst:\n            frequency[num] += 1\n    heap = []\n    for num, count in frequency.items():\n        if len(heap) < k:\n            heapq.heappush(heap, (count, num))\n        else:\n            if count > heap[0][0]:\n                heapq.heappop(heap)\n                heapq.heappush(heap, (count, num))\n    result = [num for count, num in sorted(heap, key=lambda x: (-x[0], x[1]))]\n    return result\n[DONE]"}
{"idx": 21, "completion": "import math\ndef max_Prime_Factors(n):\n    max_prime = -1\n    while n % 2 == 0:\n        max_prime = 2\n        n = n / 2\n    for i in range(3, int(math.sqrt(n)) + 1, 2):\n        while n % i == 0:\n            max_prime = i\n            n = n / i\n    if n > 2:\n        max_prime = n\n    return int(max_prime)\n[DONE]"}
{"idx": 22, "completion": "def decimal_To_Binary(n):\n    return int(bin(n)[2:])\n[DONE]"}
{"idx": 23, "completion": "def find_missing(arr, n):\n    for i in range(1, n + 1):\n        if i not in arr:\n            return i\n    return -1\n[DONE]"}
{"idx": 24, "completion": "def find_rect_num(n):\n    return n * (n + 1)\n[DONE]"}
{"idx": 25, "completion": "def find_Nth_Digit(num, den, n):\n    fraction = num / den\n    decimal_part = str(fraction).split('.')[1]\n    return int(decimal_part[n-1])\n[DONE]"}
{"idx": 26, "completion": "def sort_mixed_list(lst):\n    nums = sorted([x for x in lst if isinstance(x, int)])\n    strings = sorted([x for x in lst if isinstance(x, str)])\n    return nums + strings\n[DONE]"}
{"idx": 27, "completion": "def div_even_odd(list1):\n    even = None\n    odd = None\n    for num in list1:\n        if even is None and num % 2 == 0:\n            even = num\n        if odd is None and num % 2 != 0:\n            odd = num\n        if even is not None and odd is not None:\n            break\n    return even / odd\n[DONE]"}
{"idx": 28, "completion": "from collections import Counter\nimport heapq\n\ndef rearange_string(s):\n    count = Counter(s)\n    max_heap = [(-value, key) for key, value in count.items()]\n    heapq.heapify(max_heap)\n    result = []\n    prev_char = None\n    prev_count = 0\n    while max_heap:\n        current = heapq.heappop(max_heap)\n        result.append(current[1])\n        if prev_count < 0:\n            heapq.heappush(max_heap, (prev_count, prev_char))\n        prev_char = current[1]\n        prev_count = current[0] + 1\n    if len(result) == len(s):\n        return ''.join(result)\n    else:\n        return ''\n[DONE]"}
{"idx": 29, "completion": "from collections import Counter\ndef freq_element(test_list):\n    res = dict(Counter(i for j in test_list for i in j))\n    return res\n[DONE]"}
{"idx": 30, "completion": "def filter_evennumbers(nums):\n    even_nums = list(filter(lambda x: (x % 2 == 0), nums))\n    return even_nums\n[DONE]"}
{"idx": 31, "completion": "def find_Sum(arr,n):\n    sum = 0\n    for i in range(n):\n        if arr.count(arr[i]) > 1:\n            sum += arr[i]\n    return sum // 2\n[DONE]"}
{"idx": 32, "completion": "import re\ndef text_match(text):\n    pattern = r'^[a-z]+_[a-z]+$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 33, "completion": "import re\ndef text_match_string(text):\n    pattern = r'^[a-zA-Z]'\n    if re.search(pattern, text.strip()):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 34, "completion": "import math\nfrom functools import reduce\n\ndef get_gcd(arr):\n    x = reduce(math.gcd, arr)\n    return x\n[DONE]"}
{"idx": 35, "completion": "def test_distinct(data):\n    if len(data) == len(set(data)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 36, "completion": "def compute_Last_Digit(a, b):\n    if a == 0:\n        a_fact = 1\n    else:\n        a_fact = 1\n        for i in range(1, a + 1):\n            a_fact *= i\n    if b == 0:\n        b_fact = 1\n    else:\n        b_fact = 1\n        for i in range(1, b + 1):\n            b_fact *= i\n    if a_fact == 0:\n        return 0\n    else:\n        return (b_fact // a_fact) % 10\n[DONE]"}
{"idx": 37, "completion": "def odd_bit_set_number(n):\n    mask = 0x55555555  # This is a mask with all odd bits set (0x55555555 in hex is 01010101... in binary)\n    return n | mask\n[DONE]"}
{"idx": 38, "completion": "def specified_element(lst, n):\n    res = [i[n] for i in lst]\n    return res\n[DONE]"}
{"idx": 39, "completion": "def min_length_list(lists):\n    min_list = min(lists, key=lambda x: len(x))\n    return (len(min_list), min_list)\n[DONE]"}
{"idx": 40, "completion": "def check_equilateral(x,y,z):\n    if x == y == z:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 41, "completion": "def parallelogram_area(base, height):\n    area = base * height\n    return area\n[DONE]"}
{"idx": 42, "completion": "def check_Equality(test_str):\n    if test_str[0] == test_str[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"\n[DONE]"}
{"idx": 43, "completion": "def counting_sort(arr):\n    max_element = max(arr)\n    min_element = min(arr)\n    range_of_elements = max_element - min_element + 1\n    count = [0] * range_of_elements\n    output = [0] * len(arr)\n    \n    for num in arr:\n        count[num - min_element] += 1\n    \n    for i in range(1, len(count)):\n        count[i] += count[i-1]\n    \n    for num in reversed(arr):\n        output[count[num - min_element] - 1] = num\n        count[num - min_element] -= 1\n    \n    return output\n[DONE]"}
{"idx": 44, "completion": "def tn_gp(a1, a2, n):\n    r = a2 / a1\n    an = a1 * (r ** (n - 1))\n    return an\n[DONE]"}
{"idx": 45, "completion": "def check(n):\n    reversed_n = int(str(n)[::-1])\n    return n == 2 * reversed_n - 1\n[DONE]"}
{"idx": 46, "completion": "def find_Max_Num(arr, n):\n    arr.sort(reverse=True)\n    num = int(''.join(map(str, arr)))\n    return num\n[DONE]"}
{"idx": 47, "completion": "def opposite_Signs(x,y):\n    return (x * y) < 0\n[DONE]"}
{"idx": 48, "completion": "def is_octagonal(n):\n    return n * (3 * n - 2)\n[DONE]"}
{"idx": 49, "completion": "def max_len_sub(arr, n):\n    dp = [1] * n\n    for i in range(1, n):\n        for j in range(i):\n            if abs(arr[i] - arr[j]) == 1 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n    return max(dp)\n[DONE]"}
{"idx": 50, "completion": "def count_Substrings(s, n):\n    count = 0\n    for i in range(n):\n        current_sum = 0\n        for j in range(i, n):\n            current_sum += int(s[j])\n            length = j - i + 1\n            if current_sum == length:\n                count += 1\n    return count\n[DONE]"}
{"idx": 51, "completion": "def smallest_num(list1):\n    min = list1[0]\n    for a in list1:\n        if a < min:\n            min = a\n    return min\n[DONE]"}
{"idx": 52, "completion": "def max_difference(test_list):\n    max_diff = 0\n    for tup in test_list:\n        diff = abs(tup[0] - tup[1])\n        if diff > max_diff:\n            max_diff = diff\n    return max_diff\n[DONE]"}
{"idx": 53, "completion": "def subject_marks(subject_data):\n    subject_data.sort(key=lambda x: x[1])\n    return subject_data\n[DONE]"}
{"idx": 54, "completion": "def recursive_list_sum(data):\n    total = 0\n    for element in data:\n        if isinstance(element, list):\n            total += recursive_list_sum(element)\n        else:\n            total += element\n    return total\n[DONE]"}
{"idx": 55, "completion": "def pos_count(list1):\n    count = 0\n    for num in list1:\n        if num > 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 56, "completion": "def bell_number(n):\n    bell = [[0] * (n + 1) for _ in range(n + 1)]\n    bell[0][0] = 1\n    for i in range(1, n + 1):\n        bell[i][0] = bell[i - 1][i - 1]\n        for j in range(1, i + 1):\n            bell[i][j] = bell[i - 1][j - 1] + bell[i][j - 1]\n    return bell[n][0]\n[DONE]"}
{"idx": 57, "completion": "def is_Monotonic(A):\n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1)))\n[DONE]"}
{"idx": 58, "completion": "def is_sublist(main_list, sublist):\n    n = len(sublist)\n    for i in range(len(main_list) - n + 1):\n        if main_list[i:i+n] == sublist:\n            return True\n    return False\n[DONE]"}
{"idx": 59, "completion": "def get_equal(test_tup, length):\n    for tup in test_tup:\n        if len(tup) != length:\n            return 'All tuples do not have same length'\n    return 'All tuples have same length'\n[DONE]"}
{"idx": 60, "completion": "def comb_sort(arr):\n    n = len(arr)\n    gap = n\n    shrink = 1.3\n    swapped = True\n\n    while gap > 1 or swapped:\n        gap = int(gap / shrink)\n        if gap < 1:\n            gap = 1\n        swapped = False\n        for i in range(n - gap):\n            if arr[i] > arr[i + gap]:\n                arr[i], arr[i + gap] = arr[i + gap], arr[i]\n                swapped = True\n    return arr\n[DONE]"}
{"idx": 61, "completion": "def dif_Square(n):\n    if n % 2 != 0 or n % 4 == 0:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 62, "completion": "import re\ndef multiple_split(string):\n    return re.split('[\\n*]', string)\n[DONE]"}
{"idx": 63, "completion": "def is_samepatterns(colors, patterns):\n    if len(colors) != len(patterns):\n        return False\n    color_to_pattern = {}\n    pattern_to_color = {}\n    for color, pattern in zip(colors, patterns):\n        if color in color_to_pattern:\n            if color_to_pattern[color] != pattern:\n                return False\n        else:\n            color_to_pattern[color] = pattern\n        if pattern in pattern_to_color:\n            if pattern_to_color[pattern] != color:\n                return False\n        else:\n            pattern_to_color[pattern] = color\n    return True\n[DONE]"}
{"idx": 64, "completion": "def find_tuples(lst, k):\n    result = [tup for tup in lst if all(x % k == 0 for x in tup)]\n    return str(result)\n[DONE]"}
{"idx": 65, "completion": "def count_Squares(n, m):\n    count = 0\n    for i in range(1, min(n, m) + 1):\n        count += (n - i + 1) * (m - i + 1)\n    return count\n[DONE]"}
{"idx": 66, "completion": "def is_Diff(n):\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(n):\n        num = int(digit)\n        if num % 2 == 0:\n            even_sum += num\n        else:\n            odd_sum += num\n    return abs(even_sum - odd_sum) % 11 == 0\n[DONE]"}
{"idx": 67, "completion": "def count_With_Odd_SetBits(n):\n    count = 0\n    for i in range(1, n + 1):\n        if bin(i).count('1') % 2 != 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 68, "completion": "def word_len(word):\n    return len(word) % 2 != 0\n[DONE]"}
{"idx": 69, "completion": "def tetrahedral_number(n):\n    return (n * (n + 1) * (n + 2)) / 6\n[DONE]"}
{"idx": 70, "completion": "def zip_tuples(tuple1, tuple2):\n    max_len = max(len(tuple1), len(tuple2))\n    zipped = []\n    for i in range(max_len):\n        val1 = tuple1[i % len(tuple1)]\n        val2 = tuple2[i % len(tuple2)]\n        zipped.append((val1, val2))\n    return zipped\n[DONE]"}
{"idx": 71, "completion": "import math\ndef volume_sphere(radius):\n    volume = (4/3) * math.pi * (radius ** 3)\n    return volume\n[DONE]"}
{"idx": 72, "completion": "def get_Char(str1):\n    total = 0\n    for c in str1:\n        total += ord(c)\n    total = total % 26\n    total = total + ord('a')\n    return chr(total)\n[DONE]"}
{"idx": 73, "completion": "def sequence(n):\n    if n == 1 or n == 2:\n        return 1\n    arr = [0] * (n + 1)\n    arr[1], arr[2] = 1, 1\n    for i in range(3, n + 1):\n        arr[i] = arr[arr[i - 1]] + arr[i - arr[i - 1]]\n    return arr[n]\n[DONE]"}
{"idx": 74, "completion": "import math\ndef surfacearea_sphere(r):\n    return 4 * math.pi * r * r\n[DONE]"}
{"idx": 75, "completion": "def centered_hexagonal_number(n):\n    return 3 * n * (n - 1) + 1\n[DONE]"}
{"idx": 76, "completion": "def merge_dictionaries_three(dict1, dict2, dict3):\n    merged_dict = dict1.copy()\n    merged_dict.update(dict2)\n    merged_dict.update(dict3)\n    return merged_dict\n[DONE]"}
{"idx": 77, "completion": "def freq_count(list):\n    freq = {}\n    for item in list:\n        if (item in freq):\n            freq[item] += 1\n        else:\n            freq[item] = 1\n    return freq\n[DONE]"}
{"idx": 78, "completion": "def closest_num(n):\n    return n - 1\n[DONE]"}
{"idx": 79, "completion": "def len_log(list1):\n    max_len = 0\n    for word in list1:\n        if len(word) > max_len:\n            max_len = len(word)\n    return max_len\n[DONE]"}
{"idx": 80, "completion": "def find_substring(list_string, sub_string):\n    for string in list_string:\n        if sub_string in string:\n            return True\n    return False\n[DONE]"}
{"idx": 81, "completion": "def is_undulating(n):\n    if len(n) < 2:\n        return False\n    if len(set(n)) != 2:\n        return False\n    for i in range(len(n)-1):\n        if n[i] == n[i+1]:\n            return False\n    return True\n[DONE]"}
{"idx": 82, "completion": "def power(a, b):\n    return a ** b\n[DONE]"}
{"idx": 83, "completion": "def index_minimum(test_list):\n    min_val = float('inf')\n    min_name = \"\"\n    for name, value in test_list:\n        if value < min_val:\n            min_val = value\n            min_name = name\n    return min_name\n[DONE]"}
{"idx": 84, "completion": "def Find_Min_Length(test_list):\n    min_length = min(len(sublist) for sublist in test_list)\n    return min_length\n[DONE]"}
{"idx": 85, "completion": "def divisor(n):\n    count = 0\n    for i in range(1, n + 1):\n        if n % i == 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 86, "completion": "def frequency_lists(list1):\n    frequency_dict = {}\n    for sublist in list1:\n        for item in sublist:\n            if item in frequency_dict:\n                frequency_dict[item] += 1\n            else:\n                frequency_dict[item] = 1\n    return frequency_dict\n[DONE]"}
{"idx": 87, "completion": "def multiply_num(numbers):\n    product = 1\n    for num in numbers:\n        product *= num\n    return product / len(numbers)\n[DONE]"}
{"idx": 88, "completion": "def decimal_to_binary(n):\n    return bin(n).replace(\"0b\", \"\")\n[DONE]"}
{"idx": 89, "completion": "def next_smallest_palindrome(num):\n    num += 1\n    while str(num) != str(num)[::-1]:\n        num += 1\n    return num\n[DONE]"}
{"idx": 90, "completion": "def kth_element(arr, n, k):\n    arr.sort()\n    return arr[k-1]\n[DONE]"}
{"idx": 91, "completion": "def snake_to_camel(s):\n    words = s.split('_')\n    camel_case = ''.join([word.capitalize() for word in words])\n    return camel_case\n[DONE]"}
{"idx": 92, "completion": "def eulerian_num(n, m):\n    if m >= n or n == 0:\n        return 0\n    if m == 0:\n        return 1\n    return (n - m) * eulerian_num(n - 1, m - 1) + (m + 1) * eulerian_num(n - 1, m)\n[DONE]"}
{"idx": 93, "completion": "def sort_sublists(l):\n    return [sorted(sublist, key=lambda x: x) for sublist in l]\n[DONE]"}
{"idx": 94, "completion": "def count(lst):\n    return sum(lst)\n[DONE]"}
{"idx": 95, "completion": "def add_lists(test_list, test_tup):\n    res = test_tup + tuple(test_list)\n    return res\n[DONE]"}
{"idx": 96, "completion": "def count_Hexadecimal(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        if num >= 10 and num <= 15:\n            count += 1\n    return count\n[DONE]"}
{"idx": 97, "completion": "import heapq\n\ndef merge_sorted_list(l1, l2, l3):\n    return list(heapq.merge(l1, l2, l3))\n[DONE]"}
{"idx": 98, "completion": "def odd_Equivalent(s, n): \n    count = 0\n    for i in range(n):\n        rotated = s[i:] + s[:i]\n        if int(rotated, 2) % 2 != 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 99, "completion": "def extract_missing(ranges, start, end):\n    missing = []\n    # Process the start of the first range\n    first_start, first_end = ranges[0]\n    if start < first_start:\n        missing.append((start, first_start))\n    # Process the end of the first range\n    if first_end < end:\n        missing.append((first_end, end))\n    # Process the rest of the ranges\n    for i in range(1, len(ranges)):\n        prev_end = ranges[i-1][1]\n        current_start, current_end = ranges[i]\n        if prev_end < current_start:\n            missing.append((prev_end, current_start))\n        if current_end < end:\n            missing.append((current_end, end))\n    return missing\n[DONE]"}
{"idx": 100, "completion": "def common_in_nested_lists(nested_list):\n    if not nested_list:\n        return []\n    common_elements = set(nested_list[0])\n    for lst in nested_list[1:]:\n        common_elements.intersection_update(lst)\n    return sorted(common_elements, reverse=True)\n[DONE]"}
{"idx": 101, "completion": "import math\ndef perimeter(r, h):\n    perimeter = 2 * (2 * r + h)\n    return perimeter\n[DONE]"}
{"idx": 102, "completion": "def check_integer(string):\n    if string.isdigit():\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 103, "completion": "from collections import defaultdict\n\ndef assign_freq(test_list):\n    freq = defaultdict(int)\n    for t in test_list:\n        freq[t] += 1\n    result = []\n    for t in test_list:\n        if t in freq:\n            new_t = t + (freq[t],)\n            result.append(new_t)\n            del freq[t]\n    return str(result)\n[DONE]"}
{"idx": 104, "completion": "def empty_dit(list1):\n    for element in list1:\n        if element:\n            return False\n    return True\n[DONE]"}
{"idx": 105, "completion": "def tuple_to_int(tup):\n    res = int(''.join(map(str, tup)))\n    return res\n[DONE]"}
{"idx": 106, "completion": "def list_to_float(test_list):\n    converted = []\n    for tup in test_list:\n        new_tup = []\n        for elem in tup:\n            try:\n                new_elem = float(elem)\n            except ValueError:\n                new_elem = elem\n            new_tup.append(new_elem)\n        converted.append(tuple(new_tup))\n    return str(converted)\n[DONE]"}
{"idx": 107, "completion": "def string_to_list(string):\n    return string.split()\n[DONE]"}
{"idx": 108, "completion": "def search(arr, n):\n    for i in range(0, n, 2):\n        if i == n - 1 or arr[i] != arr[i + 1]:\n            return arr[i]\n    return -1\n[DONE]"}
{"idx": 109, "completion": "def max_product_tuple(list1):\n    max_product = 0\n    for tuple1 in list1:\n        product = tuple1[0] * tuple1[1]\n        if product > max_product:\n            max_product = product\n    return max_product\n[DONE]"}
{"idx": 110, "completion": "def check_triplet(arr, n, sum, count):\n    if count == 3 and sum == 0:\n        return True\n    if count == 3 or n == 0 or sum < 0:\n        return False\n    return check_triplet(arr, n - 1, sum - arr[n - 1], count + 1) or check_triplet(arr, n - 1, sum, count)\n[DONE]"}
{"idx": 111, "completion": "def smartNumber(n):\n    count = 0\n    num = 1\n    while True:\n        temp = num\n        factors = set()\n        for i in [2, 3, 5]:\n            while temp % i == 0:\n                factors.add(i)\n                temp = temp // i\n        if temp == 1 and len(factors) == 3:\n            count += 1\n            if count == n:\n                return num\n        num += 1\n[DONE]"}
{"idx": 112, "completion": "def amicable_numbers_sum(n):\n    def sum_proper_divisors(num):\n        if num == 1:\n            return 0\n        sum_div = 1\n        sqrt_num = int(num ** 0.5)\n        for i in range(2, sqrt_num + 1):\n            if num % i == 0:\n                sum_div += i\n                other_div = num // i\n                if other_div != i:\n                    sum_div += other_div\n        return sum_div\n\n    amicable_sum = 0\n    for a in range(1, n + 1):\n        b = sum_proper_divisors(a)\n        if a != b and sum_proper_divisors(b) == a and a < b:\n            amicable_sum += a + b\n    return amicable_sum\n[DONE]"}
{"idx": 113, "completion": "import cmath\ndef angle_complex(x, y):\n    z = complex(x, y)\n    return cmath.phase(z)\n[DONE]"}
{"idx": 114, "completion": "def find_length(bin_str, n):\n    max_diff = 0\n    for i in range(n):\n        count0 = 0\n        count1 = 0\n        for j in range(i, n):\n            if bin_str[j] == '0':\n                count0 += 1\n            else:\n                count1 += 1\n            current_diff = abs(count0 - count1)\n            if current_diff > max_diff:\n                max_diff = current_diff\n    return max_diff\n[DONE]"}
{"idx": 115, "completion": "def sum(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    def get_common_divisors(n):\n        divisors = set()\n        for i in range(1, int(n**0.5) + 1):\n            if n % i == 0:\n                divisors.add(i)\n                divisors.add(n // i)\n        return divisors\n    common_divisors = get_common_divisors(gcd(a, b))\n    return sum(common_divisors)\n[DONE]"}
{"idx": 116, "completion": "def multiply_int(a, b):\n    result = 0\n    for _ in range(abs(b)):\n        result += a\n    if b < 0:\n        result = -result\n    return result\n[DONE]"}
{"idx": 117, "completion": "def long_words(n, str):\n    word_list = str.split()\n    long_words_list = [word for word in word_list if len(word) > n]\n    return long_words_list\n[DONE]"}
{"idx": 118, "completion": "def magic_square_test(test_square):\n    n = len(test_square)\n    magic_sum = n * (n ** 2 + 1) // 2\n    \n    # Check rows\n    for row in test_square:\n        if sum(row) != magic_sum:\n            return False\n    \n    # Check columns\n    for j in range(n):\n        if sum(test_square[i][j] for i in range(n)) != magic_sum:\n            return False\n    \n    # Check diagonals\n    if sum(test_square[i][i] for i in range(n)) != magic_sum:\n        return False\n    if sum(test_square[i][n - 1 - i] for i in range(n)) != magic_sum:\n        return False\n    \n    return True\n[DONE]"}
{"idx": 119, "completion": "from collections import Counter\ndef max_occurrences(nums):\n    count = Counter(nums)\n    max_count = max(count.values())\n    max_num = [num for num, cnt in count.items() if cnt == max_count][0]\n    return (max_num, max_count)\n[DONE]"}
{"idx": 120, "completion": "def reverse_vowels(s):\n    vowels = []\n    s_list = list(s)\n    for char in s_list:\n        if char.lower() in {'a', 'e', 'i', 'o', 'u'}:\n            vowels.append(char)\n    vowels.reverse()\n    vowel_index = 0\n    for i in range(len(s_list)):\n        if s_list[i].lower() in {'a', 'e', 'i', 'o', 'u'}:\n            s_list[i] = vowels[vowel_index]\n            vowel_index += 1\n    return ''.join(s_list)\n[DONE]"}
{"idx": 121, "completion": "def tup_string(tup):\n    return ''.join(tup)\n[DONE]"}
{"idx": 122, "completion": "def sum_negativenum(nums):\n    negative_nums = list(filter(lambda x: x < 0, nums))\n    return sum(negative_nums)\n[DONE]"}
{"idx": 123, "completion": "def check_last(arr, p, n):\n    last_element = arr[-1]\n    if p % 2 == 0:\n        return \"EVEN\" if last_element % 2 == 0 else \"ODD\"\n    else:\n        return \"ODD\" if last_element % 2 != 0 else \"EVEN\"\n[DONE]"}
{"idx": 124, "completion": "def hexagonal_num(n):\n    return n * (2 * n - 1)\n[DONE]"}
{"idx": 125, "completion": "def cal_electbill(units):\n    if units <= 50:\n        bill = units * 2.5\n    elif units <= 150:\n        bill = 50 * 2.5 + (units - 50) * 3.5\n    elif units <= 250:\n        bill = 50 * 2.5 + 100 * 3.5 + (units - 150) * 4.5\n    else:\n        bill = 50 * 2.5 + 100 * 3.5 + 100 * 4.5 + (units - 250) * 5.5\n    return bill\n[DONE]"}
{"idx": 126, "completion": "def zero_count(nums):\n    count = nums.count(0)\n    ratio = count / len(nums)\n    return round(ratio, 2)\n[DONE]"}
{"idx": 127, "completion": "def is_Sum_Of_Powers_Of_Two(n):\n    if n == 0:\n        return False\n    while n > 0:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = (n - 1) // 2\n            if n == 0:\n                return True\n            else:\n                continue\n    return False\n[DONE]"}
{"idx": 128, "completion": "import math\ndef circle_circumference(radius):\n    circumference = 2 * math.pi * radius\n    return circumference\n[DONE]"}
{"idx": 129, "completion": "def extract_singly(test_list):\n    result = []\n    for tup in test_list:\n        for num in tup:\n            if num not in result:\n                result.append(num)\n    return result\n[DONE]"}
{"idx": 130, "completion": "def pancake_sort(arr):\n    n = len(arr)\n    for size in range(n, 1, -1):\n        max_index = max_index_of(arr, size)\n        if max_index != size - 1:\n            flip(arr, max_index)\n            flip(arr, size - 1)\n    return arr\n\ndef max_index_of(arr, n):\n    max_index = 0\n    for i in range(n):\n        if arr[i] > arr[max_index]:\n            max_index = i\n    return max_index\n\ndef flip(arr, k):\n    left = 0\n    while left < k:\n        arr[left], arr[k] = arr[k], arr[left]\n        left += 1\n        k -= 1\n[DONE]"}
{"idx": 131, "completion": "def count_samepair(list1,list2,list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] == list3[i]:\n            count += 1\n    return count\n[DONE]"}
{"idx": 132, "completion": "def find_lists(tuple1):\n    count = 0\n    for element in tuple1:\n        if isinstance(element, list):\n            count += 1\n    return count\n[DONE]"}
{"idx": 133, "completion": "def sum_Pairs(arr, n):\n    sum = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            sum += abs(arr[i] - arr[j])\n    return sum\n[DONE]"}
{"idx": 134, "completion": "def max_Abs_Diff(arr, n):\n    max_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff\n[DONE]"}
{"idx": 135, "completion": "def ascii_value_string(string):\n    total = 0\n    for char in string:\n        total += ord(char)\n    return total\n[DONE]"}
{"idx": 136, "completion": "def max_path_sum(triangle, row, col):\n    for i in range(row - 1, -1, -1):\n        for j in range(i + 1):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n[DONE]"}
{"idx": 137, "completion": "def sum_digits_twoparts(num):\n    max_sum = 0\n    s = str(num)\n    for i in range(1, len(s)):\n        part1 = int(s[:i])\n        part2 = int(s[i:])\n        current_sum = sum(int(d) for d in str(part1)) + sum(int(d) for d in str(part2))\n        if current_sum > max_sum:\n            max_sum = current_sum\n    if len(s) == 1:\n        return num\n    return max_sum\n[DONE]"}
{"idx": 138, "completion": "def longest_subseq_with_diff_one(arr, n):\n    dp = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if (arr[i] == arr[j] + 1) or (arr[i] == arr[j] - 1):\n                dp[i] = max(dp[i], dp[j] + 1)\n    return max(dp)\n[DONE]"}
{"idx": 139, "completion": "def does_Contain_B(a, b, c):\n    if c == 0:\n        return a == b\n    if c > 0:\n        return b >= a and (b - a) % c == 0\n    else:\n        return b <= a and (a - b) % (-c) == 0\n[DONE]"}
{"idx": 140, "completion": "import math\ndef is_coprime(a, b):\n    return math.gcd(a, b) == 1\n[DONE]"}
{"idx": 141, "completion": "def merge_sort(arr):\n    if len(arr) > 1:\n        mid = len(arr) // 2\n        left = arr[:mid]\n        right = arr[mid:]\n\n        merge_sort(left)\n        merge_sort(right)\n\n        i = j = k = 0\n\n        while i < len(left) and j < len(right):\n            if left[i] < right[j]:\n                arr[k] = left[i]\n                i += 1\n            else:\n                arr[k] = right[j]\n                j += 1\n            k += 1\n\n        while i < len(left):\n            arr[k] = left[i]\n            i += 1\n            k += 1\n\n        while j < len(right):\n            arr[k] = right[j]\n            j += 1\n            k += 1\n    return arr\n[DONE]"}
{"idx": 142, "completion": "def parabola_vertex(a, b, c):\n    x = -b / (2 * a)\n    y = (4 * a * c - b**2) / (4 * a)\n    return (x, y)\n[DONE]"}
{"idx": 143, "completion": "def specified_element(lst, n):\n    res = [i[n] for i in lst]\n    return res\n[DONE]"}
{"idx": 144, "completion": "def even_bit_toggle_number(number):\n    mask = 0xAAAAAAAA  # Binary: 10101010101010101010101010101010 (32 bits)\n    return number ^ mask\n[DONE]"}
{"idx": 145, "completion": "def tuple_int_str(tuple1):\n    result = tuple(tuple(int(x) for x in t) for t in tuple1)\n    return result\n[DONE]"}
{"idx": 146, "completion": "def encode_list(s):\n    if not s:\n        return []\n    result = []\n    current = s[0]\n    count = 1\n    for item in s[1:]:\n        if item == current:\n            count += 1\n        else:\n            result.append([count, current])\n            current = item\n            count = 1\n    result.append([count, current])\n    return result\n[DONE]"}
{"idx": 147, "completion": "def min_Ops(arr, n, k):\n    if n == 0:\n        return 0\n    max_val = max(arr)\n    operations = 0\n    for num in arr:\n        if (max_val - num) % k != 0:\n            return -1\n        operations += (max_val - num) // k\n    return operations\n[DONE]"}
{"idx": 148, "completion": "def month_season(month, day):\n    if month in ('January', 'February', 'March'):\n        if month == 'March' and day >= 20:\n            return 'spring'\n        else:\n            return 'winter'\n    elif month in ('April', 'May', 'June'):\n        if month == 'June' and day >= 21:\n            return 'summer'\n        else:\n            return 'spring'\n    elif month in ('July', 'August', 'September'):\n        if month == 'September' and day >= 22:\n            return 'autumn'\n        else:\n            return 'summer'\n    else:\n        if month == 'December' and day >= 21:\n            return 'winter'\n        else:\n            return 'autumn'\n[DONE]"}
{"idx": 149, "completion": "def solution(a, b, n):\n    for x in range(0, n + 1):\n        for y in range(0, n + 1):\n            if (a * x) + (b * y) == n:\n                return ('x = ', x, ', y = ', y)\n    return 'No solution'\n[DONE]"}
{"idx": 150, "completion": "def remove_elements(list1, list2):\n    result = [x for x in list1 if x not in list2]\n    return result\n[DONE]"}
{"idx": 151, "completion": "def sum_series(n):\n    sum = 0\n    while n > 0:\n        sum += n\n        n -= 2\n    return sum\n[DONE]"}
{"idx": 152, "completion": "import math\ndef area_polygon(sides, length):\n    area = (sides * (length ** 2)) / (4 * math.tan(math.pi / sides))\n    return area\n[DONE]"}
{"idx": 153, "completion": "import math\ndef areEquivalent(a,b):\n    def sum_divisors(n):\n        if n == 1:\n            return 1\n        sum = 1\n        sqrt_n = math.isqrt(n)\n        for i in range(2, sqrt_n + 1):\n            if n % i == 0:\n                if i == n // i:\n                    sum += i\n                else:\n                    sum += i + n // i\n        return sum\n    return sum_divisors(a) == sum_divisors(b)\n[DONE]"}
{"idx": 154, "completion": "def count_char_position(str1):\n    count = 0\n    for i in range(len(str1)):\n        if ((i == ord(str1[i]) - ord('a')) or (i == ord(str1[i]) - ord('A'))):\n            count += 1\n    return count\n[DONE]"}
{"idx": 155, "completion": "def find_even_Pair(arr, n): \n    count = 0\n    for i in range(n - 1): \n        for j in range(i + 1, n): \n            if (arr[i] ^ arr[j]) % 2 == 0: \n                count += 1\n    return count \n[DONE]"}
{"idx": 156, "completion": "def next_Power_Of_2(n):\n    if n == 0:\n        return 1\n    power = 1\n    while power < n:\n        power *= 2\n    return power\n[DONE]"}
{"idx": 157, "completion": "def frequency(arr, num):\n    count = 0\n    for element in arr:\n        if element == num:\n            count += 1\n    return count\n[DONE]"}
{"idx": 158, "completion": "def get_pell(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            c = 2 * b + a\n            a, b = b, c\n        return b\n[DONE]"}
{"idx": 159, "completion": "def sum_range_list(list1, start, end):\n    sum_range = 0\n    for i in range(start, end+1):\n        sum_range += list1[i]\n    return sum_range\n[DONE]"}
{"idx": 160, "completion": "def perimeter_pentagon(a):\n    perimeter = 5 * a\n    return perimeter\n[DONE]"}
{"idx": 161, "completion": "def count_occurance(string):\n    count = 0\n    n = len(string)\n    for i in range(n - 2):\n        if string[i] == 's' and string[i+1] == 't' and string[i+2] == 'd':\n            count += 1\n    return count\n[DONE]"}
{"idx": 162, "completion": "import re\ndef remove_splchar(string):\n    pattern = r'[^a-zA-Z0-9]'\n    return re.sub(pattern, '', string)\n[DONE]"}
{"idx": 163, "completion": "def group_keyvalue(test_list):\n    res = {}\n    for key, val in test_list:\n        res.setdefault(key, []).append(val)\n    return res\n[DONE]"}
{"idx": 164, "completion": "def is_valid_parenthese(str1):\n    stack = []\n    pchar = {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\n    for parenthese in str1:\n        if parenthese in pchar:\n            stack.append(parenthese)\n        elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\n            return False\n    return len(stack) == 0\n[DONE]"}
{"idx": 165, "completion": "def perimeter_triangle(a, b, c):\n    perimeter = a + b + c\n    return perimeter\n[DONE]"}
{"idx": 166, "completion": "import math\n\ndef answer(l, r):\n    for a in range(l, r + 1):\n        for b in range(a + 1, r + 1):\n            lcm = (a * b) // math.gcd(a, b)\n            if l <= lcm <= r:\n                return (a, b)\n    return (l, l + 1)\n[DONE]"}
{"idx": 167, "completion": "def string_literals(literals, string):\n    for literal in literals:\n        if literal in string:\n            return \"Matched!\"\n    return \"Not Matched!\"\n[DONE]"}
{"idx": 168, "completion": "def is_num_keith(n):\n    if n < 10:\n        return False\n    digits = [int(d) for d in str(n)]\n    length = len(digits)\n    sequence = digits.copy()\n    while sequence[-1] < n:\n        next_num = sum(sequence[-length:])\n        sequence.append(next_num)\n    return sequence[-1] == n\n[DONE]"}
{"idx": 169, "completion": "import math\ndef distance_lat_long(lat1, lon1, lat2, lon2):\n    lat1_rad = math.radians(lat1)\n    lon1_rad = math.radians(lon1)\n    lat2_rad = math.radians(lat2)\n    lon2_rad = math.radians(lon2)\n    dlat = lat2_rad - lat1_rad\n    dlon = lon2_rad - lon1_rad\n    a = math.sin(dlat / 2)**2 + math.cos(lat1_rad) * math.cos(lat2_rad) * math.sin(dlon / 2)**2\n    c = 2 * math.atan2(math.sqrt(a), math.sqrt(1 - a))\n    R = 6371.0\n    distance = R * c * 1000\n    return distance\n[DONE]"}
{"idx": 170, "completion": "def common_prefix(arr, n):\n    if not arr:\n        return \"\"\n    min_len = min(len(s) for s in arr)\n    prefix = \"\"\n    for i in range(min_len):\n        char = arr[0][i]\n        for s in arr[1:]:\n            if s[i] != char:\n                return prefix\n        prefix += char\n    return prefix\n[DONE]"}
{"idx": 171, "completion": "import re\ndef find_character(test_str):\n    up_char = re.findall(r'[A-Z]', test_str)\n    low_char = re.findall(r'[a-z]', test_str)\n    num_char = re.findall(r'[0-9]', test_str)\n    special_char = re.findall(r'[^A-Za-z0-9]', test_str)\n    return (up_char, low_char, num_char, special_char)\n[DONE]"}
{"idx": 172, "completion": "def count_pairs(arr, n, k):\n    count = 0\n    arr = list(set(arr))\n    arr.sort()\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[j] - arr[i] == k:\n                count += 1\n    return count\n[DONE]"}
{"idx": 173, "completion": "def greater_specificnum(nums, x):\n    for num in nums:\n        if num > x:\n            return True\n    return False\n[DONE]"}
{"idx": 174, "completion": "def parabola_focus(a, b, c):\n    x = -b / (2 * a)\n    y = (4 * a * c - b**2) / (4 * a)\n    return (x, y)\n[DONE]"}
{"idx": 175, "completion": "import re\ndef check_literals(text, patterns):\n    for pattern in patterns:\n        if re.search(pattern, text):\n            return 'Matched!'\n    return 'Not Matched!'\n[DONE]"}
{"idx": 176, "completion": "def longest_common_subsequence(s1, s2, m, n):\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1] + 1\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[m][n]\n[DONE]"}
{"idx": 177, "completion": "import math\n\ndef prod_Square(n):\n    for i in range(1, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            j = n // i\n            if (math.sqrt(i) == int(math.sqrt(i))) and (math.sqrt(j) == int(math.sqrt(j))):\n                return True\n    return False\n[DONE]"}
{"idx": 178, "completion": "def first_Missing_Positive(nums, n):\n    for i in range(n):\n        while 1 <= nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n            nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n    for i in range(n):\n        if nums[i] != i + 1:\n            return i + 1\n    return n + 1\n[DONE]"}
{"idx": 179, "completion": "def count_Intgral_Points(x1, y1, x2, y2):\n    return (abs(x2 - x1) - 1) * (abs(y2 - y1) - 1)\n[DONE]"}
{"idx": 180, "completion": "def check_monthnumber(month):\n    thirty_days_months = [\"April\", \"June\", \"September\", \"November\"]\n    return month in thirty_days_months\n[DONE]"}
{"idx": 181, "completion": "def check_String(test_str):\n    letter_flag = False\n    number_flag = False\n    for i in test_str:\n        if i.isalpha():\n            letter_flag = True\n        if i.isdigit():\n            number_flag = True\n    return letter_flag and number_flag\n[DONE]"}
{"idx": 182, "completion": "def remove_tuple(test_tup):\n    seen = set()\n    res = []\n    for t in test_tup:\n        if t not in seen:\n            seen.add(t)\n            res.append(t)\n    return tuple(res)\n[DONE]"}
{"idx": 183, "completion": "def octal_To_Decimal(n):\n    return int(str(n), 8)\n[DONE]"}
{"idx": 184, "completion": "def first(arr, low, high, x, n):\n    if high >= low:\n        mid = (low + high) // 2\n        if (mid == 0 or x > arr[mid - 1]) and arr[mid] == x:\n            return mid\n        elif x > arr[mid]:\n            return first(arr, (mid + 1), high, x, n)\n        else:\n            return first(arr, low, (mid - 1), x, n)\n    return -1\n\ndef first(arr, x, n):\n    return first(arr, 0, n - 1, x, n)\n[DONE]"}
{"idx": 185, "completion": "def remove_tuples(test_list, K):\n    res = [ele for ele in test_list if len(ele) != K]\n    return res\n[DONE]"}
{"idx": 186, "completion": "def find_exponentio(test_tup1, test_tup2):\n    res = tuple(pow(a, b) for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 187, "completion": "import math\ndef largest_triangle(a, b):\n    area = (3 * math.sqrt(3) * a * b) / 4\n    return area\n[DONE]"}
{"idx": 188, "completion": "import math\ndef highest_Power_of_2(n):\n    power = int(math.log2(n))\n    return 2 ** power\n[DONE]"}
{"idx": 189, "completion": "def position_max(nums):\n    max_val = max(nums)\n    positions = [i for i, num in enumerate(nums) if num == max_val]\n    return positions\n[DONE]"}
{"idx": 190, "completion": "def chkList(lst):\n    return all(x == lst[0] for x in lst)\n[DONE]"}
{"idx": 191, "completion": "def remove_even(test_str):\n    res = \"\"\n    for i in range(len(test_str)):\n        if i % 2 == 0:\n            res += test_str[i]\n    return res\n[DONE]"}
{"idx": 192, "completion": "def hamming_Distance(x, y):\n    return bin(x ^ y).count('1')\n[DONE]"}
{"idx": 193, "completion": "def count(str1, char):\n    return str1.count(char)\n[DONE]"}
{"idx": 194, "completion": "def inversion_elements(test_tup):\n    res = tuple(-x - 1 for x in test_tup)\n    return res\n[DONE]"}
{"idx": 195, "completion": "def concatenate_elements(test_tup):\n    res = tuple(test_tup[i] + test_tup[i + 1] for i in range(len(test_tup) - 1))\n    return res\n[DONE]"}
{"idx": 196, "completion": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if s[i - 1] == s[j - 1] and i != j:\n                dp[i][j] = 1 + dp[i - 1][j - 1]\n            else:\n                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n    return dp[n][n]\n[DONE]"}
{"idx": 197, "completion": "import re\ndef is_decimal(num):\n    pattern = re.compile(r'^\\d+\\.\\d{2}$')\n    return bool(pattern.match(num))\n[DONE]"}
{"idx": 198, "completion": "import heapq\ndef heap_replace(heap, item):\n    heapq.heapreplace(heap, item)\n    return heap\n[DONE]"}
{"idx": 199, "completion": "import re\ndef is_allowed_specific_char(string):\n    pattern = re.compile(r'[^a-zA-Z0-9]')\n    if pattern.search(string):\n        return False\n    else:\n        return True\n[DONE]"}
{"idx": 200, "completion": "def count_Num(n):\n    count = 0\n    for num in range(1, 2**n):\n        if (num & 1) and (num & (1 << (n-1))):\n            count += 1\n    return count\n[DONE]"}
{"idx": 201, "completion": "def fourth_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**4\n    return sum\n[DONE]"}
{"idx": 202, "completion": "def concatenate_strings(test_tup1, test_tup2):\n    res = tuple(a + b for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 203, "completion": "import math\ndef degree_radian(num):\n    return num * (180/math.pi)\n[DONE]"}
{"idx": 204, "completion": "def decode_list(lst):\n    decoded = []\n    for element in lst:\n        if isinstance(element, list):\n            count, value = element\n            decoded.extend([value] * count)\n        else:\n            decoded.append(element)\n    return decoded\n[DONE]"}
{"idx": 205, "completion": "def check_subset_list(test_list, sub_list):\n    for lst in sub_list:\n        if lst not in test_list:\n            return False\n    return True\n[DONE]"}
{"idx": 206, "completion": "def first_Repeated_Char(str1):\n    seen = set()\n    for char in str1:\n        if char in seen:\n            return char\n        seen.add(char)\n    return '\\0'\n[DONE]"}
{"idx": 207, "completion": "def min_Operations(x, y):\n    count = 0\n    while x != y:\n        if x > y:\n            x -= 1\n        else:\n            y -= 1\n        count += 1\n    return count\n[DONE]"}
{"idx": 208, "completion": "def extract_min_max(test_tup, k):\n    sorted_tup = sorted(test_tup)\n    min_k = tuple(sorted_tup[:k])\n    max_k = tuple(sorted_tup[-k:])\n    result = min_k + max_k\n    return result\n[DONE]"}
{"idx": 209, "completion": "import re\ndef replace_max_specialchar(string, n):\n    pattern = r'[ ,.]'\n    count = 0\n    result = []\n    for char in string:\n        if re.match(pattern, char):\n            if count < n:\n                result.append(':')\n                count += 1\n            else:\n                result.append(char)\n        else:\n            result.append(char)\n    return ''.join(result)\n[DONE]"}
{"idx": 210, "completion": "def first_even(lst):\n    for num in lst:\n        if num % 2 == 0:\n            return num\n    return None\n[DONE]"}
{"idx": 211, "completion": "def check_type(test_tup):\n    if len(test_tup) == 0:\n        return True\n    first_type = type(test_tup[0])\n    for element in test_tup[1:]:\n        if type(element) != first_type:\n            return False\n    return True\n[DONE]"}
{"idx": 212, "completion": "def is_majority(arr, n, x):\n    count = 0\n    for num in arr:\n        if num == x:\n            count += 1\n    return count > n // 2\n[DONE]"}
{"idx": 213, "completion": "def count_Set_Bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n[DONE]"}
{"idx": 214, "completion": "def find_Min(arr, low, high):\n    if high < low:\n        return arr[0]\n    if high == low:\n        return arr[low]\n    mid = (low + high) // 2\n    if mid < high and arr[mid+1] < arr[mid]:\n        return arr[mid+1]\n    if mid > low and arr[mid] < arr[mid - 1]:\n        return arr[mid]\n    if arr[high] > arr[mid]:\n        return find_Min(arr, low, mid-1)\n    return find_Min(arr, mid+1, high)\n[DONE]"}
{"idx": 215, "completion": "def odd_values_string(str):\n    result = \"\"\n    for i in range(len(str)):\n        if i % 2 == 0:\n            result = result + str[i]\n    return result\n[DONE]"}
{"idx": 216, "completion": "def min_of_three(x,y,z):\n    if x < y and x < z:\n        return x\n    elif y < x and y < z:\n        return y\n    else:\n        return z\n[DONE]"}
{"idx": 217, "completion": "def all_Bits_Set_In_The_Given_Range(n, l, r):\n    mask = (1 << (r - l + 1)) - 1\n    mask <<= (l - 1)\n    return (n & mask) == 0\n[DONE]"}
{"idx": 218, "completion": "def re_arrange_array(arr, n):\n    j = 0\n    for i in range(n):\n        if arr[i] < 0:\n            arr[i], arr[j] = arr[j], arr[i]\n            j += 1\n    return arr\n[DONE]"}
{"idx": 219, "completion": "def replace_blank(string, char):\n    return string.replace(' ', char)\n[DONE]"}
{"idx": 220, "completion": "def max_sum(triangle, size):\n    for i in range(size - 2, -1, -1):\n        for j in range(len(triangle[i])):\n            triangle[i][j] += max(triangle[i + 1][j], triangle[i + 1][j + 1])\n    return triangle[0][0]\n[DONE]"}
{"idx": 221, "completion": "def larg_nnum(list1, n):\n    list1.sort()\n    list1 = list1[-n:]\n    list1.reverse()\n    return list1\n[DONE]"}
{"idx": 222, "completion": "import math\ndef lateralsuface_cylinder(r, h):\n    return 2 * math.pi * r * h\n[DONE]"}
{"idx": 223, "completion": "def volume_cube(side):\n    return side ** 3\n[DONE]"}
{"idx": 224, "completion": "def even_bit_set_number(number):\n    mask = 0xAAAAAAAA  # Binary: 10101010101010101010101010101010\n    result = number | mask\n    return result\n[DONE]"}
{"idx": 225, "completion": "def No_of_Triangle(N, K):\n    if K > N:\n        return -1\n    return (N - K + 1) * (N - K + 2) // 2\n[DONE]"}
{"idx": 226, "completion": "def check_occurences(test_list):\n    freq_dict = {}\n    for tup in test_list:\n        sorted_tup = tuple(sorted(tup))\n        if sorted_tup in freq_dict:\n            freq_dict[sorted_tup] += 1\n        else:\n            freq_dict[sorted_tup] = 1\n    result = {}\n    for tup in test_list:\n        sorted_tup = tuple(sorted(tup))\n        if freq_dict[sorted_tup] > 1:\n            result[sorted_tup] = freq_dict[sorted_tup]\n        else:\n            result[sorted_tup] = 1\n    return result\n[DONE]"}
{"idx": 227, "completion": "def number_of_substrings(str):\n    n = len(str)\n    return int(n * (n + 1) / 2)\n[DONE]"}
{"idx": 228, "completion": "def get_total_number_of_sequences(m, n):\n    if n == 1:\n        return m\n    count = 0\n    for i in range(1, m//(2**(n-1)) + 1):\n        count += get_total_number_of_sequences(m, n-1)\n    return count\n[DONE]"}
{"idx": 229, "completion": "def replace_list(list1, list2):\n    list1[-1:] = list2\n    return list1\n[DONE]"}
{"idx": 230, "completion": "def array_3d(x, y, z):\n    array = [[['*' for _ in range(x)] for _ in range(y)] for _ in range(z)]\n    return array\n[DONE]"}
{"idx": 231, "completion": "def count_charac(string):\n    count=0\n    for i in string:\n        count+=1\n    return count\n[DONE]"}
{"idx": 232, "completion": "from collections import defaultdict\n\ndef sort_on_occurence(lst):\n    d = defaultdict(list)\n    for key, val in lst:\n        d[key].append(val)\n    \n    result = []\n    for key in d:\n        vals = d[key]\n        count = len(vals)\n        if count > 1:\n            entry = (key,) + tuple(vals) + (count,)\n        else:\n            entry = (key, vals[0], count)\n        result.append(entry)\n    \n    return result\n[DONE]"}
{"idx": 233, "completion": "import math\ndef next_Perfect_Square(N):\n    nextN = math.floor(math.sqrt(N)) + 1\n    return nextN * nextN\n[DONE]"}
{"idx": 234, "completion": "def max_sum(arr, n):\n    # Create two arrays to store the increasing and decreasing sequences\n    inc = [0] * n\n    dec = [0] * n\n    \n    # Initialize both arrays with the values of the original array\n    for i in range(n):\n        inc[i] = arr[i]\n        dec[i] = arr[i]\n    \n    # Compute the longest increasing subsequence from left to right\n    for i in range(1, n):\n        for j in range(i):\n            if arr[i] > arr[j] and inc[i] < inc[j] + arr[i]:\n                inc[i] = inc[j] + arr[i]\n    \n    # Compute the longest decreasing subsequence from right to left\n    for i in range(n-2, -1, -1):\n        for j in range(n-1, i, -1):\n            if arr[i] > arr[j] and dec[i] < dec[j] + arr[i]:\n                dec[i] = dec[j] + arr[i]\n    \n    # Find the maximum value of inc[i] + dec[i] - arr[i]\n    max_sum = 0\n    for i in range(n):\n        if inc[i] + dec[i] - arr[i] > max_sum:\n            max_sum = inc[i] + dec[i] - arr[i]\n    \n    return max_sum\n[DONE]"}
{"idx": 235, "completion": "def babylonian_squareroot(number):\n    if number == 0:\n        return 0\n    guess = number / 2.0\n    while True:\n        new_guess = (guess + number / guess) / 2.0\n        if abs(new_guess - guess) < 1e-10:\n            break\n        guess = new_guess\n    return new_guess\n[DONE]"}
{"idx": 236, "completion": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n - 1, -1, -1):\n        dp[i][i] = 1\n        for j in range(i + 1, n):\n            if s[i] == s[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n    return dp[0][n - 1]\n[DONE]"}
{"idx": 237, "completion": "def harmonic_sum(n):\n    total = 0.0\n    for i in range(1, n):\n        total += 1 / i\n    return total\n[DONE]"}
{"idx": 238, "completion": "def intersection_array(arr1, arr2):\n    result = list(filter(lambda x: x in arr1, arr2))\n    return result\n[DONE]"}
{"idx": 239, "completion": "def count_X(tup, X):\n    count = 0\n    for elem in tup:\n        if elem == X:\n            count += 1\n    return count\n[DONE]"}
{"idx": 240, "completion": "def insert_element(lst, element):\n    new_list = []\n    for item in lst:\n        new_list.append(element)\n        new_list.append(item)\n    return new_list\n[DONE]"}
{"idx": 241, "completion": "import cmath\ndef convert(n):\n    cn = complex(n,0)\n    polar = cmath.polar(cn)\n    return polar\n[DONE]"}
{"idx": 242, "completion": "def count_integer(list1):\n    count = 0\n    for element in list1:\n        if isinstance(element, int) and not isinstance(element, bool):\n            count += 1\n    return count\n[DONE]"}
{"idx": 243, "completion": "def words_ae(string):\n    words = string.split()\n    result = []\n    for word in words:\n        if word[0].lower() == 'a' or word[0].lower() == 'e':\n            result.append(word)\n    return result\n[DONE]"}
{"idx": 244, "completion": "from itertools import combinations_with_replacement\n\ndef combinations_colors(colors, r):\n    return list(combinations_with_replacement(colors, r))\n[DONE]"}
{"idx": 245, "completion": "def count_Primes_nums(n):\n    if n < 2:\n        return 0\n    sieve = [True] * n\n    sieve[0] = sieve[1] = False\n    for i in range(2, int(n ** 0.5) + 1):\n        if sieve[i]:\n            sieve[i*i : n : i] = [False] * len(sieve[i*i : n : i])\n    return sum(sieve)\n[DONE]"}
{"idx": 246, "completion": "def swap_numbers(x, y):\n    x, y = y, x\n    return (x, y)\n[DONE]"}
{"idx": 247, "completion": "def count_odd(nums):\n    count_odd = len(list(filter(lambda x: (x%2 != 0) , nums)))\n    return count_odd\n[DONE]"}
{"idx": 248, "completion": "def maximize_elements(test_tup1, test_tup2):\n    res = tuple(tuple(max(a, b) for a, b in zip(t1, t2)) for t1, t2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 249, "completion": "def newman_prime(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    a, b = 1, 1\n    for _ in range(2, n+1):\n        c = 2 * (a + b)\n        a = b\n        b = c\n    return b\n[DONE]"}
{"idx": 250, "completion": "def division_elements(test_tup1, test_tup2):\n    res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 251, "completion": "def split_two_parts(lst, n):\n    return (lst[:n], lst[n:])\n[DONE]"}
{"idx": 252, "completion": "def merge_dict(dict1, dict2):\n    res = {**dict1, **dict2}\n    return res\n[DONE]"}
{"idx": 253, "completion": "def dog_age(age):\n    dog_age = 21 + (age - 2) * 4\n    return dog_age\n[DONE]"}
{"idx": 254, "completion": "def list_split(lst, n):\n    result = []\n    for i in range(n):\n        result.append(lst[i::n])\n    return result\n[DONE]"}
{"idx": 255, "completion": "def lateralsurface_cube(l):\n    return 4 * (l ** 2)\n[DONE]"}
{"idx": 256, "completion": "def square_Sum(n):\n    sum_squares = 0\n    for i in range(1, 2 * n, 2):\n        sum_squares += i ** 2\n    return sum_squares\n[DONE]"}
{"idx": 257, "completion": "def find_star_num(n):\n    return 6 * n * (n - 1) + 1\n[DONE]"}
{"idx": 258, "completion": "def ascii_value(char):\n    return ord(char)\n[DONE]"}
{"idx": 259, "completion": "def sum_even_and_even_index(arr, n):\n    sum_even = 0\n    for i in range(0, n, 2):\n        if arr[i] % 2 == 0:\n            sum_even += arr[i]\n    return sum_even\n[DONE]"}
{"idx": 260, "completion": "def even_Power_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 5\n    return sum\n[DONE]"}
{"idx": 261, "completion": "def rear_extract(lst):\n    return [t[-1] for t in lst]\n[DONE]"}
{"idx": 262, "completion": "def substract_elements(test_tup1, test_tup2):\n    res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 263, "completion": "def even_binomial_Coeff_Sum(n):\n    return 2 ** (n - 1)\n[DONE]"}
{"idx": 264, "completion": "def get_Position(arr, n, k):\n    for i in range(n):\n        if arr[i] == k:\n            return i + 1\n    return -1\n[DONE]"}
{"idx": 265, "completion": "import math\ndef volume_cylinder(r,h):\n    volume = math.pi * r * r * h\n    return volume\n[DONE]"}
{"idx": 266, "completion": "def dict_filter(dict1, n):\n    new_dict = {}\n    for key, value in dict1.items():\n        if value >= n:\n            new_dict[key] = value\n    return new_dict\n[DONE]"}
{"idx": 267, "completion": "def count_first_elements(test_tup):\n    count = 0\n    for element in test_tup:\n        if isinstance(element, tuple):\n            break\n        count += 1\n    return count\n[DONE]"}
{"idx": 268, "completion": "def is_num_decagonal(n): \n    return 4 * n * n - 3 * n \n[DONE]"}
{"idx": 269, "completion": "def sequential_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return (True, i)\n    return (False, -1)\n[DONE]"}
{"idx": 270, "completion": "def all_unique(test_list):\n    return len(test_list) == len(set(test_list))\n[DONE]"}
{"idx": 271, "completion": "def sub_list(nums1, nums2):\n    result = list(map(lambda x, y: x - y, nums1, nums2))\n    return result\n[DONE]"}
{"idx": 272, "completion": "def validate(num):\n    num_str = str(num)\n    for digit in num_str:\n        count = num_str.count(digit)\n        if count > int(digit):\n            return False\n    return True\n[DONE]"}
{"idx": 273, "completion": "def check_element(lst, element):\n    return all(x == element for x in lst)\n[DONE]"}
{"idx": 274, "completion": "import re\ndef text_match_two_three(text):\n    if re.search(r'ab{2,3}', text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 275, "completion": "def max_sub_array_sum_repeated(a, n, k):\n    max_kadane = kadane(a)\n    max_wrap = 0\n    if k == 1:\n        return max_kadane\n    total_sum = sum(a)\n    for i in range(n):\n        max_wrap += a[i]\n        a[i] = -a[i]\n    max_wrap = max_wrap + kadane(a)\n    if max_wrap == 0:\n        return max_kadane\n    if total_sum > 0:\n        return max(max_kadane, total_sum * k - max_wrap)\n    else:\n        return max(max_kadane, max_wrap)\n\ndef kadane(a):\n    n = len(a)\n    max_so_far = -float('inf')\n    max_ending_here = 0\n    for i in range(n):\n        max_ending_here = max_ending_here + a[i]\n        if max_so_far < max_ending_here:\n            max_so_far = max_ending_here\n        if max_ending_here < 0:\n            max_ending_here = 0\n    return max_so_far\n[DONE]"}
{"idx": 276, "completion": "def square_Sum(n):\n    sum_squares = 0\n    for i in range(1, n+1):\n        sum_squares += (2 * i) ** 2\n    return sum_squares\n[DONE]"}
{"idx": 277, "completion": "def modular_inverse(arr, n, p):\n    count = 0\n    for num in arr:\n        if (num * num) % p == 1:\n            count += 1\n    return count\n[DONE]"}
{"idx": 278, "completion": "def odd_Days(year):\n    leap_years = year // 4\n    leap_years -= year // 100\n    leap_years += year // 400\n    total_days = (year * 365) + leap_years\n    odd_days = total_days % 7\n    return odd_days\n[DONE]"}
{"idx": 279, "completion": "def max_length(list1):\n    max_len = max(len(x) for x in list1)\n    max_list = next(x for x in list1 if len(x) == max_len)\n    return (max_len, max_list)\n[DONE]"}
{"idx": 280, "completion": "def count_no_of_ways(n, k):\n    if n == 0:\n        return 0\n    if n == 1:\n        return k\n    same = k\n    diff = k * (k - 1)\n    for i in range(3, n + 1):\n        same, diff = diff, (same + diff) * (k - 1)\n    return same + diff\n[DONE]"}
{"idx": 281, "completion": "def find(a, b):\n    return a // b\n[DONE]"}
{"idx": 282, "completion": "import math\ndef otherside_rightangle(a, b):\n    c = math.sqrt(a**2 + b**2)\n    return c\n[DONE]"}
{"idx": 283, "completion": "def max_val(list_val):\n    max_val = 0\n    for element in list_val:\n        if isinstance(element, int):\n            if element > max_val:\n                max_val = element\n    return max_val\n[DONE]"}
{"idx": 284, "completion": "def sum_div(number):\n    sum = 0\n    for i in range(1, number):\n        if number % i == 0:\n            sum += i\n    return sum\n[DONE]"}
{"idx": 285, "completion": "def get_Inv_Count(arr, n):\n    inv_count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            if (arr[i] > arr[j]):\n                inv_count += 1\n    return inv_count\n[DONE]"}
{"idx": 286, "completion": "def flatten_list(n_list):\n    result = []\n    for element in n_list:\n        if isinstance(element, list):\n            result.extend(flatten_list(element))\n        else:\n            result.append(element)\n    return result\n[DONE]"}
{"idx": 287, "completion": "def intersection_nested_lists(lst1, lst2):\n    result = []\n    for sublist in lst2:\n        intersection = [elem for elem in sublist if elem in lst1]\n        result.append(intersection)\n    return result\n[DONE]"}
{"idx": 288, "completion": "def max_aggregate(students):\n    aggregate = {}\n    for name, score in students:\n        if name in aggregate:\n            aggregate[name] += score\n        else:\n            aggregate[name] = score\n    max_name = max(aggregate.items(), key=lambda x: x[1])\n    return max_name\n[DONE]"}
{"idx": 289, "completion": "import math\ndef count_binary_seq(n):\n    total = 0\n    for k in range(0, n+1):\n        c = math.comb(n, k)\n        total += c * c\n    return total\n[DONE]"}
{"idx": 290, "completion": "def dict_depth(d, depth=1):\n    if not isinstance(d, dict) or not d:\n        return depth\n    return max(dict_depth(v, depth + 1) for k, v in d.items())\n[DONE]"}
{"idx": 291, "completion": "def set_Bit_Number(n):\n    if n == 0:\n        return 0\n    msb = 1\n    while (msb * 2) <= n:\n        msb *= 2\n    return msb\n[DONE]"}
{"idx": 292, "completion": "def solve(arr, n):\n    count1 = 0\n    count0 = 0\n    for i in range(n):\n        if arr[i] == 1:\n            count1 += 1\n        elif arr[i] == 0:\n            count0 += 1\n    return count1 == count0\n[DONE]"}
{"idx": 293, "completion": "def find_Element(arr, ranges, rotations, index):\n    for i in range(rotations):\n        left, right = ranges[i % len(ranges)]\n        arr = arr[left:right+1] + arr[:left] + arr[right+1:]\n    return arr[index]\n[DONE]"}
{"idx": 294, "completion": "def start_withp(words):\n    p_words = []\n    for word in words:\n        for w in word.split():\n            if w.startswith('P') or w.startswith('p'):\n                p_words.append(w)\n    return (p_words[0], p_words[1])\n[DONE]"}
{"idx": 295, "completion": "def max_sum_increasing_subseq(arr, n, i, k):\n    # Create a list to store the maximum sum of increasing subsequence ending at each index\n    max_sum = [0] * n\n    max_sum[0] = arr[0]\n    \n    # Compute the maximum sum of increasing subsequence for each index up to i\n    for j in range(1, i + 1):\n        max_sum[j] = arr[j]\n        for l in range(j):\n            if arr[l] < arr[j] and max_sum[l] + arr[j] > max_sum[j]:\n                max_sum[j] = max_sum[l] + arr[j]\n    \n    # Now, include the k-th element (k > i)\n    # The maximum sum up to k is the maximum sum up to i plus the k-th element if arr[i] < arr[k]\n    # But we need to consider all possible elements before k that are less than arr[k]\n    # So, we need to recompute the max_sum for k, considering elements from 0 to k-1\n    \n    # Re-initialize max_sum for k-th element\n    max_sum_k = arr[k]\n    for j in range(k):\n        if arr[j] < arr[k] and max_sum[j] + arr[k] > max_sum_k:\n            max_sum_k = max_sum[j] + arr[k]\n    \n    return max_sum_k\n[DONE]"}
{"idx": 296, "completion": "def colon_tuplex(tuplex, i, val):\n    if i < 0 or i >= len(tuplex):\n        return tuplex\n    new_list = list(tuplex)\n    new_list[i] = [val]\n    return tuple(new_list)\n[DONE]"}
{"idx": 297, "completion": "def large_product(arr1, arr2, N):\n    products = []\n    for num1 in arr1:\n        for num2 in arr2:\n            products.append(num1 * num2)\n    products = sorted(products, reverse=True)\n    return products[:N]\n[DONE]"}
{"idx": 298, "completion": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n[DONE]"}
{"idx": 299, "completion": "def string_to_tuple(str):\n    return tuple(str)\n[DONE]"}
{"idx": 300, "completion": "def set_left_most_unset_bit(n):\n    if n == 0:\n        return 1\n    unset_bit = ~n\n    if unset_bit == 0:\n        return n\n    left_most_unset_bit = (unset_bit & -unset_bit)\n    return n | left_most_unset_bit\n[DONE]"}
{"idx": 301, "completion": "import math\ndef volume_cone(r, h):\n    return (1.0/3) * math.pi * r * r * h\n[DONE]"}
{"idx": 302, "completion": "def pos_nos(list1):\n    for i in list1:\n        if i > 0:\n            print(i, end=\",\")\n    return\n[DONE]"}
{"idx": 303, "completion": "def max_sum_rectangular_grid(grid, n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return max(grid[0][0], grid[1][0])\n    \n    # Initialize dp arrays for each row\n    dp0 = [0] * n\n    dp1 = [0] * n\n    \n    dp0[0] = grid[0][0]\n    dp1[0] = grid[1][0]\n    \n    if n > 1:\n        dp0[1] = max(grid[0][1], dp1[0] + grid[0][1])\n        dp1[1] = max(grid[1][1], dp0[0] + grid[1][1])\n    \n    for i in range(2, n):\n        # For the first row, the previous step could be from the second row's i-1 or i-2\n        dp0[i] = max(dp1[i-1], dp1[i-2]) + grid[0][i]\n        # For the second row, the previous step could be from the first row's i-1 or i-2\n        dp1[i] = max(dp0[i-1], dp0[i-2]) + grid[1][i]\n    \n    return max(dp0[-1], dp1[-1])\n[DONE]"}
{"idx": 304, "completion": "def find_Max_Len_Even(test_str):\n    words = test_str.split()\n    max_len = 0\n    max_word = \"-1\"\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n            max_word = word\n    return max_word\n[DONE]"}
{"idx": 305, "completion": "def find_last_occurrence(nums, target):\n    left, right = 0, len(nums) - 1\n    result = -1\n    while left <= right:\n        mid = (left + right) // 2\n        if nums[mid] == target:\n            result = mid\n            left = mid + 1\n        elif nums[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return result\n[DONE]"}
{"idx": 306, "completion": "from itertools import groupby\ndef modified_encode(lst):\n    def run_length_encoding(lst):\n        return [[len(list(group)), key] for key, group in groupby(lst)]\n    rle = run_length_encoding(lst)\n    result = []\n    for group in rle:\n        if group[0] == 1:\n            result.append(group[1])\n        else:\n            result.append([group[0], group[1]])\n    return result\n[DONE]"}
{"idx": 307, "completion": "def max_volume(s):\n    max_vol = 0\n    for a in range(1, s//3 + 1):\n        for b in range(a, (s - a)//2 + 1):\n            c = s - a - b\n            vol = a * b * c\n            if vol > max_vol:\n                max_vol = vol\n    return max_vol\n[DONE]"}
{"idx": 308, "completion": "import re\ndef find_long_word(test):\n    res = re.findall(r'\\b\\w{5}\\b', test)\n    return res\n[DONE]"}
{"idx": 309, "completion": "def sum_difference(n):\n    sum_of_squares = 0\n    square_of_sum = 0\n    for i in range(1, n+1):\n        sum_of_squares += i**2\n        square_of_sum += i\n    square_of_sum = square_of_sum**2\n    return square_of_sum - sum_of_squares\n[DONE]"}
{"idx": 310, "completion": "def find_demlo(n):\n    s = str(n)\n    length = len(s)\n    demlo = ''.join([str(i) for i in range(1, length + 1)]) + ''.join([str(i) for i in range(length - 1, 0, -1)])\n    return demlo\n[DONE]"}
{"idx": 311, "completion": "def position_min(lst):\n    min_val = min(lst)\n    return [i for i, x in enumerate(lst) if x == min_val]\n[DONE]"}
{"idx": 312, "completion": "def re_arrange(arr, n):\n    # Separate positive and negative numbers\n    pos = [x for x in arr if x >= 0]\n    neg = [x for x in arr if x < 0]\n    \n    # Initialize the result list\n    result = []\n    i = j = k = 0\n    \n    # Merge the two lists in alternating fashion\n    while i < len(neg) and j < len(pos):\n        result.append(neg[i])\n        result.append(pos[j])\n        i += 1\n        j += 1\n    \n    # Add remaining negative numbers\n    while i < len(neg):\n        result.append(neg[i])\n        i += 1\n    \n    # Add remaining positive numbers\n    while j < len(pos):\n        result.append(pos[j])\n        j += 1\n    \n    return result\n[DONE]"}
{"idx": 313, "completion": "def sum_of_alternates(test_tup):\n    sum1 = 0\n    sum2 = 0\n    for i in range(len(test_tup)):\n        if i % 2 == 0:\n            sum1 += test_tup[i]\n        else:\n            sum2 += test_tup[i]\n    return (sum1, sum2)\n[DONE]"}
{"idx": 314, "completion": "import math\ndef get_Min_Squares(n):\n    if n <= 3:\n        return n\n    res = n\n    for x in range(1, n + 1):\n        temp = x * x\n        if temp > n:\n            break\n        else:\n            res = min(res, 1 + get_Min_Squares(n - temp))\n    return res\n[DONE]"}
{"idx": 315, "completion": "from collections import Counter\n\ndef most_occurrences(strings):\n    words = []\n    for s in strings:\n        words.extend(s.split())\n    word_counts = Counter(words)\n    most_common = word_counts.most_common(1)\n    return most_common[0][0]\n[DONE]"}
{"idx": 316, "completion": "def check_isosceles(x,y,z):\n    if x == y or y == z or x == z:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 317, "completion": "def rotate_left(nums, k, n):\n    return nums[k:k+n] + nums[:k] + nums[k+n:]\n[DONE]"}
{"idx": 318, "completion": "def neg_count(list1):\n    count = 0\n    for num in list1:\n        if num < 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 319, "completion": "import re\ndef find_char(string):\n    pattern = r'\\b\\w{3,5}\\b'\n    return re.findall(pattern, string)\n[DONE]"}
{"idx": 320, "completion": "def count_unset_bits(n):\n    binary = bin(n)[2:]\n    return binary.count('0')\n[DONE]"}
{"idx": 321, "completion": "def char_frequency(str1):\n    dict = {}\n    for n in str1:\n        keys = dict.keys()\n        if n in keys:\n            dict[n] += 1\n        else:\n            dict[n] = 1\n    return dict\n[DONE]"}
{"idx": 322, "completion": "def Sort(sub_li):\n    sub_li.sort(key=lambda x: x[1])\n    return sub_li\n[DONE]"}
{"idx": 323, "completion": "def check_Validity(a,b,c):\n    if (a + b <= c) or (a + c <= b) or (b + c <= a):\n        return False\n    else:\n        return True\n[DONE]"}
{"idx": 324, "completion": "def ap_sum(a1, an, n):\n    return n * (a1 + an) // 2\n[DONE]"}
{"idx": 325, "completion": "def check_monthnum(month):\n    return month == \"February\"\n[DONE]"}
{"idx": 326, "completion": "import re\ndef text_match_word(text):\n    pattern = r'\\bpython\\b[^\\w]*$'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 327, "completion": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    n = len(s)\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                count += 1\n    return count\n[DONE]"}
{"idx": 328, "completion": "def find_Divisor(x, y):\n    if x == y:\n        return x\n    else:\n        return 2\n[DONE]"}
{"idx": 329, "completion": "def sum_three_smallest_nums(lst):\n    positive_nums = [x for x in lst if x > 0]\n    positive_nums_sorted = sorted(positive_nums)\n    return sum(positive_nums_sorted[:3])\n[DONE]"}
{"idx": 330, "completion": "def set_to_tuple(input_set):\n    sorted_list = sorted(input_set)\n    return tuple(sorted_list)\n[DONE]"}
{"idx": 331, "completion": "import heapq\n\ndef find_minimum_range(lists):\n    min_heap = []\n    max_val = -float('inf')\n    range_start, range_end = -float('inf'), float('inf')\n    \n    # Initialize the heap with the first element of each list\n    for i, lst in enumerate(lists):\n        val = lst[0]\n        heapq.heappush(min_heap, (val, i, 0))\n        if val > max_val:\n            max_val = val\n    \n    # The initial range is from the smallest element to the max_val in the heap\n    current_range = max_val - min_heap[0][0]\n    range_start, range_end = min_heap[0][0], max_val\n    \n    while True:\n        # Extract the smallest element\n        min_val, list_idx, elem_idx = heapq.heappop(min_heap)\n        \n        # If we've reached the end of any list, break the loop\n        if elem_idx + 1 >= len(lists[list_idx]):\n            break\n        \n        # Get the next element from the same list\n        next_val = lists[list_idx][elem_idx + 1]\n        heapq.heappush(min_heap, (next_val, list_idx, elem_idx + 1))\n        \n        # Update the max_val if necessary\n        if next_val > max_val:\n            max_val = next_val\n        \n        # Check if the new range is smaller\n        new_min = min_heap[0][0]\n        new_range = max_val - new_min\n        if new_range < current_range:\n            current_range = new_range\n            range_start, range_end = new_min, max_val\n    \n    return (range_start, range_end)\n[DONE]"}
{"idx": 332, "completion": "def dig_let(string):\n    letters = 0\n    digits = 0\n    for char in string:\n        if char.isalpha():\n            letters += 1\n        elif char.isdigit():\n            digits += 1\n    return (letters, digits)\n[DONE]"}
{"idx": 333, "completion": "import math\ndef count_Odd_Squares(start, end):\n    count = 0\n    for num in range(start, end + 1):\n        sqrt_num = math.sqrt(num)\n        if sqrt_num.is_integer() and int(sqrt_num) % 2 != 0:\n            count += 1\n    return count\n[DONE]"}
{"idx": 334, "completion": "def diff_consecutivenums(nums):\n    res = []\n    for i in range(1, len(nums)):\n        res.append(nums[i] - nums[i-1])\n    return res\n[DONE]"}
{"idx": 335, "completion": "def zigzag(n, k):\n    if n == 0 and k == 0:\n        return 1\n    if k == 0:\n        return 0\n    if k == n:\n        return zigzag(n, n-1)\n    return zigzag(n, k-1) + zigzag(n-1, n-k)\n[DONE]"}
{"idx": 336, "completion": "def count_Squares(n, m):\n    count = 0\n    for i in range(1, min(n, m) + 1):\n        count += (n - i + 1) * (m - i + 1)\n    return count\n[DONE]"}
{"idx": 337, "completion": "def find_ways(n):\n    if n % 2 != 0:\n        return 0\n    n = n // 2\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(1, n + 1):\n        dp[i] = 0\n        for j in range(i):\n            dp[i] += dp[j] * dp[i - j - 1]\n    return dp[n]\n[DONE]"}
{"idx": 338, "completion": "def check(string):\n    p = set(string)\n    s = {'0', '1'}\n    if s == p or p == {'0'} or p == {'1'}:\n        return \"Yes\"\n    else:\n        return \"No\"\n[DONE]"}
{"idx": 339, "completion": "def minimum_Length(s):\n    if len(s) <= 1:\n        return len(s)\n    left = 0\n    right = len(s) - 1\n    while left < right and s[left] == s[right]:\n        char = s[left]\n        while left <= right and s[left] == char:\n            left += 1\n        while right >= left and s[right] == char:\n            right -= 1\n    return right - left + 1\n[DONE]"}
{"idx": 340, "completion": "def first_Element(arr, n, k):\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    for num in arr:\n        if freq[num] == k:\n            return num\n    return -1\n[DONE]"}
{"idx": 341, "completion": "def unique_Characters(str):\n    if len(str) == len(set(str)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 342, "completion": "def remove_column(list1, n):\n    for i in range(len(list1)):\n        list1[i].pop(n)\n    return list1\n[DONE]"}
{"idx": 343, "completion": "def tn_ap(a1, d, n):\n    return a1 + (n - 1) * d\n[DONE]"}
{"idx": 344, "completion": "def count_Rectangles(r):\n    count = 0\n    for a in range(1, 2 * r + 1):\n        for b in range(1, 2 * r + 1):\n            if (a * a + b * b) ** 0.5 <= 2 * r:\n                count += 1\n    return count\n[DONE]"}
{"idx": 345, "completion": "def find_angle(angle1, angle2):\n    angle3 = 180 - (angle1 + angle2)\n    return angle3\n[DONE]"}
{"idx": 346, "completion": "def find_max(test_list):\n    max_val = 0\n    for tup in test_list:\n        current_max = max(tup)\n        if current_max > max_val:\n            max_val = current_max\n    return max_val\n[DONE]"}
{"idx": 347, "completion": "def moddiv_list(list1, list2):\n    res = list(map(lambda x, y: x % y, list1, list2))\n    return res\n[DONE]"}
{"idx": 348, "completion": "def Check_Solution(a, b, c):\n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return \"No\"\n    sqrt_discriminant = discriminant ** 0.5\n    x1 = (-b + sqrt_discriminant) / (2*a)\n    x2 = (-b - sqrt_discriminant) / (2*a)\n    if (x1 == 2 * x2) or (x2 == 2 * x1):\n        return \"Yes\"\n    else:\n        return \"No\"\n[DONE]"}
{"idx": 349, "completion": "def get_carol(n):\n    return (2**n - 1)**2 - 2\n[DONE]"}
{"idx": 350, "completion": "def remove_empty(lst):\n    result = [x for x in lst if x != []]\n    return result\n[DONE]"}
{"idx": 351, "completion": "from collections import Counter\ndef max_occurrences(nums):\n    nums = nums\n    nums = Counter(nums)\n    max_val = max(nums.values())\n    max_keys = [k for k, v in nums.items() if v == max_val]\n    if len(max_keys) == 1:\n        return max_keys[0]\n    else:\n        return max_keys\n[DONE]"}
{"idx": 352, "completion": "def add_K_element(test_list, K):\n    res = [tuple(j + K for j in sub) for sub in test_list]\n    return res\n[DONE]"}
{"idx": 353, "completion": "def min_flip_to_make_string_alternate(bin_str):\n    flip1 = 0  # starts with '0'\n    flip2 = 0  # starts with '1'\n    for i in range(len(bin_str)):\n        expected_char1 = '0' if i % 2 == 0 else '1'\n        if bin_str[i] != expected_char1:\n            flip1 += 1\n        expected_char2 = '1' if i % 2 == 0 else '0'\n        if bin_str[i] != expected_char2:\n            flip2 += 1\n    return min(flip1, flip2)\n[DONE]"}
{"idx": 354, "completion": "def count_Digit(n):\n    return len(str(n))\n[DONE]"}
{"idx": 355, "completion": "def adjacent_num_product(list1):\n    max_product = 0\n    for i in range(len(list1)-1):\n        product = list1[i] * list1[i+1]\n        if product > max_product:\n            max_product = product\n    return max_product\n[DONE]"}
{"idx": 356, "completion": "def is_tree_balanced(root):\n    if root is None:\n        return True\n    left_height = height(root.left)\n    right_height = height(root.right)\n    if abs(left_height - right_height) <= 1 and is_tree_balanced(root.left) and is_tree_balanced(root.right):\n        return True\n    return False\n\ndef height(node):\n    if node is None:\n        return 0\n    return 1 + max(height(node.left), height(node.right))\n[DONE]"}
{"idx": 357, "completion": "def repeat_tuples(test_tup, n):\n    return (test_tup,) * n\n[DONE]"}
{"idx": 358, "completion": "def lateralsurface_cuboid(l, w, h):\n    return 2 * (l + w) * h\n[DONE]"}
{"idx": 359, "completion": "def float_sort(tuple_list):\n    tuple_list.sort(key=lambda x: float(x[1]), reverse=True)\n    return tuple_list\n[DONE]"}
{"idx": 360, "completion": "def smallest_missing(nums, left, right):\n    if left > right:\n        return left\n    mid = left + (right - left) // 2\n    if nums[mid] == mid:\n        return smallest_missing(nums, mid + 1, right)\n    else:\n        return smallest_missing(nums, left, mid - 1)\n[DONE]"}
{"idx": 361, "completion": "import heapq\ndef heap_assending(nums):\n    heapq.heapify(nums)\n    res = []\n    while nums:\n        res.append(heapq.heappop(nums))\n    return res\n[DONE]"}
{"idx": 362, "completion": "def volume_cuboid(l, w, h):\n    return l * w * h\n[DONE]"}
{"idx": 363, "completion": "from itertools import permutations\n\ndef permute_string(s):\n    perms = [''.join(p) for p in permutations(s)]\n    return perms\n[DONE]"}
{"idx": 364, "completion": "def round_num(number, multiple):\n    return multiple * round(number / multiple)\n[DONE]"}
{"idx": 365, "completion": "def remove_replica(test_tup):\n    seen = {}\n    result = []\n    for num in test_tup:\n        if num in seen:\n            result.append('MSP')\n            seen[num] += 1\n        else:\n            result.append(num)\n            seen[num] = 1\n    return tuple(result)\n[DONE]"}
{"idx": 366, "completion": "def remove_Char(s, c):\n    return s.replace(c, '')\n[DONE]"}
{"idx": 367, "completion": "def move_first(lst):\n    if len(lst) > 0:\n        lst.insert(0, lst.pop())\n    return lst\n[DONE]"}
{"idx": 368, "completion": "def surfacearea_cuboid(l, w, h):\n    return 2 * (l * w + w * h + l * h)\n[DONE]"}
{"idx": 369, "completion": "def multi_list(row, col):\n    res = []\n    for i in range(row):\n        inner = []\n        for j in range(col):\n            inner.append(i * j)\n        res.append(inner)\n    return res\n[DONE]"}
{"idx": 370, "completion": "def index_on_inner_list(list1, n):\n    list1.sort(key = lambda x: x[n])\n    return list1\n[DONE]"}
{"idx": 371, "completion": "def find_rotation_count(arr):\n    n = len(arr)\n    low = 0\n    high = n - 1\n    while low <= high:\n        if arr[low] <= arr[high]:\n            return low\n        mid = (low + high) // 2\n        next = (mid + 1) % n\n        prev = (mid - 1 + n) % n\n        if arr[mid] <= arr[next] and arr[mid] <= arr[prev]:\n            return mid\n        elif arr[mid] <= arr[high]:\n            high = mid - 1\n        elif arr[mid] >= arr[low]:\n            low = mid + 1\n    return -1\n[DONE]"}
{"idx": 372, "completion": "def even_bit_toggle_number(n):\n    mask = 0x55555555  # This is a mask with all odd bits set to 1 (0x55555555 in hex)\n    return n ^ mask\n[DONE]"}
{"idx": 373, "completion": "def frequency_Of_Smallest(n, arr):\n    min_val = min(arr)\n    count = arr.count(min_val)\n    return count\n[DONE]"}
{"idx": 374, "completion": "def get_perrin(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-2) + get_perrin(n-3)\n[DONE]"}
{"idx": 375, "completion": "def swap_count(s):\n    count = 0\n    balance = 0\n    for char in s:\n        if char == '[':\n            balance += 1\n        else:\n            balance -= 1\n            if balance < 0:\n                count += 1\n                balance = 0\n    return count\n[DONE]"}
{"idx": 376, "completion": "def even_or_odd(hex_num):\n    last_digit = hex_num[-1].upper()\n    if last_digit in {'0', '2', '4', '6', '8', 'A', 'C', 'E'}:\n        return \"Even\"\n    else:\n        return \"Odd\"\n[DONE]"}
{"idx": 377, "completion": "def highest_Power_of_2(n):\n    res = 1\n    while res * 2 <= n:\n        res *= 2\n    return res\n[DONE]"}
{"idx": 378, "completion": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    a, b = 2, 1\n    for _ in range(2, n + 1):\n        a, b = b, a + b\n    return b\n[DONE]"}
{"idx": 379, "completion": "def add_string(list_, format_string):\n    return [format_string.format(item) for item in list_]\n[DONE]"}
{"idx": 380, "completion": "def convert_list_dictionary(keys, names, values):\n    result = []\n    for i in range(len(keys)):\n        nested_dict = {keys[i]: {names[i]: values[i]}}\n        result.append(nested_dict)\n    return result\n[DONE]"}
{"idx": 381, "completion": "def get_max_sum(n):\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return max(n, get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5))\n[DONE]"}
{"idx": 382, "completion": "def max_length_list(list1):\n    max_length = max(len(x) for x in list1)\n    max_list = next(x for x in list1 if len(x) == max_length)\n    return (max_length, max_list)\n[DONE]"}
{"idx": 383, "completion": "def check_distinct(test_tup):\n    if len(test_tup) == len(set(test_tup)):\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 384, "completion": "def first_non_repeating_character(s):\n    for char in s:\n        if s.count(char) == 1:\n            return char\n    return None\n[DONE]"}
{"idx": 385, "completion": "import re\ndef check_char(string):\n    if re.match(r'^(.).*\\1$', string):\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n[DONE]"}
{"idx": 386, "completion": "def median_numbers(a, b, c):\n    if a > b:\n        if a < c:\n            median = a\n        elif b > c:\n            median = b\n        else:\n            median = c\n    else:\n        if a > c:\n            median = a\n        elif b < c:\n            median = b\n        else:\n            median = c\n    return float(median)\n[DONE]"}
{"idx": 387, "completion": "def sum_of_digits(nums):\n    total = 0\n    for num in nums:\n        if isinstance(num, int) and num >= 0:\n            for digit in str(num):\n                total += int(digit)\n    return total\n[DONE]"}
{"idx": 388, "completion": "def bitwise_xor(test_tup1, test_tup2):\n    res = tuple(a ^ b for a, b in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 389, "completion": "def extract_freq(test_list):\n    unique_tuples = set()\n    for t in test_list:\n        sorted_t = tuple(sorted(t))\n        unique_tuples.add(sorted_t)\n    return len(unique_tuples)\n[DONE]"}
{"idx": 390, "completion": "def add_nested_tuples(tuple1, tuple2):\n    result = tuple(\n        tuple(a + b for a, b in zip(t1, t2))\n        for t1, t2 in zip(tuple1, tuple2)\n    )\n    return result\n[DONE]"}
{"idx": 391, "completion": "def ncr_modp(n, r, p):\n    if r > n:\n        return 0\n    if r == 0 or r == n:\n        return 1\n    # Compute numerator mod p\n    numerator = 1\n    for i in range(n, n - r, -1):\n        numerator = (numerator * i) % p\n    # Compute denominator mod p\n    denominator = 1\n    for i in range(1, r + 1):\n        denominator = (denominator * i) % p\n    # Compute denominator's modular inverse using Fermat's little theorem\n    denominator_inv = pow(denominator, p - 2, p)\n    return (numerator * denominator_inv) % p\n[DONE]"}
{"idx": 392, "completion": "import re\ndef is_valid_URL(url):\n    regex = re.compile(\n        r'^https?://'  # http:// or https://\n        r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\\.)+[A-Z]{2,6}\\.?|'  # domain...\n        r'localhost|'  # localhost...\n        r'\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})' # ...or ip\n        r'(?::\\d+)?'  # optional port\n        r'(?:/?|[/?]\\S+)$', re.IGNORECASE)\n    return re.match(regex, url) is not None\n[DONE]"}
{"idx": 393, "completion": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b\n[DONE]"}
{"idx": 394, "completion": "def check_tuplex(tuplex, element):\n    return element in tuplex\n[DONE]"}
{"idx": 395, "completion": "def find_Parity(x):\n    if x % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n[DONE]"}
{"idx": 396, "completion": "import itertools\n\ndef rearrange_bigger(n):\n    digits = list(str(n))\n    for i in range(len(digits)-1, 0, -1):\n        if digits[i] > digits[i-1]:\n            pivot = i-1\n            break\n    else:\n        return False\n    \n    for i in range(len(digits)-1, pivot, -1):\n        if digits[i] > digits[pivot]:\n            digits[i], digits[pivot] = digits[pivot], digits[i]\n            break\n    \n    digits[pivot+1:] = reversed(digits[pivot+1:])\n    result = int(''.join(digits))\n    return result\n[DONE]"}
{"idx": 397, "completion": "import heapq\ndef k_smallest_pairs(nums1, nums2, k):\n    if not nums1 or not nums2:\n        return []\n    heap = []\n    for i in range(len(nums1)):\n        for j in range(len(nums2)):\n            heapq.heappush(heap, (nums1[i] + nums2[j], i, j))\n    res = []\n    while heap and k > 0:\n        sum_, i, j = heapq.heappop(heap)\n        res.append([nums1[i], nums2[j]])\n        k -= 1\n    return res\n[DONE]"}
{"idx": 398, "completion": "def min_product_tuple(list1):\n    min_prod = float('inf')\n    for tup in list1:\n        product = tup[0] * tup[1]\n        if product < min_prod:\n            min_prod = product\n    return min_prod\n[DONE]"}
{"idx": 399, "completion": "def min_val(test_list):\n    min_val = None\n    for element in test_list:\n        if isinstance(element, int):\n            if min_val is None or element < min_val:\n                min_val = element\n    return min_val\n[DONE]"}
{"idx": 400, "completion": "import re\ndef snake_to_camel(s):\n    return re.sub(r'_([a-z])', lambda x: x.group(1).upper(), s.title())\n[DONE]"}
{"idx": 401, "completion": "def remove_odd(nums):\n    result = [x for x in nums if x % 2 == 0]\n    return result\n[DONE]"}
{"idx": 402, "completion": "def extract_nth_element(test_list, n):\n    res = [x[n] for x in test_list]\n    return res\n[DONE]"}
{"idx": 403, "completion": "def overlapping(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return False\n[DONE]"}
{"idx": 404, "completion": "def max_Product(arr):\n    arr.sort()\n    n = len(arr)\n    if (arr[0] * arr[1]) > (arr[n-1] * arr[n-2]):\n        return (arr[0], arr[1])\n    else:\n        return (arr[n-2], arr[n-1])\n[DONE]"}
{"idx": 405, "completion": "def breakSum(n):\n    if n == 0 or n == 1:\n        return n\n    return max(n, breakSum(n//2) + breakSum(n//3) + breakSum(n//4))\n[DONE]"}
{"idx": 406, "completion": "def group_tuples(tuples_list):\n    groups = {}\n    for t in tuples_list:\n        key = t[0]\n        if key not in groups:\n            groups[key] = [key]\n        groups[key].extend(t[1:])\n    return [tuple(items) for items in groups.values()]\n[DONE]"}
{"idx": 407, "completion": "def Find_Max(l):\n    max_len = max(len(sublist) for sublist in l)\n    for sublist in l:\n        if len(sublist) == max_len:\n            return sublist\n[DONE]"}
{"idx": 408, "completion": "def round_and_sum(nums):\n    rounded_nums = [round(num) for num in nums]\n    total_sum = sum(rounded_nums)\n    result = total_sum * len(nums)\n    return result\n[DONE]"}
{"idx": 409, "completion": "def cube_Sum(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += (2 * i) ** 3\n    return sum\n[DONE]"}
{"idx": 410, "completion": "def concatenate_tuple(test_tup):\n    delimiter = '-'\n    concatenated = delimiter.join([str(elem) for elem in test_tup])\n    return concatenated\n[DONE]"}
{"idx": 411, "completion": "def find_Average_Of_Cube(n):\n    sum_of_cubes = 0\n    for i in range(1, n+1):\n        sum_of_cubes += i ** 3\n    average = sum_of_cubes / n\n    return average\n[DONE]"}
{"idx": 412, "completion": "def get_maxgold(gold, m, n):\n    dp = [[0 for _ in range(n)] for _ in range(m)]\n    for col in range(n-1, -1, -1):\n        for row in range(m):\n            if col == n-1:\n                right = 0\n            else:\n                right = dp[row][col+1]\n            if row == 0 or col == n-1:\n                right_up = 0\n            else:\n                right_up = dp[row-1][col+1]\n            if row == m-1 or col == n-1:\n                right_down = 0\n            else:\n                right_down = dp[row+1][col+1]\n            dp[row][col] = gold[row][col] + max(right, right_up, right_down)\n    max_gold = dp[0][0]\n    for i in range(1, m):\n        if dp[i][0] > max_gold:\n            max_gold = dp[i][0]\n    return max_gold\n[DONE]"}
{"idx": 413, "completion": "def extract_rear(words):\n    return [word[-1] for word in words]\n[DONE]"}
{"idx": 414, "completion": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n[DONE]"}
{"idx": 415, "completion": "def filter_oddnumbers(nums):\n    odd_numbers = list(filter(lambda x: x % 2 != 0, nums))\n    return odd_numbers\n[DONE]"}
{"idx": 416, "completion": "import re\ndef change_date_format(dt):\n    return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)\n[DONE]"}
{"idx": 417, "completion": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\n[DONE]"}
{"idx": 418, "completion": "def and_tuples(test_tup1, test_tup2):\n    res = tuple([ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2)])\n    return res\n[DONE]"}
{"idx": 419, "completion": "def parabola_directrix(a, b, c):\n    directrix = c - ((b**2) + 1)/(4*a)\n    return directrix\n[DONE]"}
{"idx": 420, "completion": "def common_element(list1, list2):\n    for element in list1:\n        if element in list2:\n            return True\n    return None\n[DONE]"}
{"idx": 421, "completion": "def median_trapezium(a, b, c):\n    median = (a + b) / 2\n    return median\n[DONE]"}
{"idx": 422, "completion": "def check_greater(arr, num):\n    if num > max(arr):\n        return \"Yes, the entered number is greater than those in the array\"\n    else:\n        return \"No, entered number is less than those in the array\"\n[DONE]"}
{"idx": 423, "completion": "import re\ndef text_match_one(text):\n    pattern = r'ab+'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 424, "completion": "def last_Digit(n):\n    return n % 10\n[DONE]"}
{"idx": 425, "completion": "def neg_nos(list1):\n    neg_list = [num for num in list1 if num < 0]\n    return tuple(neg_list)\n[DONE]"}
{"idx": 426, "completion": "def remove_odd(test_str):\n    res = \"\"\n    for i in range(len(test_str)):\n        if i % 2 != 0:\n            res = res + test_str[i]\n    return res\n[DONE]"}
{"idx": 427, "completion": "def count_bidirectional(test_list):\n    count = 0\n    seen = set()\n    for t in test_list:\n        if t[::-1] in seen:\n            count += 1\n            seen.remove(t[::-1])\n        else:\n            seen.add(t)\n    return str(count * 2)\n[DONE]"}
{"idx": 428, "completion": "def multiple_to_single(lst):\n    num_str = ''.join(map(str, lst))\n    return int(num_str)\n[DONE]"}
{"idx": 429, "completion": "import re\ndef find_adverb_position(s):\n    match = re.search(r'\\w+ly', s)\n    if match:\n        return (match.start(), match.end(), match.group())\n    else:\n        return None\n[DONE]"}
{"idx": 430, "completion": "def surfacearea_cube(side):\n    return 6 * (side ** 2)\n[DONE]"}
{"idx": 431, "completion": "def positive_count(nums):\n    positive_nums = [num for num in nums if num > 0]\n    ratio = round(len(positive_nums)/len(nums), 2)\n    return ratio\n[DONE]"}
{"idx": 432, "completion": "def largest_neg(list1): \n    neg_nums = [num for num in list1 if num < 0]\n    if not neg_nums:\n        return None\n    return max(neg_nums)\n[DONE]"}
{"idx": 433, "completion": "def trim_tuple(test_list, K):\n    res = [tuple(tup[K:len(tup)-K]) for tup in test_list]\n    return str(res)\n[DONE]"}
{"idx": 434, "completion": "def index_multiplication(test_tup1, test_tup2):\n    res = tuple(tuple(a * b for a, b in zip(t1, t2)) for t1, t2 in zip(test_tup1, test_tup2))\n    return res\n[DONE]"}
{"idx": 435, "completion": "def count_Occurrence(tup, lst):\n    count = 0\n    for element in tup:\n        if element in lst:\n            count += 1\n    return count\n[DONE]"}
{"idx": 436, "completion": "def cube_nums(nums):\n    cube_nums = list(map(lambda x: x ** 3, nums))\n    return cube_nums\n[DONE]"}
{"idx": 437, "completion": "def cal_sum(n):\n    if n == 0:\n        return 3\n    elif n == 1:\n        return 3\n    elif n == 2:\n        return 5\n    else:\n        a, b, c = 3, 0, 2\n        total = 5  # Sum of first three terms (3 + 0 + 2)\n        for i in range(3, n + 1):\n            next_term = a + b\n            total += next_term\n            a, b, c = b, c, next_term\n        return total\n[DONE]"}
{"idx": 438, "completion": "def check_Triangle(x1, y1, x2, y2, x3, y3):\n    # Calculate the lengths of the sides\n    a = (x1 - x2)**2 + (y1 - y2)**2\n    b = (x2 - x3)**2 + (y2 - y3)**2\n    c = (x3 - x1)**2 + (y3 - y1)**2\n    \n    # Check if the sum of any two sides is greater than the third\n    if a + b > c and a + c > b and b + c > a:\n        return 'Yes'\n    else:\n        return 'No'\n[DONE]"}
{"idx": 439, "completion": "def extract_string(str_list, size):\n    result = [word for word in str_list if len(word) >= size]\n    return result\n[DONE]"}
{"idx": 440, "completion": "import re\ndef remove_whitespaces(string):\n    return re.sub(r'\\s+', '', string)\n[DONE]"}
{"idx": 441, "completion": "def loss_amount(actual_cost, sale_amount):\n    if actual_cost > sale_amount:\n        return actual_cost - sale_amount\n    else:\n        return None\n[DONE]"}
{"idx": 442, "completion": "def sumofFactors(n):\n    sum_even = 0\n    for i in range(1, n + 1):\n        if n % i == 0 and i % 2 == 0:\n            sum_even += i\n    return sum_even\n[DONE]"}
{"idx": 443, "completion": "import re\ndef text_match_wordz(text):\n    pattern = r'\\w*z\\w*'\n    if re.search(pattern, text):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n[DONE]"}
{"idx": 444, "completion": "def check_monthnumb_number(month):\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return True\n    else:\n        return False\n[DONE]"}
{"idx": 445, "completion": "def reverse_string_list(string_list):\n    reversed_list = [s[::-1] for s in string_list]\n    return reversed_list\n[DONE]"}
{"idx": 446, "completion": "def Find_Min(lst):\n    min_length = min(len(x) for x in lst)\n    min_sublist = next(x for x in lst if len(x) == min_length)\n    return min_sublist\n[DONE]"}
{"idx": 447, "completion": "def rectangle_area(length, width):\n    return length * width\n[DONE]"}
{"idx": 448, "completion": "import re\ndef remove_uppercase(str1):\n    return re.sub('[A-Z]', '', str1)\n[DONE]"}
{"idx": 449, "completion": "def Extract(lst):\n    return [item[0] for item in lst]\n[DONE]"}
{"idx": 450, "completion": "def upper_ctr(str):\n    count = 0\n    for i in str:\n        if i.isupper():\n            count += 1\n    return count\n[DONE]"}
{"idx": 451, "completion": "from itertools import combinations\n\ndef combinations_list(lst):\n    result = []\n    for r in range(len(lst) + 1):\n        for combo in combinations(lst, r):\n            result.append(list(combo))\n    return result\n[DONE]"}
{"idx": 452, "completion": "def max_subarray_product(arr):\n    if not arr:\n        return 0\n    max_product = current_max = current_min = arr[0]\n    for num in arr[1:]:\n        if num < 0:\n            current_max, current_min = current_min, current_max\n        current_max = max(num, current_max * num)\n        current_min = min(num, current_min * num)\n        max_product = max(max_product, current_max)\n    return max_product\n[DONE]"}
{"idx": 453, "completion": "def check_value(dictionary, value):\n    return all(v == value for v in dictionary.values())\n[DONE]"}
{"idx": 454, "completion": "def drop_empty(d):\n    return {k: v for k, v in d.items() if v is not None}\n[DONE]"}
{"idx": 455, "completion": "def find_peak(arr, n):\n    if n == 1:\n        return 0\n    if arr[0] >= arr[1]:\n        return 0\n    if arr[n - 1] >= arr[n - 2]:\n        return n - 1\n    for i in range(1, n - 1):\n        if arr[i] >= arr[i - 1] and arr[i] >= arr[i + 1]:\n            return i\n    return -1\n[DONE]"}
{"idx": 456, "completion": "def decimal_to_Octal(n):\n    return int(oct(n)[2:])\n[DONE]"}
{"idx": 457, "completion": "def max_product(arr, n):\n    max_prod = 1\n    for i in range(1, 1 << n):\n        prev = -1\n        current_prod = 1\n        for j in range(n):\n            if (i >> j) & 1:\n                if arr[j] > prev:\n                    current_prod *= arr[j]\n                    prev = arr[j]\n                else:\n                    current_prod = 0\n                    break\n        if current_prod > max_prod:\n            max_prod = current_prod\n    return max_prod\n[DONE]"}
{"idx": 458, "completion": "def max_profit(prices, k):\n    if not prices or k == 0:\n        return 0\n    \n    n = len(prices)\n    dp = [[0] * n for _ in range(k + 1)]\n    \n    for i in range(1, k + 1):\n        max_diff = -prices[0]\n        for j in range(1, n):\n            dp[i][j] = max(dp[i][j - 1], prices[j] + max_diff)\n            max_diff = max(max_diff, dp[i - 1][j] - prices[j])\n    \n    return dp[k][n - 1]\n[DONE]"}
{"idx": 459, "completion": "def add_pairwise(test_tup):\n    res = tuple(test_tup[i] + test_tup[i + 1] for i in range(len(test_tup) - 1))\n    return res\n[DONE]"}
{"idx": 460, "completion": "def find_remainder(arr, n, num):\n    product = 1\n    for i in range(n):\n        product = (product * arr[i]) % num\n    return product % num\n[DONE]"}
{"idx": 461, "completion": "def check_Consecutive(l):\n    if len(l) < 1:\n        return False\n    min_val = min(l)\n    max_val = max(l)\n    if max_val - min_val + 1 == len(l):\n        for i in range(len(l)):\n            if l[i] - min_val != i:\n                return False\n        return True\n    return False\n[DONE]"}
{"idx": 462, "completion": "def tuple_intersection(test_list1, test_list2):\n    set1 = set(map(frozenset, test_list1))\n    set2 = set(map(frozenset, test_list2))\n    intersection = set1 & set2\n    result = set()\n    for elem in intersection:\n        if len(elem) == 1:\n            result.add(tuple(elem))\n        else:\n            result.add(tuple(elem))\n    return result\n[DONE]"}
{"idx": 463, "completion": "def replace_char(string, old_char, new_char):\n    new_string = string.replace(old_char, new_char)\n    return new_string\n[DONE]"}
{"idx": 464, "completion": "def sort_counter(dict1):\n    sorted_counter = sorted(dict1.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counter\n[DONE]"}
{"idx": 465, "completion": "def big_sum(nums):\n    return max(nums) + min(nums)\n[DONE]"}
{"idx": 466, "completion": "def is_lower(string):\n    return string.lower()\n[DONE]"}
{"idx": 467, "completion": "def remove_lowercase(s):\n    result = \"\"\n    for char in s:\n        if not char.islower():\n            result += char\n    return result\n[DONE]"}
{"idx": 468, "completion": "def first_Digit(n):\n    n = abs(n)\n    while n >= 10:\n        n = n // 10\n    return n\n[DONE]"}
{"idx": 469, "completion": "from collections import Counter\n\ndef get_max_occuring_char(string):\n    count = Counter(string)\n    max_char = max(count, key=count.get)\n    return max_char\n[DONE]"}
{"idx": 470, "completion": "def is_subset_sum(arr, n, sum):\n    if sum == 0:\n        return True\n    if n == 0 and sum != 0:\n        return False\n    if arr[n-1] > sum:\n        return is_subset_sum(arr, n-1, sum)\n    return is_subset_sum(arr, n-1, sum) or is_subset_sum(arr, n-1, sum-arr[n-1])\n[DONE]"}
{"idx": 471, "completion": "import re\ndef match(string):\n    if re.search(r'[A-Z][a-z]+', string):\n        return 'Yes'\n    else:\n        return 'No'\n[DONE]"}
{"idx": 472, "completion": "import math\ndef first_Factorial_Divisible_Number(x):\n    n = 1\n    while True:\n        if math.factorial(n) % x == 0:\n            return n\n        n += 1\n[DONE]"}
{"idx": 473, "completion": "def remove_matching_tuple(test_tup1, test_tup2):\n    res = [ele for ele in test_tup1 if ele not in test_tup2]\n    return res\n[DONE]"}
{"idx": 474, "completion": "def largest_palindrome(arr, n):\n    max_palindrome = -1\n    for num in arr:\n        if str(num) == str(num)[::-1] and num > max_palindrome:\n            max_palindrome = num\n    return max_palindrome\n[DONE]"}
{"idx": 475, "completion": "import math\ndef binomial_probability(n, k, p):\n    combination = math.comb(n, k)\n    probability = combination * (p ** k) * ((1 - p) ** (n - k))\n    return probability\n[DONE]"}
{"idx": 476, "completion": "def sort_tuple(tuple_list):\n    tuple_list.sort(key=lambda x: x[-1])\n    return tuple_list\n[DONE]"}
{"idx": 477, "completion": "import math\ndef area_pentagon(a):\n    area = (5 * a ** 2) / (4 * math.tan(math.pi / 5))\n    return area\n[DONE]"}
{"idx": 478, "completion": "def frequency_Of_Largest(n,arr):\n    max_val = max(arr)\n    count = arr.count(max_val)\n    return count\n[DONE]"}
{"idx": 479, "completion": "def extract_symmetric(test_list):\n    res = set()\n    for pair in test_list:\n        if (pair[1], pair[0]) in test_list and pair[0] != pair[1]:\n            res.add(tuple(sorted(pair)))\n    return res\n[DONE]"}
{"idx": 480, "completion": "def sum_gp(a, r, n):\n    if r == 1:\n        return a * n\n    else:\n        return a * (1 - r ** n) // (1 - r)\n[DONE]"}
{"idx": 481, "completion": "def binary_search(arr, x):\n    low = 0\n    high = len(arr) - 1\n    mid = 0\n    while low <= high:\n        mid = (high + low) // 2\n        if arr[mid] < x:\n            low = mid + 1\n        elif arr[mid] > x:\n            high = mid - 1\n        else:\n            return True\n    return False\n[DONE]"}
{"idx": 482, "completion": "import math\n\ndef calculate_polygons(startx, starty, endx, endy, radius):\n    polygons = []\n    for x in range(startx, endx + 1, radius * 2):\n        for y in range(starty, endy + 1, int(radius * math.sqrt(3))):\n            hexagon = []\n            for i in range(6):\n                angle_deg = 60 * i - 30\n                angle_rad = math.pi / 180 * angle_deg\n                hex_x = x + radius * math.cos(angle_rad)\n                hex_y = y + radius * math.sin(angle_rad)\n                hexagon.append((hex_x, hex_y))\n            hexagon.append(hexagon[0])  # Close the hexagon\n            polygons.append(hexagon)\n    return polygons\n[DONE]"}
{"idx": 483, "completion": "def binary_to_integer(bin_tuple):\n    binary_str = ''.join(map(str, bin_tuple))\n    decimal_num = int(binary_str, 2)\n    return str(decimal_num)\n[DONE]"}
{"idx": 484, "completion": "import re\ndef remove_lowercase(string):\n    pattern = r'[^a-z]'\n    result = re.findall(pattern, string)\n    return ''.join(result)\n[DONE]"}
{"idx": 485, "completion": "import heapq\ndef heap_queue_smallest(nums,n):\n    smallest_n = heapq.nsmallest(n, nums)\n    return smallest_n\n[DONE]"}
{"idx": 486, "completion": "import math\ndef surfacearea_cone(r, h):\n    l = math.sqrt(r**2 + h**2)\n    area = math.pi * r * (r + l)\n    return area\n[DONE]"}
{"idx": 487, "completion": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n[DONE]"}
{"idx": 488, "completion": "def diameter_circle(r):\n    return 2 * r\n[DONE]"}
{"idx": 489, "completion": "def concatenate_elements(list_data):\n    result = '  ' + ' '.join(list_data)\n    return result\n[DONE]"}
{"idx": 490, "completion": "import math\ndef num_comm_div(a, b):\n    def gcd(x, y):\n        while y:\n            x, y = y, x % y\n        return x\n    def count_divisors(n):\n        if n == 0:\n            return 0\n        count = 0\n        sqrt_n = int(math.sqrt(n))\n        for i in range(1, sqrt_n + 1):\n            if n % i == 0:\n                if i * i == n:\n                    count += 1\n                else:\n                    count += 2\n        return count\n    g = gcd(a, b)\n    return count_divisors(g)\n[DONE]"}
{"idx": 491, "completion": "def find(a, b):\n    return a % b\n[DONE]"}
{"idx": 492, "completion": "def add_consecutive_nums(nums):\n    res = []\n    for i in range(len(nums)-1):\n        res.append(nums[i] + nums[i+1])\n    return res\n[DONE]"}
{"idx": 493, "completion": "def sum_Of_Series(n):\n    sum = 0\n    for i in range(1, n+1):\n        sum += i**3\n    return sum\n[DONE]"}
{"idx": 494, "completion": "def re_order(arr):\n    non_zero = [x for x in arr if x != 0]\n    zero = [x for x in arr if x == 0]\n    return non_zero + zero\n[DONE]"}
{"idx": 495, "completion": "def permutation_coefficient(n, k):\n    result = 1\n    for i in range(k):\n        result *= (n - i)\n    return result\n[DONE]"}
{"idx": 496, "completion": "def remove_words(list1, remove_words):\n    result = [word for word in list1 if word not in remove_words]\n    return result\n[DONE]"}
{"idx": 497, "completion": "def same_order(l1, l2):\n    common1 = [x for x in l1 if x in l2]\n    common2 = [x for x in l2 if x in l1]\n    return common1 == common2\n[DONE]"}
{"idx": 498, "completion": "def average_Odd(n):\n    sum_odd = 0\n    count_odd = 0\n    for num in range(1, n + 1, 2):\n        sum_odd += num\n        count_odd += 1\n    return sum_odd // count_odd\n[DONE]"}
{"idx": 499, "completion": "def no_of_subsequences(arr, k):\n    n = len(arr)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if arr[i - 1] < k:\n                dp[i][j] = dp[i - 1][j - 1] * arr[i - 1]\n                if dp[i][j] < k:\n                    dp[i][j] += 1\n                else:\n                    dp[i][j] = 0\n            else:\n                dp[i][j] = 0\n    return sum(sum(row) for row in dp)\n[DONE]"}
