{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current.append(char)\n\n        if depth == 0:\n            result.append(''.join(current).strip())\n            current = []\n\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    result = [numbers[0]]\n    for number in numbers[1:]:\n        result.append(delimeter)\n        result.append(number)\n    return result"}
{"idx": 6, "completion": "# Split the input string into individual groups of parentheses\n    paren_groups = paren_string.split()\n\n    # Initialize a list to store the maximum nesting levels for each group\n    max_nesting_levels = []\n\n    # Iterate over each group of parentheses\n    for group in paren_groups:\n        max_depth = 0\n        current_depth = 0\n\n        # Iterate over each character in the group\n        for char in group:\n            if char == '(':\n                # Increase the current depth for each '('\n                current_depth += 1\n                # Update the maximum depth if the current depth is greater\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                # Decrease the current depth for each ')'\n                current_depth -= 1\n\n        # Append the maximum depth of the current group to the list\n        max_nesting_levels.append(max_depth)\n\n    return max_nesting_levels"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_result = sum(numbers)\n    product_result = 1\n    for number in numbers:\n        product_result *= number\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "if a == 0 or b == 0:\n        return 0\n    if a == b:\n        return a\n    if a > b:\n        return greatest_common_divisor(a - b, b)\n    return greatest_common_divisor(a, b - a)"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_durations = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n\n    notes = music_string.split()\n    beats = [note_durations[note] for note in notes]\n\n    return beats"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    count = 0\n    i = 0\n    while i <= len(string) - len(substring):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n            i += len(substring) - 1\n        else:\n            i += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n    return result"}
{"idx": 21, "completion": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        raise ValueError(\"All elements in the list must be distinct\")\n    \n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0, \"xs must have even number of coefficients\"\n    assert xs[-1] != 0, \"largest coefficient must be non zero\"\n    # find x such that poly(x) = 0\n    # we can use binary search\n    # we know that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point\n    # we can use binary search to find it\n    # we can use the fact that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point\n    # we can use binary search to find it\n    # we can use the fact that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point\n    # we can use binary search to find it\n    # we can use the fact that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point\n    # we can use binary search to find it\n    # we can use the fact that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point\n    # we can use binary search to find it\n    # we can use the fact that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point\n    # we can use binary search to find it\n    # we can use the fact that poly(x) is continuous\n    # and poly(x) -> inf as x -> inf\n    # and poly(x) -> -inf as x -> -inf\n    # so there must be a zero point"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices.sort()\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[0:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        for i in range(3, int(x**0.5) + 1, 2):\n            if x % i == 0:\n                return False\n        return True\n\n    def fib():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    fib_gen = fib()\n    count = 0\n    for f in fib_gen:\n        if is_prime(f):\n            count += 1\n            if count == n:\n                return f"}
{"idx": 40, "completion": "# your code here\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "assert base < 10\n\n    if x == 0:\n        return \"0\"\n\n    digits = []\n    while x:\n        digits.append(str(x % base))\n        x = x // base\n    return \"\".join(digits[::-1])"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "return pow(2, n, p)"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    return ''.join(char for char in text if char not in vowels)"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 0:\n        raise ValueError(\"Fibonacci index cannot be negative.\")\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1).intersection(set(l2)))"}
{"idx": 59, "completion": "# Start with the smallest prime factor\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            # If n is divisible by factor, divide n by factor and check again\n            n //= factor\n        else:\n            # Otherwise, try the next number\n            factor += 1\n    # The remaining value of n is the largest prime factor\n    return n"}
{"idx": 60, "completion": "return sum(range(n + 1))"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "x_str = str(x)\n    shift = shift % len(x_str)\n    return x_str[-shift:] + x_str[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string by spaces\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[2])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = float('inf')\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if value < min_even:\n                min_even = value\n                min_index = index\n    \n    if min_even == float('inf'):\n        return []\n    else:\n        return [min_even, min_index]"}
{"idx": 69, "completion": "frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    result = -1\n    for num, freq in frequency.items():\n        if freq >= num and num > result:\n            result = num\n\n    return result"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    return result"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "n = len(arr)\n    count = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            count += 1\n    return count"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0:\n        return True\n    low = 1\n    high = a\n    while low <= high:\n        mid = (low + high) // 2\n        if mid ** 3 == a:\n            return True\n        elif mid ** 3 < a:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate over each character in the input string\n    for char in num:\n        # If the character is a prime digit, increment the counter\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length == 1:\n        return False\n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "# If n is 1, then the only number is 1, so the count is 1.\n    if n == 1:\n        return 1\n    # If n is greater than 1, then the count is 2^(n-1).\n    else:\n        return 2 ** (n - 1)"}
{"idx": 84, "completion": "digit_sum = sum(int(digit) for digit in str(N))\n    return bin(digit_sum)[2:]"}
{"idx": 85, "completion": "total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order, and by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    if len(array) == 1:\n        return array\n    if (array[0] + array[-1]) % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted = ''\n    for char in s:\n        # Shift each character down by 2 * 2 = 4 places\n        encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        encrypted += encrypted_char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst_sorted = sorted(lst)\n    smallest = lst_sorted[0]\n    for num in lst_sorted:\n        if num != smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # Check if one of the numbers is equal to the sum of the other two\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False"}
{"idx": 93, "completion": "vowels = 'aeiou'\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                # Find the index of the vowel in the vowels string\n                index = vowels.find(char.lower())\n                # Replace with the letter 2 places ahead in the alphabet\n                new_char = chr(ord(vowels[index]) + 2)\n                # Swap the case\n                if char.isupper():\n                    new_char = new_char.upper()\n                else:\n                    new_char = new_char.lower()\n                encoded_message += new_char\n            else:\n                # Swap the case of the consonant\n                if char.isupper():\n                    encoded_message += char.lower()\n                else:\n                    encoded_message += char.upper()\n        else:\n            # If the character is not a letter, keep it as is\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b"}
{"idx": 98, "completion": "count = 0\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    for i in range(0, len(s), 2):\n        if s[i].isupper() and s[i] in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return int(round(number))"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "# Split the string by both commas and spaces\n    words = s.replace(',', ' ').split()\n    return words"}
{"idx": 102, "completion": "# Swap x and y if x is greater than y\n    if x > y:\n        x, y = y, x\n\n    # Initialize the result to -1\n    result = -1\n\n    # Iterate through the range [x, y]\n    for num in range(x, y + 1):\n        # Check if the number is even\n        if num % 2 == 0:\n            # Update the result if the current even number is greater than the previous result\n            if num > result:\n                result = num\n\n    return result"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = round((n + m) / 2)\n    return bin(avg)"}
{"idx": 104, "completion": "def has_even_digit(number):\n        while number > 0:\n            digit = number % 10\n            if digit % 2 == 0:\n                return True\n            number = number // 10\n        return False\n\n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()\n    return result"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Calculate the factorial of i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate the sum of numbers from 1 to i\n            total = 0\n            for j in range(1, i + 1):\n                total += j\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        sum_of_digits = 0\n        for digit in str(num):\n            if digit == '-':\n                continue\n            sum_of_digits += int(digit)\n        if sum_of_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    \n    n = len(arr)\n    sorted_arr = sorted(arr)\n    \n    for i in range(n):\n        if arr == sorted_arr[i:] + sorted_arr[:i]:\n            return True\n    return False"}
{"idx": 110, "completion": "# Check if lst1 is already all even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n\n    # Check if there are any even numbers in lst2 to exchange\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n\n    # Count the number of odd numbers in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n\n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n\n    # If there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    # Split the string into a list of words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Iterate over each character in the word\n        for char in word:\n            # If the character is already in the dictionary, increment its count\n            if char in letter_count:\n                letter_count[char] += 1\n            # Otherwise, add the character to the dictionary with a count of 1\n            else:\n                letter_count[char] = 1\n    \n    # Find the maximum count in the dictionary\n    max_count = max(letter_count.values(), default=0)\n    \n    # Create a new dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate over the items in the letter_count dictionary\n    for letter, count in letter_count.items():\n        # If the count is equal to the maximum count, add the letter to the max_letters dictionary\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Delete all characters in s that are in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "total_buckets = 0\n    for row in grid:\n        row_sum = sum(row)\n        total_buckets += math.ceil(row_sum / capacity)\n    return total_buckets"}
{"idx": 116, "completion": "# Your code here\n    pass"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    words = s.split()\n    for word in words:\n        consonant_count = sum(1 for char in word if char.isalpha() and char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for i in range(len(word)-1, 0, -1):\n        if word[i] in vowels:\n            # Check if the current vowel is between two consonants\n            if i > 0 and i < len(word)-1:\n                if word[i-1] in consonants and word[i+1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    for a, b in [(s1, s2), (s2, s1)]:\n        combined = a + b\n        if is_good(combined):\n            return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    \n    # Select the k maximum elements from the sorted array\n    max_k = arr_sorted[-k:]\n    \n    # Return the sorted list of the k maximum elements\n    return max_k"}
{"idx": 121, "completion": "total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total"}
{"idx": 122, "completion": "# Initialize the sum to 0\n    total_sum = 0\n    \n    # Iterate over the first k elements of the array\n    for i in range(min(k, len(arr))):\n        # Check if the current element has at most two digits\n        if arr[i] < 100 and arr[i] > -100:\n            # Add the element to the sum\n            total_sum += arr[i]\n    \n    return total_sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = sorted([x for x in collatz_sequence if x % 2 != 0])\n    return odd_numbers"}
{"idx": 124, "completion": "# Check if the date string is not empty\n    if not date:\n        return False\n    \n    # Check if the date format is mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if c.islower() and ord(c) % 2 != 0)"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n        if lst[i] == lst[i+1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., it's not empty)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals don't intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "def is_valid(x, y, n):\n        return 0 <= x < n and 0 <= y < n\n\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_path = None\n\n    for i in range(n):\n        for j in range(n):\n            queue = [(i, j, [grid[i][j]])]\n            while queue:\n                x, y, path = queue.pop(0)\n                if len(path) == k:\n                    if min_path is None or path < min_path:\n                        min_path = path.copy()\n                    continue\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny, n):\n                        new_path = path + [grid[nx][ny]]\n                        queue.append((nx, ny, new_path))\n\n    return min_path"}
{"idx": 130, "completion": "if n < 0:\n        return []\n\n    tribonacci_sequence = [1]\n    if n == 0:\n        return tribonacci_sequence\n\n    tribonacci_sequence.append(3)\n    if n == 1:\n        return tribonacci_sequence\n\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci_sequence.append(1 + i // 2)\n        else:\n            tribonacci_sequence.append(tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i + 1])\n\n    return tribonacci_sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n = n // 10\n    if has_odd:\n        return product\n    else:\n        return 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if txt.endswith(' ' + last_char):\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [x for x in lst if x < 0]\n    positive_integers = [x for x in lst if x > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Replace comma with dot for string representations of numbers\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n    \n    # Convert to float for comparison\n    try:\n        a_val = float(a)\n        b_val = float(b)\n    except ValueError:\n        return None\n    \n    # Compare the values\n    if a_val > b_val:\n        return a if isinstance(a, str) else a_val\n    elif b_val > a_val:\n        return b if isinstance(b, str) else b_val\n    else:\n        return None"}
{"idx": 138, "completion": "# If n is less than 8, it cannot be expressed as the sum of 4 positive even numbers\n    if n < 8:\n        return False\n\n    # If n is divisible by 2, it can be expressed as the sum of 4 positive even numbers\n    if n % 2 == 0:\n        return True\n\n    # If n is odd, it cannot be expressed as the sum of 4 positive even numbers\n    return False"}
{"idx": 139, "completion": "factorial = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        factorial *= i\n        special_fact *= factorial\n    return special_fact"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    while '___' in text:\n        # Replace sequences of more than 2 underscores with a single '-'\n        text = text.replace('___', '-')\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name starts with a letter from the latin alphabet\n    if not name or not name[0].isalpha():\n        return 'No'\n    \n    # Check if there are not more than three digits in the name\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "def gcd(a, b):\n        while b:\n            a, b = b, a % b\n        return a\n\n    def simplify_fraction(numerator, denominator):\n        common_divisor = gcd(numerator, denominator)\n        return numerator // common_divisor, denominator // common_divisor\n\n    x_numerator, x_denominator = map(int, x.split('/'))\n    n_numerator, n_denominator = map(int, n.split('/'))\n\n    # Multiply the numerators and denominators\n    product_numerator = x_numerator * n_numerator\n    product_denominator = x_denominator * n_denominator\n\n    # Simplify the resulting fraction\n    simplified_numerator, simplified_denominator = simplify_fraction(product_numerator, product_denominator)\n\n    # Check if the simplified denominator is 1, indicating a whole number\n    return simplified_denominator == 1"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    # Create a list of tuples (index, number, sum of digits)\n    num_info = []\n    for idx, num in enumerate(nums):\n        abs_num = abs(num)\n        digit_sum = sum(int(d) for d in str(abs_num))\n        num_info.append((idx, num, digit_sum))\n\n    # Sort the list based on the sum of digits, and then by index\n    num_info_sorted = sorted(num_info, key=lambda x: (x[2], x[0]))\n\n    # Extract the sorted numbers\n    sorted_nums = [info[1] for info in num_info_sorted]\n\n    return sorted_nums"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start > end:\n        start, end = end, start\n    return tuple(planets[start+1:end])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if is_prime(n):\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if isinstance(x, int) and x > 0 and x % 2 != 0)"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the length of b is greater than a\n    if len(b) > len(a):\n        return False\n\n    # Create all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n\n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "roman_numerals = {\n        1000: 'm',\n        900: 'cm',\n        500: 'd',\n        400: 'cd',\n        100: 'c',\n        90: 'xc',\n        50: 'l',\n        40: 'xl',\n        10: 'x',\n        9: 'ix',\n        5: 'v',\n        4: 'iv',\n        1: 'i'\n    }\n\n    roman_string = ''\n    for value, numeral in sorted(roman_numerals.items(), reverse=True):\n        while number >= value:\n            roman_string += numeral\n            number -= value\n    return roman_string"}
{"idx": 157, "completion": "# First, we need to check if the given sides can form a triangle.\n    # The sum of the lengths of any two sides must be greater than the length of the remaining side.\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # To determine if the triangle is right-angled, we can use the Pythagorean theorem.\n    # The theorem states that in a right-angled triangle, the square of the length of the hypotenuse\n    # (the longest side) is equal to the sum of squares of the other two sides.\n    # We will check this condition for all three combinations of sides.\n    \n    # First, check if 'c' is the hypotenuse.\n    if a**2 + b**2 == c**2:\n        return True\n    # Next, check if 'b' is the hypotenuse.\n    elif a**2 + c**2 == b**2:\n        return True\n    # Finally, check if 'a' is the hypotenuse.\n    elif b**2 + c**2 == a**2:\n        return True\n    # If none of the above conditions are met, the triangle is not right-angled.\n    else:\n        return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(d) % 2 == 0 for d in str(i))]"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current_group = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n\n        current_group.append(char)\n\n        if depth == 0:\n            result.append(''.join(current_group))\n            current_group = []\n\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)"}
{"idx": 5, "completion": "result = []\n    for i, number in enumerate(numbers):\n        result.append(number)\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    return result"}
{"idx": 6, "completion": "if not paren_string:\n        return []\n\n    paren_groups = paren_string.split()\n    max_depths = []\n\n    for group in paren_groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(max_depth)\n\n    return max_depths"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_result = 0\n    product_result = 1\n    for number in numbers:\n        sum_result += number\n        product_result *= number\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for number in numbers[1:]:\n        if number > max_so_far:\n            max_so_far = number\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "# Create a dictionary to map the note representations to their corresponding beats\n    note_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the music_string into individual note representations\n    notes = music_string.split()\n    \n    # Initialize an empty list to store the beat durations\n    beats = []\n    \n    # Iterate over each note in the notes list\n    for note in notes:\n        # Append the corresponding beat duration to the beats list\n        beats.append(note_beats.get(note, 0))\n    \n    return beats"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    count = 0\n    i = 0\n    while i <= len(string) - len(substring):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n            i += len(substring) - 1\n        else:\n            i += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "numbers.sort()\n    min_diff = float('inf')\n    result = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n\n    return result"}
{"idx": 21, "completion": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n\n    min_val = min(numbers)\n    max_val = max(numbers)\n\n    if min_val == max_val:\n        raise ValueError(\"All elements in the list are equal, cannot rescale to unit\")\n\n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [i for i in l if i > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    for i in range(2, int(n**0.5)+1):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0, \"Length of coefficients must be even\"\n    assert xs[-1] != 0, \"Largest coefficient must be non zero\"\n\n    def f(x):\n        return poly(xs, x)\n\n    a = -1\n    b = 1\n\n    while f(a) * f(b) >= 0:\n        a *= 2\n        b *= 2\n\n    # Now f(a) and f(b) have different signs\n    # We can apply binary search to find the zero point\n\n    while abs(b - a) > 1e-10:\n        c = (a + b) / 2\n        if f(c) == 0:\n            return c\n        elif f(c) * f(a) < 0:\n            b = c\n        else:\n            a = c\n\n    return (a + b) / 2"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices.sort()\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x == 1:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    def fib():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    fib_gen = fib()\n    count = 0\n    for f in fib_gen:\n        if is_prime(f):\n            count += 1\n            if count == n:\n                return f"}
{"idx": 40, "completion": "# your code here\n    l.sort()\n    for i in range(len(l) - 2):\n        j = i + 1\n        k = len(l) - 1\n        while j < k:\n            if l[i] + l[j] + l[k] == 0:\n                return True\n            elif l[i] + l[j] + l[k] < 0:\n                j += 1\n            else:\n                k -= 1\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x < 0 or base <= 0 or base == 1:\n        raise ValueError(\"The number x must be a positive integer and the base must be a positive integer greater than 1.\")\n    if x == 0:\n        return '0'\n    result = []\n    while x > 0:\n        remainder = x % base\n        result.append(str(remainder))\n        x = x // base\n    return ''.join(result[::-1])"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n+1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l) // 2]"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "return pow(2, n, p)"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiou\"\n    return \"\".join([char for char in text if char.lower() not in vowels])"}
{"idx": 52, "completion": "for x in l:\n        if x >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 0:\n        raise ValueError(\"Fibonacci index cannot be negative\")\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1) & set(l2))"}
{"idx": 59, "completion": "assert n > 1 and not is_prime(n)\n    for i in range(2, n):\n        if n % i == 0:\n            return largest_prime_factor(n // i)\n    return n"}
{"idx": 60, "completion": "if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n - 1)"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "res = []\n    for i in range(1, len(xs)):\n        res.append(xs[i] * i)\n    return res"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "x_str = str(x)\n    shift = shift % len(x_str)\n    return x_str[-shift:] + x_str[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string by spaces\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "# Initialize variables to store the smallest even value and its index\n    smallest_even_value = None\n    smallest_even_index = None\n    \n    # Iterate over the array to find the smallest even value and its index\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the value is even\n            if smallest_even_value is None or value < smallest_even_value:\n                smallest_even_value = value\n                smallest_even_index = index\n    \n    # If a smallest even value was found, return it with its index\n    if smallest_even_value is not None:\n        return [smallest_even_value, smallest_even_index]\n    else:\n        return []"}
{"idx": 69, "completion": "from collections import Counter\n    count = Counter(lst)\n    candidates = [num for num in count if count[num] >= num]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left = 0\n    right = len(sorted_lst) - 1\n    toggle = True\n    \n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    \n    return result"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "changes = 0\n    n = len(arr)\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        if is_prime(i):\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0 or a == 1:\n        return True\n    low = 0\n    high = a\n    while low <= high:\n        mid = (low + high) // 2\n        if mid ** 3 == a:\n            return True\n        elif mid ** 3 < a:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is in the set of prime digits\n        if char in prime_digits:\n            # If it is, increment the counter\n            prime_count += 1\n    \n    # Return the final count of prime digits\n    return prime_count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s)-2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))"}
{"idx": 83, "completion": "# The number of n-digit numbers that start with 1 is 9^(n-1)\n    # The number of n-digit numbers that end with 1 is 9^(n-1)\n    # The number of n-digit numbers that start and end with 1 is 9^(n-2)\n    # Therefore, the number of n-digit numbers that start or end with 1 is\n    # 9^(n-1) + 9^(n-1) - 9^(n-2)\n    return 2 * 9**(n-1) - 9**(n-2)"}
{"idx": 84, "completion": "# Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to a binary string\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "total = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            total += lst[i]\n    return total"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    # Sort by columns in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    sum_first_last = array[0] + array[-1]\n    sorted_array = sorted(array)\n    \n    if sum_first_last % 2 == 0:\n        return sorted_array[::-1]\n    else:\n        return sorted_array"}
{"idx": 89, "completion": "encrypted = ''\n    for char in s:\n        # Get the ASCII value of the character\n        ascii_val = ord(char)\n        # Shift the ASCII value down by 2 * 2 = 4 places\n        new_ascii_val = ascii_val + 4\n        # Handle wrap-around for lowercase letters\n        if new_ascii_val > ord('z'):\n            new_ascii_val -= 26\n        # Convert back to character and append to the result\n        encrypted += chr(new_ascii_val)\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst_sorted = sorted(lst)\n    smallest = lst_sorted[0]\n    for num in lst_sorted:\n        if num > smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith(\"I\"):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # Check if one of the numbers is equal to the sum of the other two\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False"}
{"idx": 93, "completion": "vowels = \"aeiou\"\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                # Find the index of the vowel in the vowels string\n                index = vowels.find(char.lower())\n                # Replace with the letter 2 places ahead in the alphabet\n                new_char = chr(((ord(char.lower()) - ord('a') + 2) % 26) + ord('a'))\n                # Swap the case of the new character\n                if char.isupper():\n                    new_char = new_char.upper()\n                else:\n                    new_char = new_char.lower()\n                encoded_message += new_char\n            else:\n                # Swap the case of the character\n                if char.isupper():\n                    encoded_message += char.lower()\n                else:\n                    encoded_message += char.upper()\n        else:\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) for key in keys):\n        if all(key.islower() for key in keys):\n            return True\n        elif all(key.isupper() for key in keys):\n            return True\n    return False"}
{"idx": 96, "completion": "if n <= 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Get the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 1\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "words = []\n    current_word = \"\"\n    for char in s:\n        if char == ' ' or char == ',':\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n        else:\n            current_word += char\n    if current_word:\n        words.append(current_word)\n    return words"}
{"idx": 102, "completion": "# Ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x\n\n    # Iterate from y down to x to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n\n    # If no even number is found, return -1\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2\n    if (n + m) % 2 != 0:\n        avg += 1\n    return bin(avg)"}
{"idx": 104, "completion": "def has_even_digit(number):\n        while number > 0:\n            digit = number % 10\n            if digit % 2 == 0:\n                return True\n            number //= 10\n        return False\n\n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()\n    return result"}
{"idx": 105, "completion": "# Filter out numbers not between 1 and 9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered numbers\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            sum_i = sum(range(1, i + 1))\n            result.append(sum_i)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            signed_digits = [-int(d) for d in str(num)]\n        else:\n            signed_digits = [int(d) for d in str(num)]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n    min_index = arr.index(min(arr))\n\n    for i in range(n):\n        if arr[(min_index + i) % n] != sorted_arr[i]:\n            return False\n\n    return True"}
{"idx": 110, "completion": "# Count the number of odd numbers in lst1\n    odd_count = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # If there are no odd numbers in lst1, it's already all even\n    if odd_count == 0:\n        return \"YES\"\n    \n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If lst2 has enough even numbers to replace all odd numbers in lst1\n    if even_count_lst2 >= odd_count:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if test == \"\":\n        return {}\n    \n    # Split the string into a list of words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Iterate over each letter in the word\n        for letter in word:\n            # If the letter is already in the dictionary, increment its count\n            if letter in letter_count:\n                letter_count[letter] += 1\n            # Otherwise, add the letter to the dictionary with a count of 1\n            else:\n                letter_count[letter] = 1\n    \n    # Find the maximum count of any letter\n    max_count = max(letter_count.values())\n    \n    # Create a dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate over the letter count dictionary\n    for letter, count in letter_count.items():\n        # If the count is equal to the maximum count, add the letter to the max_letters dictionary\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Remove all characters in s that are in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n\n    return min_sum"}
{"idx": 115, "completion": "total_buckets = 0\n    for row in grid:\n        # Count the number of 1's in the current row\n        water_units = row.count(1)\n        # Calculate the number of buckets needed for this row\n        buckets_needed = math.ceil(water_units / capacity)\n        # Add the buckets needed to the total count\n        total_buckets += buckets_needed\n    return total_buckets"}
{"idx": 116, "completion": "# First, we filter out any non-negative integers from the array\n    non_negative_arr = [num for num in arr if num >= 0]\n\n    # Define a helper function to count the number of ones in the binary representation of a number\n    def count_ones(num):\n        return bin(num).count('1')\n\n    # Sort the array based on the number of ones in the binary representation, and then by the decimal value\n    sorted_arr = sorted(non_negative_arr, key=lambda x: (count_ones(x), x))\n\n    return sorted_arr"}
{"idx": 117, "completion": "# Split the string into words\n    words = s.split()\n    \n    # Define a set of vowels for quick lookup\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each word\n    for word in words:\n        # Initialize a counter for consonants\n        consonant_count = 0\n        \n        # Iterate over each character in the word\n        for char in word:\n            # Check if the character is a consonant\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        \n        # If the consonant count matches n, add the word to the result list\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the vowel is between two consonants\n            if i > 0 and i < len(word) - 1:\n                if word[i - 1] in consonants and word[i + 1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    for a, b in [(s1, s2), (s2, s1)]:\n        combined = a + b\n        if is_good(combined):\n            return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    \n    # Select the top k elements from the sorted array\n    top_k = arr_sorted[-k:]\n    \n    # Return the top k elements in ascending order\n    return sorted(top_k)"}
{"idx": 121, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total"}
{"idx": 122, "completion": "sum = 0\n    for i in range(min(k, len(arr))):\n        if arr[i] < 100 and arr[i] > -100:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        if n % 2 == 1:\n            collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    odd_numbers = [num for num in collatz_sequence if num % 2 == 1]\n    return sorted(odd_numbers)"}
{"idx": 124, "completion": "import re\n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n    month, day, year = map(int, date.split('-'))\n    if month < 1 or month > 12:\n        return False\n    if day < 1:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day > 30:\n            return False\n    elif month == 2:\n        if day > 29:\n            return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if c.islower() and ord(c) % 2 == 1)"}
{"idx": 126, "completion": "if len(lst) != len(set(lst)):\n        return False\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., it's not empty)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals don't intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "def is_valid(x, y, n):\n        return 0 <= x < n and 0 <= y < n\n\n    n = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_path = None\n\n    for i in range(n):\n        for j in range(n):\n            queue = [(grid[i][j], i, j, [grid[i][j]])]\n            while queue:\n                current_value, x, y, path = queue.pop(0)\n                if len(path) == k:\n                    if min_path is None or path < min_path:\n                        min_path = path.copy()\n                    continue\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny, n):\n                        new_path = path + [grid[nx][ny]]\n                        queue.append((grid[nx][ny], nx, ny, new_path))\n\n    return min_path"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    \n    tribonacci = [1, 3]\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci.append(1 + i // 2)\n        else:\n            tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1])\n    \n    return tribonacci"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    if has_odd:\n        return product\n    else:\n        return 0"}
{"idx": 132, "completion": "# Initialize a counter to keep track of the number of nested brackets\n    nested_count = 0\n    \n    # Initialize a stack to keep track of the brackets\n    stack = []\n    \n    # Iterate over each character in the string\n    for char in string:\n        # If the character is an opening bracket, push it onto the stack\n        if char == '[':\n            stack.append(char)\n        # If the character is a closing bracket, pop from the stack\n        elif char == ']':\n            # If the stack is not empty, pop the last element\n            if stack:\n                stack.pop()\n                # Increment the nested count by 1\n                nested_count += 1\n            # If the stack is empty, push the closing bracket onto the stack\n            else:\n                stack.append(char)\n    \n    # If the nested count is greater than 0, return True\n    if nested_count > 0:\n        return True\n    # Otherwise, return False\n    else:\n        return False"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Square each element in the rounded list\n    squared_lst = [x**2 for x in rounded_lst]\n    \n    # Sum the squared elements\n    total_sum = sum(squared_lst)\n    \n    return total_sum"}
{"idx": 134, "completion": "if len(txt) == 0:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if len(txt) == 1:\n            return True\n        if txt[-2] == ' ':\n            return True\n    return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [num for num in lst if num < 0]\n    positive_integers = [num for num in lst if num > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Normalize the input to handle different representations\n    def normalize(value):\n        if isinstance(value, str):\n            return float(value.replace(',', '.'))\n        return float(value)\n    \n    # Normalize both inputs\n    a_norm = normalize(a)\n    b_norm = normalize(b)\n    \n    # Compare the normalized values\n    if a_norm > b_norm:\n        return a\n    elif b_norm > a_norm:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "# If n is less than 8, it cannot be written as the sum of 4 positive even numbers\n    if n < 8:\n        return False\n    # If n is divisible by 2, it can be written as the sum of 4 positive even numbers\n    if n % 2 == 0:\n        return True\n    return False"}
{"idx": 139, "completion": "factorial = 1\n    for i in range(1, n + 1):\n        factorial *= math.factorial(i)\n    return factorial"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub(r'_{3,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the extension is valid\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # Check if the name starts with a letter\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Count the number of digits in the name\n    digit_count = sum(1 for char in name if char.isdigit())\n    \n    # Check if there are more than three digits\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the fractions into numerator and denominator\n    x_num, x_den = x.split('/')\n    n_num, n_den = n.split('/')\n    \n    # Convert the strings to integers\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n    \n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(num)\n            first_digit = num_str[0]\n            last_digit = num_str[-1]\n            if first_digit in ['1', '3', '5', '7', '9'] and last_digit in ['1', '3', '5', '7', '9']:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start > end:\n        start, end = end, start\n    return tuple(planets[start+1:end])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if n > 1:\n        for i in range(2, int(n/2)+1):\n            if (n % i) == 0:\n                return y\n        else:\n            return x\n    else:\n        return y"}
{"idx": 151, "completion": "sum_of_squares = 0\n    for number in lst:\n        if isinstance(number, int) and number > 0 and number % 2 != 0:\n            sum_of_squares += number ** 2\n    return sum_of_squares"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# First, we need to check if the triangle inequality theorem holds.\n    # The theorem states that the sum of the lengths of any two sides of a triangle\n    # must be greater than the length of the remaining side.\n    if (a + b > c) and (a + c > b) and (b + c > a):\n        # If the triangle inequality theorem holds, we then check if the triangle is right-angled.\n        # A triangle is right-angled if the square of the length of the longest side is equal to\n        # the sum of squares of the lengths of the other two sides.\n        sides = [a, b, c]\n        sides.sort()\n        return sides[2]**2 == sides[0]**2 + sides[1]**2\n    else:\n        # If the triangle inequality theorem does not hold, it's not a valid triangle.\n        return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "even_digits = []\n    for num in range(min(a, b), max(a, b) + 1):\n        if all(digit in '02468' for digit in str(num)):\n            even_digits.append(num)\n    return even_digits"}
{"idx": 0, "completion": "for i, number in enumerate(numbers):\n        for j in range(i + 1, len(numbers)):\n            if abs(number - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(' ', '')\n    result = []\n    current = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current.append(char)\n\n        if depth == 0:\n            result.append(''.join(current))\n            current = []\n\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)"}
{"idx": 5, "completion": "if len(numbers) == 0:\n        return []\n    else:\n        return [j for i in zip(numbers, [delimeter] * len(numbers)) for j in i][:-1]"}
{"idx": 6, "completion": "# Split the input string into groups of parentheses\n    paren_groups = paren_string.split()\n    \n    # Initialize a list to store the maximum nesting levels for each group\n    max_nesting_levels = []\n    \n    # Iterate over each group of parentheses\n    for group in paren_groups:\n        max_depth = 0\n        current_depth = 0\n        \n        # Iterate over each character in the group\n        for char in group:\n            if char == '(':\n                # Increment the current depth when an opening parenthesis is encountered\n                current_depth += 1\n                # Update the maximum depth if the current depth exceeds it\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                # Decrement the current depth when a closing parenthesis is encountered\n                current_depth -= 1\n        \n        # Append the maximum depth of the current group to the list\n        max_nesting_levels.append(max_depth)\n    \n    return max_nesting_levels"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_result = sum(numbers)\n    product_result = 1\n    for number in numbers:\n        product_result *= number\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "if a == 0 or b == 0:\n        return 0\n    if a == b:\n        return a\n    if a > b:\n        return greatest_common_divisor(a - b, b)\n    return greatest_common_divisor(a, b - a)"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_durations = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n\n    notes = music_string.split()\n    return [note_durations[note] for note in notes]"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    count = 0\n    i = 0\n    while i <= len(string) - len(substring):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n            i += len(substring) - 1\n        else:\n            i += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "# Sort the list to ensure the numbers are in order\n    sorted_numbers = sorted(numbers)\n    \n    # Initialize variables to store the closest pair and the minimum difference found\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n    \n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n    \n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "# The function is guaranteed to have a solution, so we can use the\n    # Intermediate Value Theorem to find it. We'll use binary search to find\n    # the root.\n\n    # First, we need to find an interval [a, b] such that f(a) and f(b) have\n    # opposite signs. We'll start with a = -1 and b = 1, and we'll double the\n    # interval size until we find such an interval.\n    a = -1\n    b = 1\n    while poly(xs, a) * poly(xs, b) > 0:\n        a *= 2\n        b *= 2\n\n    # Now we can use binary search to find the root.\n    while b - a > 1e-6:\n        m = (a + b) / 2\n        if poly(xs, m) * poly(xs, a) > 0:\n            a = m\n        else:\n            b = m\n\n    return (a + b) / 2"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_num = l[0]\n    for num in l:\n        if num > max_num:\n            max_num = num\n    return max_num"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices_sorted = sorted(even_indices)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices_sorted[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements back in each group. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[0:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        for i in range(3, int(x**0.5)+1, 2):\n            if x % i == 0:\n                return False\n        return True\n\n    def fib():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    fib_gen = fib()\n    count = 0\n    for f in fib_gen:\n        if is_prime(f):\n            count += 1\n            if count == n:\n                return f"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return \"0\"\n    remainders = \"\"\n    while x > 0:\n        remainders = str(x % base) + remainders\n        x //= base\n    return remainders"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "if n == 0:\n        return 1\n    return pow(2, n, p)"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "return ''.join([char for char in text if char.lower() not in 'aeiou'])"}
{"idx": 52, "completion": "for i in l:\n        if i >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1) & set(l2))"}
{"idx": 59, "completion": "assert n > 1\n    assert not is_prime(n)\n    return max(prime_factors(n))"}
{"idx": 60, "completion": "return sum(range(1, n + 1))"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "x_str = str(x)\n    shift = shift % len(x_str)\n    return x_str[-shift:] + x_str[:-shift]"}
{"idx": 66, "completion": "total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n    return total"}
{"idx": 67, "completion": "# Split the string by spaces\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if min_even is None or value < min_even:\n                min_even = value\n                min_index = index\n    \n    if min_even is None:\n        return []\n    \n    return [min_even, min_index]"}
{"idx": 69, "completion": "freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    \n    candidates = [num for num, count in freq.items() if count >= num]\n    \n    if candidates:\n        return max(candidates)\n    else:\n        return -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    return result"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    return round(a ** (1/3)) ** 3 == a"}
{"idx": 78, "completion": "# Define the prime digits in hexadecimal\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime digit\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary_representation = bin(decimal)[2:]\n    return f\"db{binary_representation}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    else:\n        return 19 * (10 ** (n - 2))"}
{"idx": 84, "completion": "digit_sum = sum(int(digit) for digit in str(N))\n    return bin(digit_sum)[2:]"}
{"idx": 85, "completion": "return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    # Sort by columns in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted = ''\n    for char in s:\n        # Shift each character down by 2 * 2 = 4 places\n        encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        encrypted += encrypted_char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    \n    smallest = float('inf')\n    second_smallest = float('inf')\n    \n    for num in lst:\n        if num < smallest:\n            second_smallest = smallest\n            smallest = num\n        elif num < second_smallest and num != smallest:\n            second_smallest = num\n    \n    if second_smallest == float('inf'):\n        return None\n    else:\n        return second_smallest"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    \n    return False"}
{"idx": 93, "completion": "vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char.lower() in vowels:\n            encoded_message += vowels[char.lower()] if char.islower() else vowels[char.lower()].upper()\n        else:\n            encoded_message += char.swapcase()\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    digit_sum = sum(int(digit) for digit in str(max_prime))\n    return digit_sum"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current_level = n\n    while current_level > 0:\n        stones.append(current_level)\n        if current_level % 2 == 0:\n            current_level += 2\n        else:\n            current_level += 2\n    return stones"}
{"idx": 101, "completion": "import re\n    return re.split('[ ,]+', s)"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = round((n + m) / 2)\n    return bin(avg)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        if all(int(digit) % 2 != 0 for digit in str(num)):\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Calculate factorial for even indices\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum of numbers from 1 to i for odd indices\n            total = sum(range(1, i + 1))\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        sum_of_digits = 0\n        for digit in str(num):\n            if digit == '-':\n                continue\n            sum_of_digits += int(digit)\n        if sum_of_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n    min_index = arr.index(min(arr))\n\n    for i in range(n):\n        if arr[(min_index + i) % n] != sorted_arr[i]:\n            return False\n\n    return True"}
{"idx": 110, "completion": "# Check if lst1 already contains only even numbers\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if lst2 contains at least as many even numbers as odd numbers in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    counts = {}\n    for letter in test.split():\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n    \n    max_count = max(counts.values())\n    histogram_dict = {k: v for k, v in counts.items() if v == max_count}\n    \n    return histogram_dict"}
{"idx": 112, "completion": "# Remove all characters in s that are in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the number of times we need to lower the buckets\n    times = 0\n\n    # Iterate over each well in the grid\n    for well in grid:\n        # Count the number of units of water in the well\n        water_units = well.count(1)\n\n        # If there are water units in the well, calculate how many times we need to lower the bucket\n        if water_units > 0:\n            # The number of times we need to lower the bucket is the ceiling of the water units divided by the bucket capacity\n            times += math.ceil(water_units / capacity)\n\n    return times"}
{"idx": 116, "completion": "# Define a helper function to count the number of 1's in the binary representation\n    def count_ones(n):\n        return bin(n).count('1')\n    \n    # Sort the array based on the number of 1's in binary, and then by the decimal value\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n    \n    return sorted_arr"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    words = s.split()\n    result = []\n    for word in words:\n        consonant_count = sum(1 for char in word if char not in vowels and char.isalpha())\n        if consonant_count == n:\n            result.append(word)\n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the vowel is between two consonants\n            if i > 0 and i < len(word) - 1:\n                if word[i-1] in consonants and word[i+1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Take the last k elements which are the largest\n    max_k = sorted_arr[-k:]\n    \n    return max_k"}
{"idx": 121, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total"}
{"idx": 122, "completion": "# Initialize a variable to store the sum\n    total_sum = 0\n\n    # Iterate over the first k elements of the array\n    for i in range(min(k, len(arr))):\n        # Check if the current element has at most two digits\n        if arr[i] < 100 and arr[i] > -100:\n            # If it does, add it to the total sum\n            total_sum += arr[i]\n\n    # Return the total sum\n    return total_sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "import re\n    from datetime import datetime\n\n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n\n    try:\n        datetime.strptime(date, '%m-%d-%Y')\n    except ValueError:\n        return False\n\n    month, day, year = map(int, date.split('-'))\n\n    if month < 1 or month > 12:\n        return False\n\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        return 1 <= day <= 31\n    elif month in [4, 6, 9, 11]:\n        return 1 <= day <= 30\n    elif month == 2:\n        return 1 <= day <= 29\n\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if c.islower() and ord(c) % 2 != 0)"}
{"idx": 126, "completion": "if len(lst) <= 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n        if lst[i] == lst[i + 1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., it's not empty)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals don't intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    \n    product_of_signs = 1\n    sum_of_magnitudes = 0\n    \n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n    \n    return sum_of_magnitudes * product_of_signs"}
{"idx": 129, "completion": "import heapq\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_heap = []\n\n    # Initialize the heap with all possible starting points\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(min_heap, (grid[i][j], [(i, j)], i, j))\n\n    while min_heap:\n        current_value, path, x, y = heapq.heappop(min_heap)\n        if len(path) == k:\n            return [grid[i][j] for i, j in path]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in path:\n                new_path = path + [(nx, ny)]\n                heapq.heappush(min_heap, (grid[nx][ny], new_path, nx, ny))\n\n    return []"}
{"idx": 130, "completion": "# Initialize the list with the first two known values\n    tribonacci_sequence = [1, 3]\n    \n    # If n is 0, return the first element\n    if n == 0:\n        return tribonacci_sequence[:1]\n    \n    # If n is 1, return the first two elements\n    if n == 1:\n        return tribonacci_sequence[:2]\n    \n    # Generate the sequence up to n\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            # If i is even, calculate the value directly\n            tribonacci_sequence.append(1 + i // 2)\n        else:\n            # If i is odd, use the recursive formula\n            tribonacci_sequence.append(tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i + 1])\n    \n    return tribonacci_sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "# Initialize a counter to keep track of the number of open brackets\n    open_brackets = 0\n    # Initialize a flag to indicate if we have seen a nested bracket\n    nested = False\n\n    # Iterate over each character in the string\n    for char in string:\n        if char == '[':\n            # Increment the open brackets counter\n            open_brackets += 1\n        elif char == ']':\n            # Decrement the open brackets counter\n            open_brackets -= 1\n            # If there was an open bracket before this close bracket, it means we have a nesting\n            if open_brackets > 0:\n                nested = True\n        # If at any point the open brackets counter is negative, it means the brackets are not balanced\n        if open_brackets < 0:\n            return False\n\n    # After the loop, if the open brackets counter is not zero, it means the brackets are not balanced\n    if open_brackets != 0:\n        return False\n\n    # Return the flag indicating if we have seen a nested bracket\n    return nested"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x**2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if len(txt) == 0:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if len(txt) == 1:\n            return True\n        if txt[-2] == ' ':\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [num for num in lst if num < 0]\n    positive_integers = [num for num in lst if num > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Normalize the input to handle different representations\n    def normalize(value):\n        if isinstance(value, str):\n            return float(value.replace(',', '.'))\n        return float(value)\n    \n    # Normalize both inputs\n    a_norm = normalize(a)\n    b_norm = normalize(b)\n    \n    # Compare the normalized values\n    if a_norm > b_norm:\n        return a\n    elif b_norm > a_norm:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 == 0:\n        return True\n    return False"}
{"idx": 139, "completion": "# Calculate the factorial of a number\n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        else:\n            return x * factorial(x - 1)\n\n    # Calculate the Brazilian factorial\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub(r'_{3,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name starts with a latin alphapet letter\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Check if there are not more than three digits in the name\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = x.split('/')\n    n_num, n_den = n.split('/')\n    \n    # Convert the numerator and denominator to integers\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n    \n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    # Create a list of tuples (number, sum_of_digits, original_index)\n    num_info = []\n    for idx, num in enumerate(nums):\n        abs_num = abs(num)\n        digit_sum = sum(int(d) for d in str(abs_num))\n        num_info.append((num, digit_sum, idx))\n\n    # Sort the list based on the sum of digits and original index\n    num_info_sorted = sorted(num_info, key=lambda x: (x[1], x[2]))\n\n    # Extract the sorted numbers\n    sorted_nums = [num for num, _, _ in num_info_sorted]\n\n    return sorted_nums"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start < end:\n        return tuple(planets[start+1:end])\n    else:\n        return tuple(planets[end+1:start])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if is_prime(n):\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "sum_of_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            sum_of_squares += num ** 2\n    return sum_of_squares"}
{"idx": 152, "completion": "return [abs(game[i] - guess[i]) if game[i] != guess[i] else 0 for i in range(len(game))]"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# First, we need to check if the given sides can form a triangle.\n    # The sum of the lengths of any two sides must be greater than the length of the remaining side.\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # To determine if the triangle is right-angled, we can use the Pythagorean theorem.\n    # The theorem states that in a right-angled triangle, the square of the length of the hypotenuse\n    # (the longest side) is equal to the sum of squares of the other two sides.\n    # We'll check all three combinations to see if any of them satisfy the Pythagorean theorem.\n    sides = [a, b, c]\n    sides.sort()\n    \n    # After sorting, sides[0] is the smallest, sides[1] is the middle, and sides[2] is the largest.\n    # We'll check if the square of the largest side is equal to the sum of squares of the other two sides.\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "# Initialize the expression with the first operand\n    expression = str(operand[0])\n    \n    # Iterate over the operator and operand lists to build the expression\n    for i in range(1, len(operand)):\n        expression += operator[i-1] + str(operand[i])\n    \n    # Evaluate the expression and return the result\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join(c.swapcase() if c.isalpha() else c for c in s)"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(d) % 2 == 0 for d in str(i))]"}
{"idx": 0, "completion": "for i, number in enumerate(numbers):\n        for j in range(i + 1, len(numbers)):\n            if abs(number - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current_group = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current_group.append(char)\n\n        if depth == 0:\n            result.append(''.join(current_group))\n            current_group = []\n\n    return result"}
{"idx": 2, "completion": "return number % 1"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "result = []\n    for i, number in enumerate(numbers):\n        result.append(number)\n        if i < len(numbers) - 1:\n            result.append(delimeter)\n    return result"}
{"idx": 6, "completion": "# Split the input string into individual groups\n    groups = paren_string.split()\n\n    # Initialize a list to store the maximum nesting levels for each group\n    max_nesting_levels = []\n\n    # Iterate over each group\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n\n        # Iterate over each character in the group\n        for char in group:\n            if char == '(':\n                # Increase the current depth when encountering an opening parenthesis\n                current_depth += 1\n                # Update the maximum depth if the current depth exceeds it\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                # Decrease the current depth when encountering a closing parenthesis\n                current_depth -= 1\n\n        # Append the maximum depth of the current group to the list\n        max_nesting_levels.append(max_depth)\n\n    return max_nesting_levels"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "sum_result = sum(numbers)\n    product_result = 1\n    for number in numbers:\n        product_result *= number\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "assert len(a) == len(b)\n    return ''.join('0' if a[i] == b[i] else '1' for i in range(len(a)))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_durations = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    notes = music_string.split()\n    return [note_durations[note] for note in notes]"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    return sum(1 for i in range(len(string)) if string.startswith(substring, i))"}
{"idx": 19, "completion": "number_dict = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list.sort(key=lambda x: number_dict[x])\n    return ' '.join(numbers_list)"}
{"idx": 20, "completion": "# Sort the list to make it easier to find the closest elements\n    sorted_numbers = sorted(numbers)\n\n    # Initialize variables to store the closest pair and the minimum difference\n    closest_pair = (sorted_numbers[0], sorted_numbers[1])\n    min_diff = abs(sorted_numbers[0] - sorted_numbers[1])\n\n    # Iterate through the sorted list to find the closest pair\n    for i in range(len(sorted_numbers) - 1):\n        diff = abs(sorted_numbers[i] - sorted_numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (sorted_numbers[i], sorted_numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "if not numbers:\n        return []\n    if len(numbers) < 2:\n        return numbers\n    min_num = min(numbers)\n    max_num = max(numbers)\n    if min_num == max_num:\n        return [0.0] * len(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "def f(x):\n        return poly(xs, x)\n\n    # The idea is to find the interval where the function changes sign.\n    # Once we have that, we can use the bisection method to find the root.\n    # We start with the interval [-1, 1] and double the interval size until we find a sign change.\n    a = -1\n    b = 1\n    while f(a) * f(b) > 0:\n        a *= 2\n        b *= 2\n\n    # Now we have an interval [a, b] where f(a) and f(b) have opposite signs.\n    # We can use the bisection method to find the root.\n    while b - a > 1e-10:\n        c = (a + b) / 2\n        if f(c) == 0:\n            return c\n        if f(a) * f(c) < 0:\n            b = c\n        else:\n            a = c\n\n    return (a + b) / 2"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i+2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices.sort()\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    fib_seq = [0, 1]\n    count = 0\n    while count < n:\n        next_fib = fib_seq[-1] + fib_seq[-2]\n        fib_seq.append(next_fib)\n        if is_prime(next_fib):\n            count += 1\n    return fib_seq[-2]"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return \"0\"\n    result = \"\"\n    while x > 0:\n        result = str(x % base) + result\n        x //= base\n    return result"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n+1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "return pow(2, n, p)"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])"}
{"idx": 52, "completion": "for i in l:\n        if i >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 0:\n        raise ValueError(\"Fibonacci index cannot be negative.\")\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1) & set(l2))"}
{"idx": 59, "completion": "# Start with the smallest prime factor\n    factor = 2\n    while factor * factor <= n:\n        if n % factor == 0:\n            # Divide n by the factor as long as it is divisible\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    return n if n > 1 else factor - 1"}
{"idx": 60, "completion": "sum = 0\n    for i in range(1, n + 1):\n        sum += i\n    return sum"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n+1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "x_str = str(x)\n    shift = shift % len(x_str)\n    return x_str[-shift:] + x_str[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into parts\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if min_even is None or value < min_even:\n                min_even = value\n                min_index = index\n    \n    if min_even is None:\n        return []\n    \n    return [min_even, min_index]"}
{"idx": 69, "completion": "from collections import Counter\n    count = Counter(lst)\n    candidates = [x for x in count if x <= count[x]]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left, right = 0, len(sorted_lst) - 1\n    toggle = True\n    \n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    \n    return result"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-(i + 1)]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0:\n        return True\n    for i in range(1, int(a ** (1/3)) + 2):\n        if i ** 3 == a:\n            return True\n    return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate over each character in the input string\n    for char in num:\n        # If the character is a prime digit, increment the counter\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))"}
{"idx": 83, "completion": "# The number of n-digit numbers that start with 1 is 9^(n-1)\n    # The number of n-digit numbers that end with 1 is 9^(n-1)\n    # The number of n-digit numbers that start and end with 1 is 9^(n-2)\n    # So the total number of n-digit numbers that start or end with 1 is\n    # 9^(n-1) + 9^(n-1) - 9^(n-2)\n    return 2 * (9 ** (n - 1)) - (9 ** (n - 2))"}
{"idx": 84, "completion": "# Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order, and by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted_string = \"\"\n    for char in s:\n        # Get the ASCII value of the character\n        ascii_value = ord(char)\n        # Shift the ASCII value down by (2 * 2) = 4 places\n        new_ascii_value = ascii_value + 4\n        # Handle wrap-around for lowercase letters\n        if new_ascii_value > ord('z'):\n            new_ascii_value -= 26\n        # Convert the new ASCII value back to a character\n        new_char = chr(new_ascii_value)\n        # Append the new character to the encrypted string\n        encrypted_string += new_char\n    return encrypted_string"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst_sorted = sorted(lst)\n    smallest = lst_sorted[0]\n    for num in lst_sorted:\n        if num > smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "if not all(isinstance(num, int) for num in [x, y, z]):\n        return False\n    \n    numbers = [x, y, z]\n    for num in numbers:\n        if num == sum(numbers) - num:\n            return True\n    return False"}
{"idx": 93, "completion": "vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                encoded_char = vowels[char.lower()]\n                if char.isupper():\n                    encoded_char = encoded_char.upper()\n                encoded_message += encoded_char\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    sum_digits = sum(int(digit) for digit in str(max_prime))\n    return sum_digits"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n    \n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    return unit_a * unit_b"}
{"idx": 98, "completion": "count = 0\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "words = []\n    current_word = \"\"\n    for char in s:\n        if char == \" \" or char == \",\":\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n        else:\n            current_word += char\n    if current_word:\n        words.append(current_word)\n    return words"}
{"idx": 102, "completion": "# Ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x\n\n    # Iterate from y down to x to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n\n    # If no even number is found, return -1\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2\n    if (n + m) % 2 != 0:\n        avg += 1\n    return bin(avg)"}
{"idx": 104, "completion": "def has_even_digit(num):\n        while num > 0:\n            digit = num % 10\n            if digit % 2 == 0:\n                return True\n            num = num // 10\n        return False\n\n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()\n    return result"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Calculate the factorial of i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate the sum of numbers from 1 to i\n            total = sum(range(1, i + 1))\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if sum(map(int, str(abs(num)))) > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n    min_index = arr.index(min(arr))\n\n    for i in range(n):\n        if arr[(min_index + i) % n] != sorted_arr[i]:\n            return False\n    return True"}
{"idx": 110, "completion": "# Count the number of odd numbers in lst1\n    odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If the number of odd numbers in lst1 is less than or equal to the number of even numbers in lst2,\n    # it is possible to exchange elements to make lst1 all even.\n    if odd_count_lst1 <= even_count_lst2:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    # Split the string into a list of words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Iterate over each letter in the word\n        for letter in word:\n            # If the letter is already in the dictionary, increment its count\n            if letter in letter_count:\n                letter_count[letter] += 1\n            # If the letter is not in the dictionary, add it with a count of 1\n            else:\n                letter_count[letter] = 1\n    \n    # Find the maximum count of any letter\n    max_count = max(letter_count.values()) if letter_count else 0\n    \n    # Create a dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate over the letter count dictionary\n    for letter, count in letter_count.items():\n        # If the count is equal to the maximum count, add the letter to the max_letters dictionary\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Step 1: Remove characters from s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    return (result_string, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the number of times we need to lower the buckets\n    times = 0\n\n    # Iterate over each well in the grid\n    for well in grid:\n        # Count the number of units of water in the current well\n        water_units = well.count(1)\n\n        # If there are water units in the well, calculate how many times we need to lower the bucket\n        if water_units > 0:\n            # The number of times we need to lower the bucket is the ceiling of the water units divided by the bucket capacity\n            times += math.ceil(water_units / capacity)\n\n    return times"}
{"idx": 116, "completion": "# Check if the array contains only non-negative integers\n    if any(x < 0 for x in arr):\n        return sorted(arr, reverse=True)\n    \n    # Sort the array based on the number of ones in their binary representation\n    # and then by their decimal value\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    for word in s.split():\n        consonant_count = sum(1 for char in word if char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    word_length = len(word)\n    \n    for i in range(word_length - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the character before and after the vowel are consonants\n            if i > 0 and word[i - 1] in consonants:\n                if i < word_length - 1 and word[i + 1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    \n    # Select the last k elements which are the largest\n    max_k = arr_sorted[-k:]\n    \n    # Return the sorted list of the maximum k numbers\n    return max_k"}
{"idx": 121, "completion": "total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total"}
{"idx": 122, "completion": "# Initialize sum to 0\n    sum = 0\n    \n    # Iterate over the first k elements of the array\n    for i in range(min(k, len(arr))):\n        # Check if the current element has at most two digits\n        if arr[i] < 100 and arr[i] > -100:\n            # Add the element to the sum\n            sum += arr[i]\n    \n    # Return the sum\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "# Check if the date string is not empty\n    if not date:\n        return False\n    \n    # Check if the date format is mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    odd_count += 1\n        return odd_count"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n        if lst[i] == lst[i + 1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., it's not empty)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals don't intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    \n    product_of_signs = 1\n    sum_of_magnitudes = 0\n    \n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n    \n    return sum_of_magnitudes * product_of_signs"}
{"idx": 129, "completion": "import heapq\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize a priority queue with all starting positions\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], i, j, [grid[i][j]]))\n\n    # Perform BFS with priority queue\n    while pq:\n        current_val, x, y, path = heapq.heappop(pq)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(pq, (new_path[0], nx, ny, new_path))\n\n    return []"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    \n    tribonacci_sequence = [1, 3]\n    \n    if n == 0:\n        return tribonacci_sequence\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci_sequence.append(1 + i // 2)\n        else:\n            tribonacci_sequence.append(tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i + 1])\n    \n    return tribonacci_sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if len(txt) == 0:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        words = txt.split()\n        if len(words) == 0:\n            return False\n        last_word = words[-1]\n        if last_char == last_word[-1]:\n            return False\n        else:\n            return True\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [num for num in lst if num < 0]\n    positive_integers = [num for num in lst if num > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Normalize the input to handle different representations\n    def normalize(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                value = float(value)\n            except ValueError:\n                return value\n        return value\n\n    a_norm = normalize(a)\n    b_norm = normalize(b)\n\n    # Compare the normalized values\n    if a_norm > b_norm:\n        return a\n    elif b_norm > a_norm:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "# Since we are looking for the sum of exactly 4 positive even numbers,\n    # the smallest possible sum is 2 + 2 + 2 + 2 = 8.\n    # Therefore, if n < 8, it's impossible to express n as the sum of 4 positive even numbers.\n    if n < 8:\n        return False\n    \n    # If n is even, we can always express it as the sum of 4 positive even numbers.\n    # For example, if n is 8, we can write it as 2 + 2 + 2 + 2.\n    # If n is greater than 8, we can write it as 2 + 2 + 2 + (n-6), where (n-6) is even.\n    # If n is odd, it's impossible to express it as the sum of 4 even numbers because the sum of 4 even numbers is always even.\n    return n % 2 == 0"}
{"idx": 139, "completion": "# Calculate the factorial of a number\n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        else:\n            return x * factorial(x - 1)\n\n    # Calculate the special factorial\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub('_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name starts with a letter from the latin alphabet\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Check if there are more than three digits in the name\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = x.split('/')\n    n_num, n_den = n.split('/')\n\n    # Convert the numerator and denominator to integers\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n\n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n\n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start < end:\n        return tuple(planets[start+1:end])\n    else:\n        return tuple(planets[end+1:start])"}
{"idx": 149, "completion": "# Delete strings with odd lengths from the list\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if n > 1:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return y\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "return sum(num ** 2 for num in lst if isinstance(num, int) and num > 0 and num % 2 != 0)"}
{"idx": 152, "completion": "# Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate over the scores and guesses\n    for score, guess in zip(game, guess):\n        # If the guess is correct, append 0 to the differences list\n        if score == guess:\n            differences.append(0)\n        # Otherwise, append the absolute difference\n        else:\n            differences.append(abs(score - guess))\n    \n    # Return the list of differences\n    return differences"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "# Define the Roman numeral symbols and their corresponding values\n    roman_numerals = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n\n    # Initialize an empty string to store the Roman numeral\n    roman_numeral = ''\n\n    # Iterate over the Roman numeral symbols\n    for value, symbol in roman_numerals:\n        # While the number is greater than or equal to the current value\n        while number >= value:\n            # Append the corresponding symbol to the Roman numeral string\n            roman_numeral += symbol\n            # Subtract the value from the number\n            number -= value\n\n    # Return the Roman numeral string in lowercase\n    return roman_numeral"}
{"idx": 157, "completion": "# First, we need to check if the given lengths can form a triangle.\n    # The triangle inequality theorem states that the sum of the lengths of any two sides\n    # must be greater than the length of the remaining side.\n    if a + b > c and a + c > b and b + c > a:\n        # If the triangle inequality holds, we then check if it's a right-angled triangle.\n        # A triangle is right-angled if it satisfies the Pythagorean theorem.\n        # The Pythagorean theorem states that in a right-angled triangle, the square of the\n        # length of the hypotenuse (the side opposite the right angle) is equal to the sum\n        # of squares of the lengths of the other two sides.\n        # To check this, we first identify the hypotenuse, which is the longest side.\n        sides = [a, b, c]\n        hypotenuse = max(sides)\n        sides.remove(hypotenuse)\n        # Now we apply the Pythagorean theorem.\n        if hypotenuse**2 == sides[0]**2 + sides[1]**2:\n            return True\n        else:\n            return False\n    else:\n        # If the triangle inequality doesn't hold, the sides cannot form a triangle.\n        return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(d)%2 == 0 for d in str(i))]"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n\n        current.append(char)\n\n        if depth == 0:\n            result.append(''.join(current))\n            current = []\n\n    return result"}
{"idx": 2, "completion": "return number % 1"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result"}
{"idx": 6, "completion": "results = []\n    for group in paren_string.split():\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        results.append(max_depth)\n    return results"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "sum_result = 0\n    product_result = 1\n\n    for number in numbers:\n        sum_result += number\n        product_result *= number\n\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for number in numbers:\n        if current_max is None or number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(c1) ^ int(c2)) for c1, c2 in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "if b == 0:\n        return a\n    return greatest_common_divisor(b, a % b)"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "# Create a dictionary to map each note representation to its corresponding beat count\n    note_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the input string into individual note representations\n    notes = music_string.split()\n    \n    # Convert each note representation to its corresponding beat count\n    beats = [note_beats[note] for note in notes]\n    \n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string)):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    numbers.sort()\n    min_distance = float('inf')\n    closest_pair = (numbers[0], numbers[1])\n\n    for i in range(len(numbers) - 1):\n        distance = abs(numbers[i] - numbers[i + 1])\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "if len(numbers) < 2:\n        raise ValueError(\"List must contain at least two elements\")\n    \n    min_val = min(numbers)\n    max_val = max(numbers)\n    \n    if min_val == max_val:\n        raise ValueError(\"All elements in the list must be distinct\")\n    \n    rescaled = [(x - min_val) / (max_val - min_val) for x in numbers]\n    return rescaled"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [string for string in strings if string.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n ** 0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "if len(xs) % 2 == 1:\n        raise ValueError(\"xs must have even number of coefficients\")\n    if xs[-1] < 0:\n        xs = [-x for x in xs]\n    a = xs[0]\n    b = xs[-1]\n    return -math.pow(a / b, 1 / (len(xs) - 1))"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "# Extract the even-indexed elements and sort them\n    even_indices = l[::2]\n    sorted_even_indices = sorted(even_indices)\n\n    # Create a new list with sorted even-indexed elements and original odd-indexed elements\n    sorted_list = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            sorted_list.append(sorted_even_indices[i // 2])\n        else:\n            sorted_list.append(l[i])\n\n    return sorted_list"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    fib_seq = [0, 1]\n    count = 0\n    while count < n:\n        next_fib = fib_seq[-1] + fib_seq[-2]\n        fib_seq.append(next_fib)\n        if is_prime(next_fib):\n            count += 1\n    return fib_seq[-2]"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "assert base < 10\n    if x == 0:\n        return \"0\"\n    result = \"\"\n    while x > 0:\n        result = str(x % base) + result\n        x //= base\n    return result"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    else:\n        return (2 * modp(n - 1, p)) % p"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "if l[0] < l[-1]:\n        return all(x <= y for x, y in zip(l, l[1:]))\n    else:\n        return all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1).intersection(set(l2)))"}
{"idx": 59, "completion": "if is_prime(n):\n        return n\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return max(i, largest_prime_factor(n // i))"}
{"idx": 60, "completion": "return sum(range(n+1))"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "digits = str(x)\n    shift = shift % len(digits)\n    return digits[-shift:] + digits[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string by spaces\n    parts = s.split()\n    \n    # Extract the number of apples\n    apples = int(parts[0])\n    \n    # Extract the number of oranges\n    oranges = int(parts[2])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "# Initialize variables to store the smallest even value and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even value and its index\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the value is even\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    # If a smallest even value was found, return it with its index\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []"}
{"idx": 69, "completion": "frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n\n    candidates = []\n    for num, freq in frequency.items():\n        if freq >= num:\n            candidates.append(num)\n\n    if candidates:\n        return max(candidates)\n    else:\n        return -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    left, right = 0, len(sorted_lst) - 1\n    toggle = True\n    \n    while left <= right:\n        if toggle:\n            result.append(sorted_lst[left])\n            left += 1\n        else:\n            result.append(sorted_lst[right])\n            right -= 1\n        toggle = not toggle\n    \n    return result"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-(i + 1)]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0:\n        return True\n    for i in range(1, int(a ** (1/3)) + 2):\n        if i ** 3 == a:\n            return True\n    return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime digit\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "# Convert the decimal number to binary\n    binary = bin(decimal)[2:]\n    # Add the 'db' characters to the beginning and end of the binary string\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length == 1:\n        return False\n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "# If n is 1, then the only number is 1, which starts with 1 and ends with 1.\n    if n == 1:\n        return 1\n    # If n is greater than 1, then the count of numbers that start with 1 is 9^(n-1)\n    # and the count of numbers that end with 1 is 9^(n-1).\n    # However, we have to subtract the count of numbers that start and end with 1,\n    # which is 9^(n-2).\n    return 2 * (9 ** (n - 1)) - (9 ** (n - 2))"}
{"idx": 84, "completion": "# Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum([lst[i] for i in range(len(lst)) if lst[i] % 2 == 0 and i % 2 != 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order, and by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    if len(array) == 1:\n        return array\n    \n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted = ''\n    for char in s:\n        if char.isalpha():\n            shift = (ord(char.lower()) - ord('a') + 2 * 2) % 26\n            encrypted += chr(ord('a') + shift)\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    sorted_lst = sorted(lst)\n    smallest = sorted_lst[0]\n    for num in sorted_lst:\n        if num > smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    return x == y + z or y == x + z or z == x + y"}
{"idx": 93, "completion": "vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                encoded_char = vowels[char.lower()]\n                if char.isupper():\n                    encoded_char = encoded_char.upper()\n                encoded_message += encoded_char\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_prime = -1\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n\n    if largest_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(largest_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n    primes = []\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "# Split the string by both commas and spaces\n    words = s.replace(',', ' ').split()\n    return words"}
{"idx": 102, "completion": "# Ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x\n\n    # Iterate from y down to x to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n\n    # If no even number is found, return -1\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2\n    if (n + m) % 2 != 0:\n        avg += 1\n    return bin(avg)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Calculate factorial for even i\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum for odd i\n            total = sum(range(1, i+1))\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if sum_of_digits(num) > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    \n    n = len(arr)\n    # Find the index of the minimum element\n    min_index = arr.index(min(arr))\n    \n    # Check if the array is sorted in non-decreasing order starting from min_index\n    for i in range(1, n):\n        if arr[(min_index + i) % n] < arr[(min_index + i - 1) % n]:\n            return False\n    \n    return True"}
{"idx": 110, "completion": "# Check if lst1 is already all even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange\n    if all(num % 2 != 0 for num in lst2):\n        return \"NO\"\n    \n    # Count the number of odd numbers in lst1\n    odd_count = sum(1 for num in lst1 if num % 2 != 0)\n    \n    # Count the number of even numbers in lst2\n    even_count_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_in_lst2 >= odd_count:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "# Split the string into a list of words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Iterate through each letter in the word\n        for letter in word:\n            # If the letter is already in the dictionary, increment its count\n            if letter in letter_count:\n                letter_count[letter] += 1\n            # Otherwise, add the letter to the dictionary with a count of 1\n            else:\n                letter_count[letter] = 1\n    \n    # Find the maximum count of any letter\n    max_count = max(letter_count.values(), default=0)\n    \n    # Create a dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate through the letter count dictionary\n    for letter, count in letter_count.items():\n        # If the count is equal to the maximum count, add the letter to the max_letters dictionary\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Step 1: Remove all characters in s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Step 3: Return the result as a tuple\n    return (result_string, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = nums[0]\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the number of times we need to lower the buckets\n    times = 0\n\n    # Iterate over each well in the grid\n    for well in grid:\n        # Count the number of units of water in the current well\n        water_units = well.count(1)\n\n        # If there are water units in the well, calculate how many times we need to lower the bucket\n        if water_units > 0:\n            # Calculate the number of times we need to lower the bucket to empty the well\n            times += math.ceil(water_units / capacity)\n\n    return times"}
{"idx": 116, "completion": "# First, filter out non-negative integers\n    non_neg_arr = [num for num in arr if num >= 0]\n    \n    # Define a key function that returns a tuple (number of 1s, number)\n    def key_func(num):\n        return (bin(num).count('1'), num)\n    \n    # Sort the non-negative integers based on the key function\n    sorted_non_neg_arr = sorted(non_neg_arr, key=key_func)\n    \n    # Replace the original non-negative integers with the sorted ones\n    sorted_arr = []\n    non_neg_index = 0\n    for num in arr:\n        if num >= 0:\n            sorted_arr.append(sorted_non_neg_arr[non_neg_index])\n            non_neg_index += 1\n        else:\n            sorted_arr.append(num)\n    \n    return sorted_arr"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    words = s.split()\n    for word in words:\n        consonant_count = sum(1 for char in word if char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    for i in range(len(word)-1, 1, -1):\n        if word[i] in consonants and word[i-1] in vowels and word[i-2] in consonants:\n            return word[i-1]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Take the last k elements from the sorted array\n    max_k_elements = sorted_arr[-k:]\n    \n    return max_k_elements"}
{"idx": 121, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total"}
{"idx": 122, "completion": "sum = 0\n    for i in range(min(k, len(arr))):\n        if arr[i] < 100 and arr[i] > -100:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "# Check if the date string is empty\n    if not date:\n        return False\n    \n    # Check if the date format is mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    odd_count += 1\n        return odd_count"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n        if lst[i] == lst[i + 1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection of the two intervals\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., the start is less than or equal to the end)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals do not intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "import heapq\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_heap = []\n\n    # Initialize the heap with all possible starting points\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(min_heap, (grid[i][j], [(i, j)], i, j))\n\n    while min_heap:\n        current_value, path, x, y = heapq.heappop(min_heap)\n        if len(path) == k:\n            return [grid[i][j] for i, j in path]\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N and (nx, ny) not in path:\n                new_path = path + [(nx, ny)]\n                heapq.heappush(min_heap, (grid[nx][ny], new_path, nx, ny))\n\n    return []"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    sequence = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n    return sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for bracket in string:\n        if bracket == '[':\n            stack.append(bracket)\n        elif bracket == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Square each element in the rounded list\n    squared_lst = [x**2 for x in rounded_lst]\n    \n    # Sum the squared elements\n    total_sum = sum(squared_lst)\n    \n    return total_sum"}
{"idx": 134, "completion": "if txt == \"\":\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if txt.endswith(' ' + last_char):\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [x for x in lst if x < 0]\n    positive_integers = [x for x in lst if x > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Replace comma with dot for string representations of numbers\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n    \n    # Convert to float if necessary\n    if isinstance(a, str):\n        a = float(a)\n    if isinstance(b, str):\n        b = float(b)\n    \n    # Compare and return the larger value in its original type\n    if a > b:\n        return type(a)(a) if isinstance(a, (int, float)) else a\n    elif b > a:\n        return type(b)(b) if isinstance(b, (int, float)) else b\n    else:\n        return None"}
{"idx": 138, "completion": "# Check if the number is less than 8\n    if n < 8:\n        return False\n    \n    # Check if the number is divisible by 2\n    if n % 2 == 0:\n        return True\n    else:\n        return False"}
{"idx": 139, "completion": "factorial = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        factorial *= i\n        special_fact *= factorial\n    return special_fact"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(\" \", \"_\")\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub(r\"_{3,}\", \"-\", text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name starts with a letter from the latin alphabet\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Check if there are more than three digits in the name\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = x.split('/')\n    n_num, n_den = n.split('/')\n    \n    # Convert the numerator and denominator to integers\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n    \n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start > end:\n        start, end = end, start\n    return tuple(planets[start+1:end])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if is_prime(n):\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if isinstance(x, int) and x > 0 and x % 2 != 0)"}
{"idx": 152, "completion": "# Initialize an empty list to store the differences\n    differences = []\n    \n    # Iterate over the scores and guesses simultaneously\n    for score, guess in zip(game, guess):\n        # If the guess is correct, append 0 to the differences list\n        if score == guess:\n            differences.append(0)\n        else:\n            # Otherwise, append the absolute difference\n            differences.append(abs(score - guess))\n    \n    return differences"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the length of b is greater than a\n    if len(b) > len(a):\n        return False\n    \n    # Create all rotations of b\n    rotations = [b[i:] + b[:i] for i in range(len(b))]\n    \n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "roman_numerals = {\n        1000: 'm',\n        900: 'cm',\n        500: 'd',\n        400: 'cd',\n        100: 'c',\n        90: 'xc',\n        50: 'l',\n        40: 'xl',\n        10: 'x',\n        9: 'ix',\n        5: 'v',\n        4: 'iv',\n        1: 'i'\n    }\n\n    roman_string = ''\n    for value, numeral in sorted(roman_numerals.items(), reverse=True):\n        while number >= value:\n            roman_string += numeral\n            number -= value\n    return roman_string"}
{"idx": 157, "completion": "# First, we need to check if the given sides can form a triangle.\n    # The sum of the lengths of any two sides must be greater than the length of the remaining side.\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Next, we need to check if the triangle is a right-angled triangle.\n    # We can use the Pythagorean theorem for this.\n    # The Pythagorean theorem states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle) is equal to the sum of squares of the lengths of the other two sides.\n    # So, we need to check if a^2 + b^2 = c^2 or a^2 + c^2 = b^2 or b^2 + c^2 = a^2.\n    # We can do this by sorting the sides and then checking if the square of the largest side is equal to the sum of squares of the other two sides.\n    \n    sides = [a, b, c]\n    sides.sort()\n    \n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for i in range(1, len(operand)):\n        expression += operator[i-1] + str(operand[i])\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "# Determine the range of numbers to consider\n    start = min(a, b)\n    end = max(a, b)\n    \n    # Initialize an empty list to store the even digits\n    even_digits = []\n    \n    # Iterate through the range and check each number\n    for num in range(start, end + 1):\n        # Convert the number to a string to easily access each digit\n        num_str = str(num)\n        # Check if all digits in the number are even\n        if all(int(digit) % 2 == 0 for digit in num_str):\n            # If all digits are even, add the number to the list\n            even_digits.append(num)\n    \n    return even_digits"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(' ', '')\n    groups = []\n    current_group = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n\n        current_group.append(char)\n\n        if depth == 0:\n            groups.append(''.join(current_group))\n            current_group = []\n\n    return groups"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result"}
{"idx": 6, "completion": "# Split the input string into individual parenthesis groups\n    paren_groups = paren_string.split()\n\n    # Initialize a list to store the maximum nesting levels for each group\n    max_nesting_levels = []\n\n    # Iterate over each parenthesis group\n    for group in paren_groups:\n        max_depth = 0\n        current_depth = 0\n\n        # Iterate over each character in the group\n        for char in group:\n            if char == '(':\n                # Increment the current depth when encountering an opening parenthesis\n                current_depth += 1\n                # Update the maximum depth if the current depth exceeds it\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                # Decrement the current depth when encountering a closing parenthesis\n                current_depth -= 1\n\n        # Append the maximum depth of the current group to the list\n        max_nesting_levels.append(max_depth)\n\n    return max_nesting_levels"}
{"idx": 7, "completion": "return [s for s in strings if substring in s]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_numbers = sum(numbers)\n    product_numbers = 1\n    for number in numbers:\n        product_numbers *= number\n    return (sum_numbers, product_numbers)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for number in numbers:\n        if current_max is None or number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return ''\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Strings must be of equal length\")\n    return ''.join('0' if x == y else '1' for x, y in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "# Create a dictionary to map the note representations to their corresponding beats\n    note_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the music string into individual note representations\n    notes = music_string.split()\n    \n    # Convert each note representation to its corresponding number of beats\n    beats = [note_beats[note] for note in notes]\n    \n    return beats"}
{"idx": 18, "completion": "if not substring:\n        return 0\n    count = 0\n    i = 0\n    while i < len(string):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n            i += len(substring) - 1\n        i += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "if len(numbers) < 2:\n        raise ValueError(\"The list must contain at least two numbers.\")\n\n    numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    min_distance = abs(numbers[0] - numbers[1])\n\n    for i in range(1, len(numbers)):\n        distance = abs(numbers[i] - numbers[i - 1])\n        if distance < min_distance:\n            min_distance = distance\n            closest_pair = (numbers[i - 1], numbers[i])\n\n    return closest_pair"}
{"idx": 21, "completion": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n//2, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    i = 2\n    while i * i <= n:\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n        i += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result"}
{"idx": 27, "completion": "return ''.join(char.lower() if char.isupper() else char.upper() for char in string)"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [string for string in strings if string.startswith(prefix)]"}
{"idx": 30, "completion": "return [i for i in l if i > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    return math.pow(-1, len(xs)) * sum(xs[:-1]) / xs[-1]"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 3 > len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n        else:\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices.sort()\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 0, 1\n    while True:\n        if is_prime(b):\n            count += 1\n            if count == n:\n                return b\n        a, b = b, a + b"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "assert base > 1\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return \"\".join(digits[::-1])"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "return pow(2, n, p)"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = 'aeiouAEIOU'\n    return ''.join([char for char in text if char not in vowels])"}
{"idx": 52, "completion": "return all(i < t for i in l)"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1) & set(l2))"}
{"idx": 59, "completion": "factor = 2\n    while factor * factor <= n:\n        while n % factor == 0:\n            n //= factor\n        factor += 1\n    return n if n > 1 else factor - 1"}
{"idx": 60, "completion": "if n == 1:\n        return 1\n    else:\n        return n + sum_to_n(n - 1)"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "digits = str(x)\n    shift = shift % len(digits)\n    return digits[-shift:] + digits[:-shift]"}
{"idx": 66, "completion": "total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n    return total"}
{"idx": 67, "completion": "# Split the string by spaces to separate the numbers and words\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes by subtracting the number of apples and oranges from the total number of fruits\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if min_even is None or value < min_even:\n                min_even = value\n                min_index = index\n                \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "from collections import Counter\n    count = Counter(lst)\n    candidates = [x for x in count if count[x] >= x]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    return result"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-(i + 1)]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0:\n        return True\n    x = int(a ** (1/3))\n    if x ** 3 == a:\n        return True\n    elif (x + 1) ** 3 == a:\n        return True\n    elif (x - 1) ** 3 == a:\n        return True\n    else:\n        return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate over each character in the input string\n    for char in num:\n        # If the character is a prime digit, increment the counter\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s)-2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "# The number of n-digit numbers that start with 1 is 9 * 10^(n-1)\n    # The number of n-digit numbers that end with 1 is 9 * 10^(n-1)\n    # The number of n-digit numbers that start and end with 1 is 10^(n-1)\n    # So the total number of n-digit numbers that start or end with 1 is\n    # 9 * 10^(n-1) + 9 * 10^(n-1) - 10^(n-1) = 17 * 10^(n-1)\n    return 17 * (10 ** (n - 1))"}
{"idx": 84, "completion": "# Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum([lst[i] for i in range(len(lst)) if lst[i] % 2 == 0 and i % 2 != 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order\n    coordinates.sort(key=lambda coord: coord[0])\n    # Sort by columns in descending order within the same row\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted_str = ''\n    for char in s:\n        # Shift the character down by 2 * 2 = 4 places\n        encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        encrypted_str += encrypted_char\n    return encrypted_str"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    \n    smallest = float('inf')\n    next_smallest = float('inf')\n    \n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif num < next_smallest and num != smallest:\n            next_smallest = num\n    \n    return next_smallest if next_smallest != float('inf') else None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if not (isinstance(x, int) and isinstance(y, int) and isinstance(z, int)):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    return x == y + z or y == x + z or z == x + y"}
{"idx": 93, "completion": "vowels = ['a', 'e', 'i', 'o', 'u']\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                # Find the index of the vowel in the vowels list\n                index = vowels.index(char.lower())\n                # Find the next vowel in the list\n                next_vowel = vowels[(index + 2) % len(vowels)]\n                # Replace the vowel with the next vowel\n                if char.isupper():\n                    encoded_message += next_vowel.upper()\n                else:\n                    encoded_message += next_vowel\n            else:\n                # Swap the case of the letter\n                if char.isupper():\n                    encoded_message += char.lower()\n                else:\n                    encoded_message += char.upper()\n        else:\n            # If the character is not a letter, add it as is\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Get the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "# Split the string by both commas and spaces\n    words = s.replace(',', ' ').split()\n    return words"}
{"idx": 102, "completion": "# First, ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x\n\n    # Initialize the result to -1 (default if no even number is found)\n    result = -1\n\n    # Iterate through the range [x, y]\n    for num in range(x, y + 1):\n        # Check if the number is even\n        if num % 2 == 0:\n            # Update the result if the current even number is larger\n            if num > result:\n                result = num\n\n    return result"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    average = (n + m) // 2\n    if (n + m) % 2 != 0:\n        average += 1\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "# Filter the array to only include integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Calculate factorial of i\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum of numbers from 1 to i\n            total = 0\n            for j in range(1, i+1):\n                total += j\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            signed_digits = [-int(d) for d in str(num)]\n        else:\n            signed_digits = [int(d) for d in str(num)]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n\n    # Find the index of the minimum element in the original array\n    min_index = arr.index(min(arr))\n\n    # Perform the right shift operation 'min_index' times\n    shifted_arr = arr[min_index:] + arr[:min_index]\n\n    # Check if the shifted array is sorted\n    if shifted_arr == sorted_arr:\n        return True\n    else:\n        return False"}
{"idx": 110, "completion": "# Check if lst1 is already all even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n    \n    # Count the number of odd numbers in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    \n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    # Split the string into a list of letters\n    letters = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate over each letter in the list\n    for letter in letters:\n        # If the letter is already in the dictionary, increment its count\n        if letter in letter_count:\n            letter_count[letter] += 1\n        # Otherwise, add the letter to the dictionary with a count of 1\n        else:\n            letter_count[letter] = 1\n    \n    # Find the maximum count of any letter\n    max_count = max(letter_count.values())\n    \n    # Create a new dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate over each letter and count in the letter_count dictionary\n    for letter, count in letter_count.items():\n        # If the count is equal to the maximum count, add the letter and count to the max_letters dictionary\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Step 1: Remove all characters in s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Step 3: Return the result as a tuple\n    return (result_string, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for idx, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the number of times to lower the buckets\n    times = 0\n\n    # Iterate over each row in the grid\n    for row in grid:\n        # Count the number of 1s in the current row\n        water_units = row.count(1)\n        # If there are water units in the row, calculate the number of times to lower the bucket\n        if water_units > 0:\n            # The number of times to lower the bucket is the ceiling of the water units divided by the bucket capacity\n            times += math.ceil(water_units / capacity)\n\n    return times"}
{"idx": 116, "completion": "# Your code here\n    pass"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    words = s.split()\n    for word in words:\n        consonant_count = sum(1 for char in word if char not in vowels and char.isalpha())\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the current vowel is between two consonants\n            if i > 0 and i < len(word) - 1:\n                if word[i - 1] in consonants and word[i + 1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    else:\n        return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Select the last k elements from the sorted array\n    max_k_elements = sorted_arr[-k:]\n    \n    return max_k_elements"}
{"idx": 121, "completion": "total = 0\n    for i, num in enumerate(lst):\n        if i % 2 == 0 and num % 2 != 0:\n            total += num\n    return total"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if arr[i] < 100 and arr[i] > -100:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "# Check if the date string is empty\n    if not date:\n        return False\n    \n    # Check if the date format is mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        return sum(1 for c in txt if c.islower() and ord(c) % 2 != 0)"}
{"idx": 126, "completion": "if len(lst) <= 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n        if lst[i] == lst[i + 1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # Check if the intervals intersect\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = intersection_end - intersection_start + 1\n    \n    # Check if the length is a prime number\n    if intersection_length < 2:\n        return \"NO\"\n    \n    for i in range(2, int(intersection_length**0.5) + 1):\n        if intersection_length % i == 0:\n            return \"NO\"\n    \n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "def is_valid(x, y, N):\n        return 0 <= x < N and 0 <= y < N\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    min_path = None\n\n    for i in range(N):\n        for j in range(N):\n            queue = [(grid[i][j], i, j, [grid[i][j]])]\n            while queue:\n                current_value, x, y, path = queue.pop(0)\n                if len(path) == k:\n                    if min_path is None or path < min_path:\n                        min_path = path.copy()\n                    continue\n                for dx, dy in directions:\n                    nx, ny = x + dx, y + dy\n                    if is_valid(nx, ny, N):\n                        new_path = path.copy()\n                        new_path.append(grid[nx][ny])\n                        queue.append((grid[nx][ny], nx, ny, new_path))\n\n    return min_path"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    \n    tribonacci_sequence = [0] * (n + 1)\n    tribonacci_sequence[0] = 1\n    \n    if n >= 1:\n        tribonacci_sequence[1] = 3\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci_sequence[i] = 1 + (i // 2)\n        else:\n            tribonacci_sequence[i] = tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i + 1]\n    \n    return tribonacci_sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Square each element in the rounded list\n    squared_lst = [x**2 for x in rounded_lst]\n    \n    # Return the sum of the squared elements\n    return sum(squared_lst)"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if txt.endswith(' ' + last_char):\n            return True\n        else:\n            return False\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [x for x in lst if x < 0]\n    positive_integers = [x for x in lst if x > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Replace comma with dot for string representations\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n    \n    # Convert to float for comparison\n    a_val = float(a) if isinstance(a, (int, float, str)) else None\n    b_val = float(b) if isinstance(b, (int, float, str)) else None\n    \n    if a_val is None or b_val is None:\n        return None\n    \n    if a_val > b_val:\n        return a if isinstance(a, (int, float)) else str(a).replace('.', ',')\n    elif b_val > a_val:\n        return b if isinstance(b, (int, float)) else str(b).replace('.', ',')\n    else:\n        return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 == 0:\n        return True\n    return False"}
{"idx": 139, "completion": "# Calculate the factorial of n\n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        else:\n            return x * factorial(x - 1)\n\n    # Calculate the special factorial\n    special_fact = 1\n    for i in range(1, n + 1):\n        special_fact *= factorial(i)\n\n    return special_fact"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub('_{3,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the extension is valid\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # Check if the name starts with a latin alphapet letter\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Count the number of digits in the name\n    digit_count = sum(1 for char in name if char.isdigit())\n    \n    # Check if there are more than three digits\n    if digit_count > 3:\n        return 'No'\n    \n    # If all checks pass, return 'Yes'\n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the fractions into numerator and denominator\n    x_numerator, x_denominator = x.split('/')\n    n_numerator, n_denominator = n.split('/')\n    \n    # Convert the numerator and denominator to integers\n    x_numerator = int(x_numerator)\n    x_denominator = int(x_denominator)\n    n_numerator = int(n_numerator)\n    n_denominator = int(n_denominator)\n    \n    # Calculate the product of the numerators and denominators\n    product_numerator = x_numerator * n_numerator\n    product_denominator = x_denominator * n_denominator\n    \n    # Check if the product is a whole number\n    return product_numerator % product_denominator == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    indexed_nums = list(enumerate(nums))\n    sorted_nums = sorted(indexed_nums, key=lambda x: (digit_sum(x[1]), x[0]))\n    return [num for idx, num in sorted_nums]"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(num)\n            first_digit = num_str[0]\n            last_digit = num_str[-1]\n            if int(first_digit) % 2 != 0 and int(last_digit) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start < end:\n        return tuple(planets[start+1:end])\n    else:\n        return tuple(planets[end+1:start])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "# Check if n is a prime number\n    if is_prime(n):\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if isinstance(x, int) and x > 0 and x % 2 != 0)"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "# Initialize variables to store the strongest extension and its strength\n    strongest_extension = None\n    max_strength = None\n    \n    # Iterate over each extension in the list\n    for extension in extensions:\n        # Calculate the number of uppercase and lowercase letters\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        \n        # Calculate the strength of the extension\n        strength = CAP - SM\n        \n        # If this extension has a higher strength, update the strongest extension\n        if (max_strength is None) or (strength > max_strength):\n            strongest_extension = extension\n            max_strength = strength\n    \n    # Return the class name with the strongest extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the length of b is greater than a\n    if len(b) > len(a):\n        return False\n\n    # Create all rotations of b\n    rotations = []\n    for i in range(len(b)):\n        rotation = b[i:] + b[:i]\n        rotations.append(rotation)\n\n    # Check if any rotation is a substring of a\n    for rotation in rotations:\n        if rotation in a:\n            return True\n\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "roman_numerals = [\n        (1000, 'm'), (900, 'cm'), (500, 'd'), (400, 'cd'),\n        (100, 'c'), (90, 'xc'), (50, 'l'), (40, 'xl'),\n        (10, 'x'), (9, 'ix'), (5, 'v'), (4, 'iv'), (1, 'i')\n    ]\n\n    roman_string = ''\n    for value, symbol in roman_numerals:\n        while number >= value:\n            roman_string += symbol\n            number -= value\n\n    return roman_string"}
{"idx": 157, "completion": "# First, we need to check if the three sides can form a triangle.\n    # According to the triangle inequality theorem, the sum of the lengths of any two sides\n    # must be greater than the length of the remaining side.\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Next, we need to check if the triangle is a right-angled triangle.\n    # According to the Pythagorean theorem, in a right-angled triangle, the square of the\n    # length of the hypotenuse (the longest side) is equal to the sum of squares of the\n    # lengths of the other two sides.\n    sides = [a, b, c]\n    sides.sort()\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "# Calculate the total number of carrots eaten\n    total_eaten = number + min(need, remaining)\n    \n    # Calculate the number of carrots left\n    carrots_left = max(remaining - need, 0)\n    \n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for i in range(1, len(operand)):\n        expression += operator[i-1] + str(operand[i])\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "# Determine the range of numbers to check\n    start = min(a, b)\n    end = max(a, b)\n    \n    # Initialize an empty list to store the even digits\n    even_digits = []\n    \n    # Iterate through the range of numbers\n    for num in range(start, end + 1):\n        # Convert the number to a string to check each digit\n        num_str = str(num)\n        # Initialize a flag to indicate if the number contains an even digit\n        has_even_digit = False\n        # Check each digit in the number\n        for digit_char in num_str:\n            digit = int(digit_char)\n            if digit % 2 == 0:\n                has_even_digit = True\n                break\n        # If the number contains an even digit, add it to the list\n        if has_even_digit:\n            even_digits.append(num)\n    \n    return even_digits"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    groups = []\n    current_group = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current_group.append(char)\n\n        if depth == 0:\n            groups.append(''.join(current_group))\n            current_group = []\n\n    return groups"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result"}
{"idx": 6, "completion": "# Split the input string into individual groups of parentheses\n    paren_groups = paren_string.split()\n\n    # Initialize a list to store the maximum nesting levels for each group\n    max_nesting_levels = []\n\n    # Iterate over each group of parentheses\n    for group in paren_groups:\n        max_depth = 0\n        current_depth = 0\n\n        # Iterate over each character in the group\n        for char in group:\n            if char == '(':\n                # Increase the current depth when an opening parenthesis is encountered\n                current_depth += 1\n                # Update the maximum depth if the current depth exceeds it\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                # Decrease the current depth when a closing parenthesis is encountered\n                current_depth -= 1\n\n        # Append the maximum depth of the current group to the list\n        max_nesting_levels.append(max_depth)\n\n    return max_nesting_levels"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_result = sum(numbers)\n    product_result = 1\n    for number in numbers:\n        product_result *= number\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for num in numbers:\n        if current_max is None or num > current_max:\n            current_max = num\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "# Create a dictionary to map note representations to their corresponding beats\n    note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the music string into individual note representations\n    notes = music_string.split()\n    \n    # Convert each note representation to its corresponding number of beats\n    beats = [note_to_beats[note] for note in notes]\n    \n    return beats"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    count = 0\n    i = 0\n    while i <= len(string) - len(substring):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n            i += len(substring) - 1\n        else:\n            i += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "numbers.sort()\n    min_distance = float('inf')\n    result = (0, 0)\n    for i in range(1, len(numbers)):\n        distance = numbers[i] - numbers[i - 1]\n        if distance < min_distance:\n            min_distance = distance\n            result = (numbers[i - 1], numbers[i])\n    return result"}
{"idx": 21, "completion": "min_value = min(numbers)\n    max_value = max(numbers)\n    return [(x - min_value) / (max_value - min_value) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result"}
{"idx": 27, "completion": "return ''.join(char.lower() if char.isupper() else char.upper() for char in string)"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [string for string in strings if string.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    i = 3\n    while i * i <= n:\n        if n % i == 0:\n            return False\n        i += 2\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0, \"xs must have even number of coefficients\"\n    assert xs[-1] != 0, \"largest coefficient must be non zero\"\n    return bisection(lambda x: poly(xs, x), -100, 100)"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i+2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices_sorted = sorted(even_indices)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices_sorted[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[0:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x == 1:\n            return False\n        for i in range(2, int(x**0.5)+1):\n            if x % i == 0:\n                return False\n        return True\n\n    fib_seq = [1, 1]\n    while True:\n        next_fib = fib_seq[-1] + fib_seq[-2]\n        fib_seq.append(next_fib)\n        if is_prime(next_fib):\n            n -= 1\n            if n == 0:\n                return next_fib"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "# Since all cars move at the same speed and start out very far from each other,\n    # the number of collisions is simply the number of pairs of cars, which is n choose 2.\n    return n * (n - 1) // 2"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "assert base < 10\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x:\n        digits.append(str(x % base))\n        x = x // base\n    return \"\".join(digits[::-1])"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    n = len(l)\n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    return (2 * modp(n - 1, p)) % p"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = ['a', 'e', 'i', 'o', 'u']\n    return ''.join([char for char in text if char.lower() not in vowels])"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 0:\n        raise ValueError(\"Fibonacci index cannot be negative.\")\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n + 1):\n            a, b = b, a + b\n        return b"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return (all(l[i] <= l[i+1] for i in range(len(l) - 1)) or\n            all(l[i] >= l[i+1] for i in range(len(l) - 1)))"}
{"idx": 58, "completion": "return sorted(set(l1) & set(l2))"}
{"idx": 59, "completion": "# Start with the smallest prime number\n    factor = 2\n    while n != 1:\n        if n % factor == 0:\n            n //= factor\n        else:\n            factor += 1\n    return factor"}
{"idx": 60, "completion": "if n == 1:\n        return 1\n    return n + sum_to_n(n - 1)"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "digits = str(x)\n    shift = shift % len(digits)\n    return digits[-shift:] + digits[:-shift]"}
{"idx": 66, "completion": "total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n    return total"}
{"idx": 67, "completion": "# Split the string by spaces to separate the numbers and words\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "# Initialize variables to store the smallest even value and its index\n    smallest_even = None\n    smallest_index = -1\n\n    # Iterate through the array to find the smallest even value and its index\n    for index, value in enumerate(arr):\n        if value % 2 == 0:  # Check if the value is even\n            if smallest_even is None or value < smallest_even:\n                smallest_even = value\n                smallest_index = index\n\n    # If a smallest even value was found, return it with its index\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []"}
{"idx": 69, "completion": "from collections import Counter\n    count = Counter(lst)\n    result = -1\n    for num in sorted(count, reverse=True):\n        if count[num] >= num:\n            result = num\n            break\n    return result"}
{"idx": 70, "completion": "if not lst:\n        return []\n    \n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    \n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    \n    return result"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-(i + 1)]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        if is_prime(i):\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0 or a == 1:\n        return True\n    low = 0\n    high = a\n    while low <= high:\n        mid = (low + high) // 2\n        if mid ** 3 == a:\n            return True\n        elif mid ** 3 < a:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime digit\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary_representation = bin(decimal)[2:]\n    return f\"db{binary_representation}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    else:\n        return 18 * (10 ** (n - 2))"}
{"idx": 84, "completion": "# Calculate the sum of digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to binary\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)"}
{"idx": 86, "completion": "words = s.split(' ')\n    sorted_words = []\n    for word in words:\n        sorted_word = ''.join(sorted(word))\n        sorted_words.append(sorted_word)\n    return ' '.join(sorted_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, element in enumerate(row):\n            if element == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order, then by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    if len(array) == 1:\n        return array\n    \n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted_string = \"\"\n    for char in s:\n        # Calculate the new character by shifting it down by 2*2 = 4 places\n        new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        encrypted_string += new_char\n    return encrypted_string"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    \n    smallest = float('inf')\n    next_smallest = float('inf')\n    \n    for num in lst:\n        if num < smallest:\n            next_smallest = smallest\n            smallest = num\n        elif num < next_smallest and num != smallest:\n            next_smallest = num\n    \n    return next_smallest if next_smallest != float('inf') else None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if not all(isinstance(num, int) for num in (x, y, z)):\n        return False\n    \n    # Check if one of the numbers is equal to the sum of the other two\n    if x == y + z or y == x + z or z == x + y:\n        return True\n    \n    return False"}
{"idx": 93, "completion": "vowels = \"aeiou\"\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                # Find the index of the vowel in the vowels string\n                index = vowels.find(char.lower())\n                # Replace with the letter 2 places ahead in the alphabet\n                new_char = chr(((ord(char.lower()) - ord('a') + 2) % 26) + ord('a'))\n                # Swap the case\n                if char.isupper():\n                    new_char = new_char.upper()\n                else:\n                    new_char = new_char.lower()\n                encoded_message += new_char\n            else:\n                # Swap the case\n                if char.isupper():\n                    encoded_message += char.lower()\n                else:\n                    encoded_message += char.upper()\n        else:\n            # If the character is not a letter, keep it as is\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    largest_prime = -1\n    for num in lst:\n        if is_prime(num) and num > largest_prime:\n            largest_prime = num\n\n    if largest_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(largest_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n    primes = []\n    for num in range(2, n):\n        if is_prime(num):\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return int(round(number))"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 1\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "# Split the string by both commas and spaces\n    words = s.replace(',', ' ').split()\n    return words"}
{"idx": 102, "completion": "# Ensure x is less than or equal to y\n    if x > y:\n        x, y = y, x\n\n    # Iterate from y down to x to find the largest even number\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n\n    # If no even number is found, return -1\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2 if (n + m) % 2 == 0 else (n + m + 1) // 2\n    return bin(avg)"}
{"idx": 104, "completion": "def has_even_digit(number):\n        while number > 0:\n            digit = number % 10\n            if digit % 2 == 0:\n                return True\n            number = number // 10\n        return False\n\n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()\n    return result"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_to_name = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_to_name[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Calculate the factorial of i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate the sum of numbers from 1 to i\n            total = sum(range(1, i + 1))\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        sum_digits = 0\n        for digit in str(num):\n            if digit == '-':\n                continue\n            sum_digits += int(digit)\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    # Find the index of the minimum element\n    min_index = arr.index(min(arr))\n\n    # Check if the array is sorted in non-decreasing order starting from min_index\n    for i in range(1, n):\n        if arr[(min_index + i) % n] < arr[(min_index + i - 1) % n]:\n            return False\n\n    return True"}
{"idx": 110, "completion": "# Check if lst1 already contains only even numbers\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n\n    # Check if lst2 contains at least as many even numbers as odd numbers in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n\n    counts = {}\n    for letter in test.split():\n        if letter in counts:\n            counts[letter] += 1\n        else:\n            counts[letter] = 1\n\n    max_count = max(counts.values())\n    histogram_dict = {k: v for k, v in counts.items() if v == max_count}\n\n    return histogram_dict"}
{"idx": 112, "completion": "# Step 1: Remove all characters in s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Step 3: Return the result as a tuple\n    return (result_string, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n\n    return min_sum"}
{"idx": 115, "completion": "total_buckets = 0\n    for row in grid:\n        # Count the number of 1s in the row\n        count = sum(row)\n        # Calculate the number of times the bucket needs to be lowered\n        total_buckets += math.ceil(count / capacity)\n    return total_buckets"}
{"idx": 116, "completion": "# First, filter out non-negative integers\n    non_negatives = [num for num in arr if num >= 0]\n    \n    # Then, sort based on the number of ones in the binary representation\n    # and then by the decimal value\n    sorted_arr = sorted(non_negatives, key=lambda x: (bin(x).count('1'), x))\n    \n    return sorted_arr"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    for word in s.split():\n        consonant_count = sum(1 for char in word if char not in vowels and char.isalpha())\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for i in range(len(word) - 1, 0, -1):\n        if word[i] in vowels:\n            # Check if the current vowel is between two consonants\n            if i > 0 and i < len(word) - 1:\n                if word[i - 1] in consonants and word[i + 1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# First, sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Then, take the last k elements from the sorted array\n    max_k_elements = sorted_arr[-k:]\n    \n    return max_k_elements"}
{"idx": 121, "completion": "total = 0\n    for index, value in enumerate(lst):\n        if index % 2 == 0 and value % 2 != 0:\n            total += value\n    return total"}
{"idx": 122, "completion": "sum_of_elements = 0\n    for i in range(min(k, len(arr))):\n        if arr[i] < 100 and arr[i] > -100:\n            sum_of_elements += arr[i]\n    return sum_of_elements"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "import re\n    # Check if the date string is empty\n    if not date:\n        return False\n    \n    # Check if the date format is correct\n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n    \n    # Split the date into month, day, and year\n    month, day, year = map(int, date.split('-'))\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    count += 1\n        return count"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n        if lst[i] == lst[i+1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection of the two intervals\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., start <= end)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals do not intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "import heapq\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize a priority queue with all starting positions\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)], i, j))\n\n    # Perform a BFS with priority queue\n    for _ in range(k - 1):\n        current_val, path, x, y = heapq.heappop(pq)\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                heapq.heappush(pq, (grid[nx][ny], path + [(nx, ny)], nx, ny))\n\n    # The top of the priority queue now contains the minimum path\n    min_path_val, min_path, _, _ = heapq.heappop(pq)\n    return [grid[x][y] for x, y in min_path]"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    \n    tribonacci_sequence = [1, 3]\n    \n    if n == 0:\n        return tribonacci_sequence\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci_sequence.append(1 + i // 2)\n        else:\n            tribonacci_sequence.append(tribonacci_sequence[i - 1] + tribonacci_sequence[i - 2] + tribonacci_sequence[i + 1])\n    \n    return tribonacci_sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if txt == \"\":\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if txt.endswith(' '):\n            return False\n        words = txt.split()\n        if len(words) == 1:\n            return False\n        last_word = words[-1]\n        if last_char == last_word[-1]:\n            return True\n    return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [x for x in lst if x < 0]\n    positive_integers = [x for x in lst if x > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Normalize the input to handle different representations\n    def normalize(value):\n        if isinstance(value, str):\n            return float(value.replace(',', '.'))\n        return float(value)\n    \n    # Normalize both inputs\n    a_norm = normalize(a)\n    b_norm = normalize(b)\n    \n    # Compare the normalized values\n    if a_norm > b_norm:\n        return a\n    elif b_norm > a_norm:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "# Since we are looking for the sum of 4 positive even numbers, the smallest possible sum is 2 + 2 + 2 + 2 = 8\n    # Therefore, if n is less than 8, it's impossible to express it as the sum of 4 positive even numbers\n    if n < 8:\n        return False\n    \n    # If n is even, we can always express it as the sum of 4 even numbers\n    # For example, if n = 10, we can write it as 2 + 2 + 2 + 4\n    # If n is odd, it's impossible to express it as the sum of 4 even numbers\n    return n % 2 == 0"}
{"idx": 139, "completion": "factorial = 1\n    special_fact = 1\n    for i in range(1, n+1):\n        factorial *= i\n        special_fact *= factorial\n    return special_fact"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub(r'_{3,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name starts with a letter from the latin alphabet\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Check if the name contains more than three digits\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_length_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_length_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = x.split('/')\n    n_num, n_den = n.split('/')\n    \n    # Convert the numerator and denominator to integers\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n    \n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start > end:\n        start, end = end, start\n    return tuple(planets[start+1:end])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "# Your code here\n    if n > 1:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return y\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "sum_of_squares = 0\n    for number in lst:\n        if isinstance(number, int) and number > 0 and number % 2 != 0:\n            sum_of_squares += number ** 2\n    return sum_of_squares"}
{"idx": 152, "completion": "return [abs(game[i] - guess[i]) if game[i] != guess[i] else 0 for i in range(len(game))]"}
{"idx": 153, "completion": "# Initialize variables to store the strongest extension and its strength\n    strongest_extension = None\n    max_strength = -float('inf')\n    \n    # Iterate over each extension in the list\n    for extension in extensions:\n        # Count the number of uppercase and lowercase letters\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        # Calculate the strength of the extension\n        strength = CAP - SM\n        # Update the strongest extension if the current one is stronger\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    \n    # Return the class name with the strongest extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# First, we need to check if the given lengths can form a triangle.\n    # The triangle inequality theorem states that the sum of the lengths of any two sides\n    # of a triangle must be greater than the length of the remaining side.\n    if a + b > c and a + c > b and b + c > a:\n        # If the triangle inequality theorem holds, we then check if it's a right-angled triangle.\n        # A triangle is right-angled if the square of the length of the longest side\n        # is equal to the sum of squares of the lengths of the other two sides.\n        # This is known as the Pythagorean theorem.\n        sides = [a, b, c]\n        sides.sort()  # Sorting the sides to easily identify the longest side\n        if sides[0]**2 + sides[1]**2 == sides[2]**2:\n            return True\n        else:\n            return False\n    else:\n        # If the triangle inequality theorem doesn't hold, the sides cannot form a triangle.\n        return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "# Initialize the expression with the first operand\n    expression = str(operand[0])\n    \n    # Iterate over the operator and operand lists to build the expression\n    for i in range(1, len(operand)):\n        expression += operator[i-1] + str(operand[i])\n    \n    # Evaluate the expression and return the result\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(c) % 2 == 0 for c in str(i))]"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current_group = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current_group.append(char)\n\n        if depth == 0:\n            result.append(''.join(current_group))\n            current_group = []\n\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "result = []\n    for number in numbers:\n        result.append(number)\n        result.append(delimeter)\n    return result[:-1] if result else result"}
{"idx": 6, "completion": "result = []\n    for group in paren_string.split():\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n    return result"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_numbers = sum(numbers)\n    product_numbers = 1\n    for number in numbers:\n        product_numbers *= number\n    return (sum_numbers, product_numbers)"}
{"idx": 9, "completion": "max_list = []\n    max_value = None\n    for number in numbers:\n        if max_value is None or number > max_value:\n            max_value = number\n        max_list.append(max_value)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(char_a) ^ int(char_b)) for char_a, char_b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "if a == 0:\n        return b\n    if b == 0:\n        return a\n    if a == b:\n        return a\n    if a > b:\n        return greatest_common_divisor(a - b, b)\n    return greatest_common_divisor(a, b - a)"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_durations = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    return [note_durations[note] for note in notes]"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    count = 0\n    for i in range(len(string)):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "numbers.sort()\n    min_diff = float('inf')\n    result = (None, None)\n    for i in range(len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i + 1])\n    return result"}
{"idx": 21, "completion": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for number in numbers:\n        if number not in seen:\n            result.append(number)\n            seen.add(number)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "# The idea is to use the intermediate value theorem.\n    # We know that if the leading coefficient is positive, the polynomial will go to infinity as x goes to infinity,\n    # and to negative infinity as x goes to negative infinity.\n    # Similarly, if the leading coefficient is negative, the polynomial will go to negative infinity as x goes to infinity,\n    # and to positive infinity as x goes to negative infinity.\n    # Therefore, by evaluating the polynomial at a large positive and negative value, we can find an interval where the polynomial changes sign,\n    # and then use binary search to find the root.\n\n    # First, we need to determine the leading coefficient and its sign.\n    leading_coeff = xs[-1]\n    sign = 1 if leading_coeff > 0 else -1\n\n    # Now, we choose two points, one large positive and one large negative.\n    # The exact values don't matter as long as they are large enough.\n    x_pos = 1\n    x_neg = -1\n\n    # We evaluate the polynomial at these points.\n    y_pos = poly(xs, x_pos)\n    y_neg = poly(xs, x_neg)\n\n    # If the signs of y_pos and y_neg are the same, we need to increase the magnitude of our points.\n    while y_pos * y_neg > 0:\n        x_pos *= 2\n        x_neg *= 2\n        y_pos = poly(xs, x_pos)\n        y_neg = poly(xs, x_neg)\n\n    # Now, we have an interval [x_neg, x_pos] where the polynomial changes sign.\n    # We can use binary search to find the root.\n    while x_pos - x_neg > 1e-10:  # We stop when the interval is small enough.\n        x_mid = (x_pos + x_neg) / 2\n        y_mid = poly(xs, x_mid)\n\n        if y_mid * y_pos > 0:\n            x_pos = x_mid\n        else:\n            x_neg = x_mid\n\n    return (x_pos + x_neg) / 2"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 3 > len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n        else:\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_num = l[0]\n    for num in l:\n        if num > max_num:\n            max_num = num\n    return max_num"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices.sort()\n    l_prime = l.copy()\n    l_prime[::2] = even_indices\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[0:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x == 2:\n            return True\n        if x % 2 == 0:\n            return False\n        for i in range(3, int(x**0.5)+1, 2):\n            if x % i == 0:\n                return False\n        return True\n\n    def fib():\n        a, b = 0, 1\n        while True:\n            yield a\n            a, b = b, a + b\n\n    fib_gen = fib()\n    count = 0\n    for f in fib_gen:\n        if is_prime(f):\n            count += 1\n            if count == n:\n                return f"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x < 0:\n        return \"-\" + change_base(-x, base)\n    if x < base:\n        return str(x)\n    return change_base(x // base, base) + str(x % base)"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    n = len(l)\n    if n % 2 == 1:\n        return l[n // 2]\n    else:\n        return (l[n // 2 - 1] + l[n // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "if n == 0:\n        return 1\n    res = 1\n    for _ in range(n):\n        res = (res * 2) % p\n    return res"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])"}
{"idx": 52, "completion": "for number in l:\n        if number >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "if l[0] < l[-1]:\n        return all(x <= y for x, y in zip(l, l[1:]))\n    else:\n        return all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1).intersection(l2))"}
{"idx": 59, "completion": "assert n > 1\n    assert not is_prime(n)\n    return max(prime_factors(n))"}
{"idx": 60, "completion": "return sum(range(1, n + 1))"}
{"idx": 61, "completion": "\"\"\"\n    We need to check if every opening bracket has a corresponding closing bracket.\n    We can do this by keeping track of the number of opening brackets we have seen.\n    If we see a closing bracket, we decrement the count.\n    If the count ever goes negative, we know that there is a closing bracket without a corresponding opening bracket.\n    If we finish and the count is not zero, we know that there is an opening bracket without a corresponding closing bracket.\n    \"\"\"\n    count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count"}
{"idx": 65, "completion": "x_str = str(x)\n    shift = shift % len(x_str)\n    return x_str[-shift:] + x_str[:-shift]"}
{"idx": 66, "completion": "sum = 0\n    for char in s:\n        if char.isupper():\n            sum += ord(char)\n    return sum"}
{"idx": 67, "completion": "# Split the string into parts\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = float('inf')\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if value < min_even:\n                min_even = value\n                min_index = index\n    \n    if min_even == float('inf'):\n        return []\n    else:\n        return [min_even, min_index]"}
{"idx": 69, "completion": "from collections import Counter\n    freq = Counter(lst)\n    candidates = [x for x in freq if x <= freq[x]]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    return result"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "changes = 0\n    for i in range(len(arr) // 2):\n        if arr[i] != arr[-(i + 1)]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "def count_chars(lst):\n        return sum(len(s) for s in lst)\n    \n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n    \n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0:\n        return True\n    x = int(a ** (1/3))\n    if x ** 3 == a:\n        return True\n    elif (x + 1) ** 3 == a:\n        return True\n    elif (x - 1) ** 3 == a:\n        return True\n    else:\n        return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime digit\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s)-2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))"}
{"idx": 83, "completion": "# The number of n-digit numbers that start with 1 is 9 * 10^(n-1)\n    # The number of n-digit numbers that end with 1 is 9 * 10^(n-1)\n    # The number of n-digit numbers that start and end with 1 is 9 * 10^(n-2)\n    # So the total number of n-digit numbers that start or end with 1 is:\n    # 9 * 10^(n-1) + 9 * 10^(n-1) - 9 * 10^(n-2)\n    # Simplifying:\n    # 2 * 9 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n-1) - 9 * 10^(n-2)\n    # 18 * 10^(n"}
{"idx": 84, "completion": "# Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to a binary string\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by row ascending, then by column descending\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted_string = \"\"\n    for char in s:\n        # Shift each character down by 2 * 2 = 4 places\n        encrypted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        encrypted_string += encrypted_char\n    return encrypted_string"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst_sorted = sorted(lst)\n    smallest = lst_sorted[0]\n    for num in lst_sorted:\n        if num > smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # Check if one of the numbers is equal to the sum of the other two\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False"}
{"idx": 93, "completion": "vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                encoded_char = vowels[char.lower()]\n                if char.isupper():\n                    encoded_char = encoded_char.upper()\n            else:\n                encoded_char = char.swapcase()\n            encoded_message += encoded_char\n        else:\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    return unit_digit_a * unit_digit_b"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "words = []\n    current_word = \"\"\n    for char in s:\n        if char == ' ' or char == ',':\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n        else:\n            current_word += char\n    if current_word:\n        words.append(current_word)\n    return words"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    for num in range(y, x - 1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2\n    if (n + m) % 2 != 0:\n        avg += 1\n    return bin(avg)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            sum_i = sum(range(1, i+1))\n            result.append(sum_i)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for i in range(1, n + 1):\n        if is_palindrome(i):\n            if i % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sign = -1\n        else:\n            sign = 1\n        digit_sum = 0\n        while num > 0:\n            digit_sum += sign * (num % 10)\n            num //= 10\n        if digit_sum > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    # Find the index of the minimum element\n    min_index = arr.index(min(arr))\n\n    # Check if the array can be sorted by rotating\n    for i in range(1, n):\n        if arr[(min_index + i) % n] < arr[(min_index + i - 1) % n]:\n            return False\n\n    return True"}
{"idx": 110, "completion": "# Count the number of odd numbers in lst1\n    odd_count = sum(1 for x in lst1 if x % 2 != 0)\n    \n    # If there are no odd numbers in lst1, it's already all even\n    if odd_count == 0:\n        return \"YES\"\n    \n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n    \n    # If there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_lst2 >= odd_count:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    # Split the string into a list of words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate over each word in the list\n    for word in words:\n        # Iterate over each letter in the word\n        for letter in word:\n            # If the letter is already in the dictionary, increment its count\n            if letter in letter_count:\n                letter_count[letter] += 1\n            # If the letter is not in the dictionary, add it with a count of 1\n            else:\n                letter_count[letter] = 1\n    \n    # Find the maximum count\n    max_count = max(letter_count.values()) if letter_count else 0\n    \n    # Create a dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate over the letter count dictionary\n    for letter, count in letter_count.items():\n        # If the count is equal to the maximum count, add it to the max_letters dictionary\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Step 1: Remove all characters in s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Step 3: Return the result as a tuple\n    return (result_string, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n\n    for num in nums:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the number of times to lower the buckets\n    times = 0\n\n    # Iterate over each row in the grid\n    for row in grid:\n        # Count the number of 1s in the current row\n        water_units = row.count(1)\n        # If there are water units in the well, calculate the number of times to lower the bucket\n        if water_units > 0:\n            # Calculate the number of times to lower the bucket to empty the well\n            times += math.ceil(water_units / capacity)\n\n    return times"}
{"idx": 116, "completion": "# Define a function to count the number of ones in the binary representation\n    def count_ones(n):\n        return bin(n).count('1')\n\n    # Sort the array based on the number of ones in binary, then by decimal value\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n\n    return sorted_arr"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    words = s.split()\n    for word in words:\n        consonant_count = sum(1 for char in word if char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    for i in range(len(word)-1, 1, -1):\n        if word[i] in consonants and word[i-1] in vowels and word[i-2] in consonants:\n            return word[i-1]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Take the last k elements from the sorted array\n    max_k = sorted_arr[-k:]\n    \n    return max_k"}
{"idx": 121, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total"}
{"idx": 122, "completion": "sum = 0\n    for i in range(min(k, len(arr))):\n        if arr[i] < 100 and arr[i] > -100:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = sorted([x for x in collatz_sequence if x % 2 != 0])\n    return odd_numbers"}
{"idx": 124, "completion": "# Check if the date string is not empty\n    if not date:\n        return False\n    \n    # Check if the date format is mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    odd_count += 1\n        return odd_count"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n        if lst[i] == lst[i + 1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the intersection of the two intervals\n    intersection_start = max(start1, start2)\n    intersection_end = min(end1, end2)\n    \n    # Check if the intervals intersect\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = intersection_end - intersection_start + 1\n    \n    # Check if the length is a prime number\n    if intersection_length < 2:\n        return \"NO\"\n    for i in range(2, int(intersection_length ** 0.5) + 1):\n        if intersection_length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "import heapq\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize a priority queue with all possible starting points\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], i, j, [grid[i][j]]))\n\n    while pq:\n        current_val, x, y, path = heapq.heappop(pq)\n        if len(path) == k:\n            return path\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < N:\n                new_path = path + [grid[nx][ny]]\n                heapq.heappush(pq, (grid[nx][ny], nx, ny, new_path))\n\n    return []"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    sequence = [1]\n    if n == 0:\n        return sequence\n    sequence.append(3)\n    if n == 1:\n        return sequence\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sequence.append(1 + i // 2)\n        else:\n            sequence.append(sequence[i - 1] + sequence[i - 2] + sequence[i + 1])\n    return sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n = n // 10\n    if has_odd:\n        return product\n    else:\n        return 0"}
{"idx": 132, "completion": "# Your code here\n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if txt == \"\":\n        return False\n    last_char = txt[-1]\n    if last_char.isalpha():\n        if txt.endswith(' '):\n            return False\n        else:\n            return True\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [num for num in lst if num < 0]\n    positive_integers = [num for num in lst if num > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "def to_number(s):\n        try:\n            return float(s.replace(',', '.'))\n        except:\n            return s\n\n    a_val = to_number(a)\n    b_val = to_number(b)\n\n    if a_val > b_val:\n        return a\n    elif b_val > a_val:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 == 0:\n        return True\n    return False"}
{"idx": 139, "completion": "factorial = 1\n    result = 1\n    for i in range(1, n+1):\n        factorial *= i\n        result *= factorial\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub('_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if there is exactly one dot in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Check if the substring before the dot is not empty and starts with a letter\n    if not name or not name[0].isalpha():\n        return 'No'\n    \n    # Check if the substring after the dot is one of the allowed extensions\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # Count the number of digits in the file name\n    digit_count = sum(1 for char in file_name if char.isdigit())\n    \n    # Check if there are not more than three digits in the file name\n    if digit_count > 3:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    # Calculate the product of the two fractions\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start < end:\n        return tuple(planets[start+1:end])\n    else:\n        return tuple(planets[end+1:start])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if n > 1:\n        for i in range(2, int(n**0.5)+1):\n            if n % i == 0:\n                return y\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "sum_of_squares = 0\n    for number in lst:\n        if isinstance(number, int) and number > 0 and number % 2 != 0:\n            sum_of_squares += number ** 2\n    return sum_of_squares"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for c in extension if c.isupper())\n        SM = sum(1 for c in extension if c.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num //= 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# First, we need to check if the given sides can form a triangle.\n    # The triangle inequality theorem states that the sum of the lengths of any two sides\n    # of a triangle must be greater than the length of the remaining side.\n    if a + b > c and a + c > b and b + c > a:\n        # If the triangle inequality theorem holds, we then check if it's a right-angled triangle.\n        # A triangle is right-angled if the square of the length of the longest side\n        # is equal to the sum of squares of the lengths of the other two sides.\n        # This is known as the Pythagorean theorem.\n        sides = [a, b, c]\n        sides.sort()\n        return sides[0]**2 + sides[1]**2 == sides[2]**2\n    else:\n        # If the triangle inequality theorem does not hold, the sides cannot form a triangle.\n        return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "# Calculate the total number of carrots eaten\n    total_eaten = number + min(need, remaining)\n    \n    # Calculate the number of carrots left\n    carrots_left = max(remaining - need, 0)\n    \n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(d) % 2 == 0 for d in str(i))]"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current.append(char)\n\n        if depth == 0:\n            result.append(''.join(current))\n            current = []\n\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result"}
{"idx": 6, "completion": "result = []\n    for group in paren_string.split():\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        result.append(max_depth)\n    return result"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_result = sum(numbers)\n    product_result = 1\n    for num in numbers:\n        product_result *= num\n    return (sum_result, product_result)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for number in numbers:\n        if current_max is None or number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return \"\"\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join(str(int(c1) ^ int(c2)) for c1, c2 in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "# Create a dictionary to map each note to its corresponding duration\n    note_durations = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the input string into individual note representations\n    notes = music_string.split()\n    \n    # Convert each note representation to its corresponding duration\n    durations = [note_durations[note] for note in notes]\n    \n    return durations"}
{"idx": 18, "completion": "if not string or not substring:\n        return 0\n    count = 0\n    i = 0\n    while i <= len(string) - len(substring):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n            i += len(substring) - 1\n        i += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "numbers.sort()\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[0] - numbers[1])\n\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i] - numbers[i + 1])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "min_num = min(numbers)\n    max_num = max(numbers)\n    return [(x - min_num) / (max_num - min_num) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"}
{"idx": 25, "completion": "factors = []\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n            factors.append(i)\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    if n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5) + 1, 2):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "if len(xs) % 2 == 1:\n        raise ValueError(\"The number of coefficients must be even.\")\n\n    a = xs[-1]\n    b = xs[-2]\n\n    if a == 0:\n        raise ValueError(\"The largest coefficient must be non-zero.\")\n\n    x = -b / a\n    return x"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "if not l:\n        return None\n    max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices_sorted = sorted(even_indices)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indices_sorted[i // 2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 0, 1\n    while True:\n        if is_prime(b):\n            count += 1\n            if count == n:\n                return b\n        a, b = b, a + b"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "assert base < 10\n    if x == 0:\n        return \"0\"\n    digits = []\n    while x:\n        digits.append(str(x % base))\n        x //= base\n    return \"\".join(digits[::-1])"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "if not text:\n        return True\n    if text[0] != text[-1]:\n        return False\n    return is_palindrome(text[1:-1])"}
{"idx": 49, "completion": "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    else:\n        return (2 * modp(n - 1, p)) % p"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    for vowel in vowels:\n        text = text.replace(vowel, '')\n    return text"}
{"idx": 52, "completion": "for i in l:\n        if i >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 0:\n        raise ValueError(\"Fibonacci index cannot be negative.\")\n    if n == 0:\n        return 0\n    a, b = 0, 1\n    for _ in range(1, n):\n        a, b = b, a + b\n    return b"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "return all(x <= y for x, y in zip(l, l[1:])) or all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1) & set(l2))"}
{"idx": 59, "completion": "# Start with the smallest prime number\n    factor = 2\n    while n != 1:\n        if n % factor == 0:\n            n = n // factor\n        else:\n            factor += 1\n    return factor"}
{"idx": 60, "completion": "return sum(range(1, n + 1))"}
{"idx": 61, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        elif bracket == \")\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s and s[-1].lower() == 'y':\n        count += 1\n    return count"}
{"idx": 65, "completion": "s = str(x)\n    shift = shift % len(s)\n    return s[-shift:] + s[:-shift]"}
{"idx": 66, "completion": "total = 0\n    for char in s:\n        if char.isupper():\n            total += ord(char)\n    return total"}
{"idx": 67, "completion": "# Split the string by spaces\n    parts = s.split()\n    \n    # Extract the number of apples\n    apples = int(parts[0])\n    \n    # Extract the number of oranges\n    oranges = int(parts[2])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if min_even is None or value < min_even:\n                min_even = value\n                min_index = index\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    result = -1\n    for num, count in freq.items():\n        if count >= num:\n            if result == -1 or num > result:\n                result = num\n    return result"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    return result"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1"}
{"idx": 72, "completion": "if sum(q) > w:\n        return False\n    return q == q[::-1]"}
{"idx": 73, "completion": "n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "def count_chars(lst):\n        return sum(len(s) for s in lst)\n\n    count1 = count_chars(lst1)\n    count2 = count_chars(lst2)\n\n    if count1 <= count2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n ** power <= x:\n        if n ** power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    return round(a ** (1/3)) ** 3 == a"}
{"idx": 78, "completion": "# Define the prime digits in hexadecimal\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate through each character in the input string\n    for char in num:\n        # Check if the character is a prime digit\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary_representation = bin(decimal)[2:]\n    return f\"db{binary_representation}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1  # Only the number 1 itself\n    else:\n        # For n-digit numbers, the first digit can be 1 (1 way) and the last digit can be 1 (1 way).\n        # The remaining (n-2) digits can be any digit from 0 to 9 (10^(n-2) ways).\n        return 1 * 10**(n-2) + 1 * 10**(n-2) - 1 * 1 * 10**(n-2)"}
{"idx": 84, "completion": "# Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to a binary string\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum(lst[i] for i in range(1, len(lst), 2) if lst[i] % 2 == 0)"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if 'a' <= char <= 'z':\n            encrypted += chr((ord(char) - ord('a') + 2 * 2) % 26 + ord('a'))\n        elif 'A' <= char <= 'Z':\n            encrypted += chr((ord(char) - ord('A') + 2 * 2) % 26 + ord('A'))\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst_sorted = sorted(lst)\n    smallest = lst_sorted[0]\n    for num in lst_sorted:\n        if num > smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.strip().startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # Check if one of the numbers is equal to the sum of the other two\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False"}
{"idx": 93, "completion": "vowels = {'a': 'c', 'e': 'g', 'i': 'k', 'o': 'q', 'u': 'w'}\n    encoded_message = ''\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                encoded_char = vowels[char.lower()]\n                if char.isupper():\n                    encoded_char = encoded_char.upper()\n                encoded_message += encoded_char\n            else:\n                encoded_message += char.swapcase()\n        else:\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    digit_sum = sum(int(digit) for digit in str(max_prime))\n    return digit_sum"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Get the unit digits of both numbers\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = set(\"AEIOU\")\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "words = []\n    current_word = \"\"\n    for char in s:\n        if char == ' ' or char == ',':\n            if current_word:\n                words.append(current_word)\n                current_word = \"\"\n        else:\n            current_word += char\n    if current_word:\n        words.append(current_word)\n    return words"}
{"idx": 102, "completion": "# First, we need to ensure that x is less than or equal to y\n    if x > y:\n        return -1\n\n    # Initialize the result as -1, assuming there is no even number in the range\n    result = -1\n\n    # Loop through the range from x to y (inclusive)\n    for num in range(x, y + 1):\n        # Check if the number is even\n        if num % 2 == 0:\n            # If it is, update the result with the current even number\n            result = num\n\n    # Return the result, which will be the largest even number in the range or -1 if none exists\n    return result"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2\n    if (n + m) % 2 != 0:\n        avg += 1\n    return bin(avg)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "# Filter the array to include only integers between 1 and 9 inclusive\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array in ascending order\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Calculate factorial for even i\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum for odd i\n            total = sum(range(1, i+1))\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        sum_digits = 0\n        for digit in str(num):\n            if digit == '-':\n                continue\n            sum_digits += int(digit)\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    \n    n = len(arr)\n    sorted_arr = sorted(arr)\n    \n    for i in range(n):\n        if arr == sorted_arr[i:] + sorted_arr[:i]:\n            return True\n    return False"}
{"idx": 110, "completion": "# Check if lst1 is already all even\n    if all(x % 2 == 0 for x in lst1):\n        return \"YES\"\n\n    # Check if there are any even numbers in lst2 to replace the odd numbers in lst1\n    if any(x % 2 == 0 for x in lst2):\n        # Count the number of odd numbers in lst1\n        odd_count_lst1 = sum(1 for x in lst1 if x % 2 != 0)\n        # Count the number of even numbers in lst2\n        even_count_lst2 = sum(1 for x in lst2 if x % 2 == 0)\n        # If there are enough even numbers in lst2 to replace all odd numbers in lst1, return \"YES\"\n        if even_count_lst2 >= odd_count_lst1:\n            return \"YES\"\n\n    # If none of the above conditions are met, return \"NO\"\n    return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    # Split the string into a list of words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    # Iterate through each word in the list\n    for word in words:\n        # Iterate through each character in the word\n        for char in word:\n            # If the character is already in the dictionary, increment its count\n            if char in letter_count:\n                letter_count[char] += 1\n            # If the character is not in the dictionary, add it with a count of 1\n            else:\n                letter_count[char] = 1\n    \n    # Find the maximum count in the dictionary\n    max_count = max(letter_count.values(), default=0)\n    \n    # Create a new dictionary to store the letters with the maximum count\n    max_letters = {}\n    \n    # Iterate through the dictionary to find the letters with the maximum count\n    for letter, count in letter_count.items():\n        if count == max_count:\n            max_letters[letter] = count\n    \n    return max_letters"}
{"idx": 112, "completion": "# Delete all characters in s that are in c\n    result = ''.join([char for char in s if char not in c])\n    \n    # Check if the result string is a palindrome\n    is_palindrome = result == result[::-1]\n    \n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_digits = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the number of times to lower the buckets\n    times = 0\n\n    # Iterate over each well in the grid\n    for well in grid:\n        # Count the number of units of water in the well\n        water_units = well.count(1)\n        # If there are water units, calculate the number of times to lower the bucket\n        if water_units > 0:\n            # Use ceiling division to ensure we round up in case of a remainder\n            times += math.ceil(water_units / capacity)\n\n    return times"}
{"idx": 116, "completion": "# If the array is empty, return it as is\n    if not arr:\n        return arr\n\n    # Define a function to count the number of 1s in the binary representation of a number\n    def count_ones(n):\n        return bin(n).count('1')\n\n    # Sort the array based on the number of 1s in the binary representation\n    # If two numbers have the same number of 1s, sort based on their decimal value\n    sorted_arr = sorted(arr, key=lambda x: (count_ones(x), x))\n\n    return sorted_arr"}
{"idx": 117, "completion": "vowels = set(\"aeiouAEIOU\")\n    result = []\n    \n    for word in s.split():\n        consonant_count = sum(1 for char in word if char not in vowels)\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    \n    for i in range(len(word)-1, 0, -1):\n        if word[i] in vowels:\n            # Check if both the previous and next characters are consonants\n            if i > 0 and i < len(word)-1:\n                if word[i-1] in consonants and word[i+1] in consonants:\n                    return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for char in s:\n            if char == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    arr_sorted = sorted(arr)\n    \n    # Take the last k elements which are the largest\n    max_k = arr_sorted[-k:]\n    \n    return max_k"}
{"idx": 121, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total"}
{"idx": 122, "completion": "# Initialize sum to 0\n    total_sum = 0\n\n    # Iterate over the first k elements of the array\n    for i in range(min(k, len(arr))):\n        # Check if the current element has at most two digits\n        if arr[i] < 100 and arr[i] > -100:\n            # Add the element to the sum\n            total_sum += arr[i]\n\n    return total_sum"}
{"idx": 123, "completion": "collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "# Check if the date string is not empty\n    if not date:\n        return False\n    \n    # Check if the date format is mm-dd-yyyy\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    try:\n        month, day, year = map(int, date.split('-'))\n    except ValueError:\n        return False\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check the number of days based on the month\n    if month in {1, 3, 5, 7, 8, 10, 12}:\n        if day < 1 or day > 31:\n            return False\n    elif month in {4, 6, 9, 11}:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        if day < 1 or day > 29:\n            return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    odd_count += 1\n        return odd_count"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n        if lst[i] == lst[i+1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # Check if the intervals intersect\n    if intersection_start > intersection_end:\n        return \"NO\"\n    \n    # Calculate the length of the intersection\n    intersection_length = intersection_end - intersection_start + 1\n    \n    # Check if the length is a prime number\n    if intersection_length < 2:\n        return \"NO\"\n    \n    for i in range(2, int(intersection_length**0.5) + 1):\n        if intersection_length % i == 0:\n            return \"NO\"\n    \n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        if num > 0:\n            sign = 1\n        elif num < 0:\n            sign = -1\n        else:\n            sign = 0\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return sum_of_magnitudes * product_of_signs"}
{"idx": 129, "completion": "import heapq\n\n    N = len(grid)\n    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n\n    # Initialize a priority queue with all starting positions\n    pq = []\n    for i in range(N):\n        for j in range(N):\n            heapq.heappush(pq, (grid[i][j], [(i, j)], [grid[i][j]]))\n\n    # Perform BFS with priority queue\n    while pq:\n        current_value, path, values = heapq.heappop(pq)\n        if len(values) == k:\n            return values\n        last_i, last_j = path[-1]\n        for di, dj in directions:\n            ni, nj = last_i + di, last_j + dj\n            if 0 <= ni < N and 0 <= nj < N and (ni, nj) not in path:\n                new_values = values + [grid[ni][nj]]\n                heapq.heappush(pq, (new_values[0], path + [(ni, nj)], new_values))\n\n    return []"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    \n    tribonacci = [1, 3]\n    \n    if n == 0:\n        return tribonacci\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci.append(1 + i // 2)\n        else:\n            tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1])\n    \n    return tribonacci"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if txt == \"\":\n        return False\n    words = txt.split()\n    if not words:\n        return False\n    last_word = words[-1]\n    last_char = last_word[-1]\n    return last_char.isalpha() and last_char not in last_word[:-1]"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [x for x in lst if x < 0]\n    positive_integers = [x for x in lst if x > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Replace comma with dot for proper float conversion\n    if isinstance(a, str):\n        a = a.replace(',', '.')\n    if isinstance(b, str):\n        b = b.replace(',', '.')\n    \n    # Convert to float for comparison\n    try:\n        a_val = float(a)\n        b_val = float(b)\n    except ValueError:\n        return None\n    \n    # Compare the values\n    if a_val > b_val:\n        return a if isinstance(a, (int, float)) else str(a)\n    elif b_val > a_val:\n        return b if isinstance(b, (int, float)) else str(b)\n    else:\n        return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 == 0:\n        return True\n    return False"}
{"idx": 139, "completion": "# Calculate the factorial of a number\n    def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        else:\n            return x * factorial(x - 1)\n\n    # Calculate the special factorial\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Find all sequences of more than 2 underscores\n    import re\n    text = re.sub(r'_{3,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if the name starts with a latin alphapet letter\n    if not name[0].isalpha():\n        return 'No'\n    \n    # Check if there are more than three digits in the name\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = x.split('/')\n    n_num, n_den = n.split('/')\n    \n    # Convert the numerator and denominator to integers\n    x_num = int(x_num)\n    x_den = int(x_den)\n    n_num = int(n_num)\n    n_den = int(n_den)\n    \n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    def digit_sum(n):\n        return sum(int(d) for d in str(abs(n)))\n\n    indexed_nums = list(enumerate(nums))\n    sorted_nums = sorted(indexed_nums, key=lambda x: (digit_sum(x[1]), x[0]))\n    return [num for idx, num in sorted_nums]"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start > end:\n        start, end = end, start\n    return tuple(planets[start+1:end])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if n > 1:\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return y\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if isinstance(x, int) and x > 0 and x % 2 != 0)"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# First, we need to check if the given sides can form a triangle.\n    # The sum of the lengths of any two sides must be greater than the length of the remaining side.\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # Next, we need to check if the triangle is a right-angled triangle.\n    # We can use the Pythagorean theorem for this purpose.\n    # The theorem states that in a right-angled triangle, the square of the length of the hypotenuse (the side opposite the right angle)\n    # is equal to the sum of squares of the lengths of the other two sides.\n    # We can check this by comparing the square of the longest side with the sum of squares of the other two sides.\n    \n    # First, let's find the longest side.\n    sides = [a, b, c]\n    hypotenuse = max(sides)\n    \n    # Now, let's remove the hypotenuse from the list of sides.\n    sides.remove(hypotenuse)\n    \n    # Now, let's calculate the sum of squares of the other two sides.\n    sum_of_squares = sides[0] ** 2 + sides[1] ** 2\n    \n    # Finally, let's compare the sum of squares with the square of the hypotenuse.\n    if sum_of_squares == hypotenuse ** 2:\n        return True\n    else:\n        return False"}
{"idx": 158, "completion": "# Initialize variables to store the maximum number of unique characters and the corresponding word\n    max_unique = 0\n    max_word = \"\"\n\n    # Iterate through each word in the list\n    for word in words:\n        # Convert the word to a set to find unique characters and count them\n        unique_chars = set(word)\n        num_unique = len(unique_chars)\n\n        # Check if the current word has more unique characters than the previous maximum\n        if num_unique > max_unique:\n            max_unique = num_unique\n            max_word = word\n        # If the number of unique characters is the same, choose the lexicographically smaller word\n        elif num_unique == max_unique:\n            if word < max_word:\n                max_word = word\n\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    result = \"\"\n    for c in s:\n        if c.isalpha():\n            if c.islower():\n                result += c.upper()\n            else:\n                result += c.lower()\n        else:\n            result += c\n    return result"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    import hashlib\n    return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(d) % 2 == 0 for d in str(i))]"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "paren_string = paren_string.replace(\" \", \"\")\n    result = []\n    current = []\n    depth = 0\n\n    for char in paren_string:\n        if char == '(':\n            depth += 1\n        elif char == ')':\n            depth -= 1\n        current.append(char)\n        if depth == 0:\n            result.append(''.join(current))\n            current = []\n\n    return result"}
{"idx": 2, "completion": "return number % 1"}
{"idx": 3, "completion": "balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_deviations = [abs(number - mean) for number in numbers]\n    return sum(absolute_deviations) / len(absolute_deviations)"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    interspersed_numbers = [numbers[0]]\n    for number in numbers[1:]:\n        interspersed_numbers.append(delimeter)\n        interspersed_numbers.append(number)\n    return interspersed_numbers"}
{"idx": 6, "completion": "paren_groups = paren_string.split()\n    max_depths = []\n    for group in paren_groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                current_depth -= 1\n        max_depths.append(max_depth)\n    return max_depths"}
{"idx": 7, "completion": "return [string for string in strings if substring in string]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_numbers = sum(numbers)\n    product_numbers = 1\n    for number in numbers:\n        product_numbers *= number\n    return (sum_numbers, product_numbers)"}
{"idx": 9, "completion": "max_list = []\n    current_max = None\n    for number in numbers:\n        if current_max is None or number > current_max:\n            current_max = number\n        max_list.append(current_max)\n    return max_list"}
{"idx": 10, "completion": "if not string:\n        return string\n\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "return ''.join('0' if x == y else '1' for x, y in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    return max(strings, key=len)"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "return [string[:i] for i in range(1, len(string) + 1)]"}
{"idx": 15, "completion": "return ' '.join(str(i) for i in range(n + 1))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "# Create a dictionary to map each note to its corresponding number of beats\n    note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    \n    # Split the music_string into individual note components\n    notes = music_string.split()\n    \n    # Convert each note to its corresponding number of beats using the dictionary\n    beats = [note_to_beats[note] for note in notes]\n    \n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string)):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "num_dict = {'zero': 0, 'one': 1, 'two': 2, 'three': 3, 'four': 4, 'five': 5, 'six': 6, 'seven': 7, 'eight': 8, 'nine': 9}\n    num_list = numbers.split()\n    num_list.sort(key=lambda x: num_dict[x])\n    return ' '.join(num_list)"}
{"idx": 20, "completion": "numbers.sort()\n    min_diff = float('inf')\n    result = (numbers[0], numbers[1])\n\n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i - 1], numbers[i])\n\n    return result"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"}
{"idx": 22, "completion": "return [value for value in values if isinstance(value, int)]"}
{"idx": 23, "completion": "return len(string)"}
{"idx": 24, "completion": "for i in range(n - 1, 0, -1):\n        if n % i == 0:\n            return i"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n >= 2:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        else:\n            divisor += 1\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            result.append(num)\n            seen.add(num)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    # find the interval [a, b] such that f(a) * f(b) < 0\n    a = 0\n    b = 1\n    while poly(xs, a) * poly(xs, b) > 0:\n        a = a - 1\n        b = b + 1\n    # now we have a and b such that f(a) * f(b) < 0\n    # we can use binary search to find the zero point\n    while b - a > 1e-6:\n        c = (a + b) / 2\n        if poly(xs, c) * poly(xs, a) < 0:\n            b = c\n        else:\n            a = c\n    return (a + b) / 2"}
{"idx": 33, "completion": "l_prime = l.copy()\n    for i in range(0, len(l), 3):\n        if i + 2 < len(l):\n            l_prime[i:i+3] = sorted(l[i:i+3])\n    return l_prime"}
{"idx": 34, "completion": "return sorted(set(l))"}
{"idx": 35, "completion": "max_el = l[0]\n    for el in l:\n        if el > max_el:\n            max_el = el\n    return max_el"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices_sorted = sorted(even_indices)\n    l_prime = l.copy()\n    l_prime[::2] = even_indices_sorted\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group back. Unless group has fewer elements than 3.\n    groups = [(group[2] + group[:2]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "if n < 1:\n        raise ValueError(\"n must be a positive integer\")\n\n    def is_prime(x):\n        if x < 2:\n            return False\n        for i in range(2, int(x**0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    fib_sequence = [0, 1]\n    count = 0\n    while count < n:\n        next_fib = fib_sequence[-1] + fib_sequence[-2]\n        fib_sequence.append(next_fib)\n        if is_prime(next_fib):\n            count += 1\n    return fib_sequence[-1]"}
{"idx": 40, "completion": "if len(l) < 3:\n        return False\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x < 0:\n        return \"-\" + change_base(-x, base)\n    if x < base:\n        return str(x)\n    return change_base(x // base, base) + str(x % base)"}
{"idx": 45, "completion": "return a * h / 2"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2] + l[len(l) // 2 - 1]) / 2\n    else:\n        return l[len(l) // 2]"}
{"idx": 48, "completion": "if text == text[::-1]:\n        return True\n    else:\n        return False"}
{"idx": 49, "completion": "if n == 0:\n        return 1\n    if n % 2 == 0:\n        return (modp(n // 2, p) ** 2) % p\n    else:\n        return (2 * modp(n - 1, p)) % p"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = 'aeiouAEIOU'\n    return ''.join(char for char in text if char not in vowels)"}
{"idx": 52, "completion": "return all(x < t for x in l)"}
{"idx": 53, "completion": "return x + y"}
{"idx": 54, "completion": "return sorted(s0) == sorted(s1)"}
{"idx": 55, "completion": "if n < 2:\n        return n\n    return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "count = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            count += 1\n        elif bracket == \">\":\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 57, "completion": "if l[0] < l[-1]:\n        return all(x <= y for x, y in zip(l, l[1:]))\n    else:\n        return all(x >= y for x, y in zip(l, l[1:]))"}
{"idx": 58, "completion": "return sorted(set(l1).intersection(set(l2)))"}
{"idx": 59, "completion": "# Start with the smallest prime number\n    factor = 2\n    while n != 1:\n        if n % factor == 0:\n            n = n // factor\n        else:\n            factor += 1\n    return factor"}
{"idx": 60, "completion": "return sum(range(1, n + 1))"}
{"idx": 61, "completion": "\"\"\"\n    The problem is to determine if a given string of brackets is correctly bracketed. \n    This means that every opening bracket '(' has a corresponding closing bracket ')'. \n    To solve this, we can use a stack-based approach, which is a common method for matching brackets.\n\n    Here's a step-by-step breakdown of the approach:\n\n    1. Initialize an empty stack.\n    2. Iterate through each character in the string:\n        a. If the character is an opening bracket '(', push it onto the stack.\n        b. If the character is a closing bracket ')':\n            i. If the stack is empty, return False because there's no corresponding opening bracket.\n            ii. If the stack is not empty, pop the top element from the stack.\n    3. After iterating through the string, if the stack is empty, return True because all opening brackets have been matched.\n    4. If the stack is not empty, return False because there are unmatched opening brackets.\n\n    This approach ensures that each bracket is checked and matched in a linear pass through the string, making it efficient with a time complexity of O(n), where n is the length of the string.\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == '(':\n            stack.append(bracket)\n        elif bracket == ')':\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "return [xs[i] * i for i in range(1, len(xs))]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = set('aeiouAEIOU')\n    count = 0\n    for char in s:\n        if char in vowels:\n            count += 1\n    if s.endswith('y') or s.endswith('Y'):\n        count += 1\n    return count"}
{"idx": 65, "completion": "digits = str(x)\n    shift = shift % len(digits)\n    return digits[-shift:] + digits[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string by spaces\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[3])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = float('inf')\n    min_index = -1\n    \n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if value < min_even:\n                min_even = value\n                min_index = index\n    \n    if min_even == float('inf'):\n        return []\n    else:\n        return [min_even, min_index]"}
{"idx": 69, "completion": "frequency = {}\n    for num in lst:\n        if num in frequency:\n            frequency[num] += 1\n        else:\n            frequency[num] = 1\n    \n    valid_numbers = []\n    for num, count in frequency.items():\n        if count >= num:\n            valid_numbers.append(num)\n    \n    if valid_numbers:\n        return max(valid_numbers)\n    else:\n        return -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = sorted(lst)\n    result = []\n    i = 0\n    j = len(sorted_lst) - 1\n    while i <= j:\n        if i == j:\n            result.append(sorted_lst[i])\n        else:\n            result.append(sorted_lst[i])\n            result.append(sorted_lst[j])\n        i += 1\n        j -= 1\n    return result"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Return the area rounded to 2 decimal points\n        return round(area, 2)\n    else:\n        # Return -1 if the sides do not form a valid triangle\n        return -1"}
{"idx": 72, "completion": "return q == q[::-1] and sum(q) <= w"}
{"idx": 73, "completion": "n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - i - 1]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars_lst1 = sum(len(s) for s in lst1)\n    total_chars_lst2 = sum(len(s) for s in lst2)\n    \n    # Compare the total number of characters and return the appropriate list\n    if total_chars_lst1 <= total_chars_lst2:\n        return lst1\n    else:\n        return lst2"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for i in range(2, a):\n        for j in range(2, i):\n            if i % j == 0:\n                break\n        else:\n            primes.append(i)\n    for i in primes:\n        for j in primes:\n            for k in primes:\n                if i * j * k == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if n == 1:\n        return x == 1\n    power = 0\n    while n**power <= x:\n        if n**power == x:\n            return True\n        power += 1\n    return False"}
{"idx": 77, "completion": "if a < 0:\n        a = -a\n    if a == 0:\n        return True\n    low = 1\n    high = a\n    while low <= high:\n        mid = (low + high) // 2\n        if mid ** 3 == a:\n            return True\n        elif mid ** 3 < a:\n            low = mid + 1\n        else:\n            high = mid - 1\n    return False"}
{"idx": 78, "completion": "# Define the hexadecimal digits that are prime\n    prime_digits = {'2', '3', '5', '7', 'B', 'D'}\n    \n    # Initialize a counter for prime digits\n    prime_count = 0\n    \n    # Iterate over each character in the input string\n    for char in num:\n        # If the character is a prime digit, increment the counter\n        if char in prime_digits:\n            prime_count += 1\n    \n    return prime_count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i + 1] or s[i] == s[i + 2] or s[i + 1] == s[i + 2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        elif gpa == 0.0:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n\n    return is_prime(len(string))"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    else:\n        return 18 * (10 ** (n - 2))"}
{"idx": 84, "completion": "# Calculate the sum of the digits of N\n    digit_sum = sum(int(digit) for digit in str(N))\n    \n    # Convert the sum to a binary string\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum([lst[i] for i in range(len(lst)) if lst[i] % 2 == 0 and i % 2 != 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "coordinates = []\n    for i, row in enumerate(lst):\n        for j, value in enumerate(row):\n            if value == x:\n                coordinates.append((i, j))\n    # Sort by rows in ascending order and by columns in descending order\n    coordinates.sort(key=lambda coord: (coord[0], -coord[1]))\n    return coordinates"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    sum_first_last = array[0] + array[-1]\n    if sum_first_last % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)"}
{"idx": 89, "completion": "encrypted_string = \"\"\n    for char in s:\n        # Calculate the new character by shifting it down by 2 * 2 = 4 places\n        new_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n        encrypted_string += new_char\n    return encrypted_string"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst_sorted = sorted(lst)\n    smallest = lst_sorted[0]\n    for num in lst_sorted:\n        if num > smallest:\n            return num\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.')\n    sentences += S.split('?')\n    sentences += S.split('!')\n    count = 0\n    for sentence in sentences:\n        if sentence.startswith('I'):\n            count += 1\n    return count"}
{"idx": 92, "completion": "# Check if all numbers are integers\n    if isinstance(x, int) and isinstance(y, int) and isinstance(z, int):\n        # Check if one of the numbers is equal to the sum of the other two\n        if x == y + z or y == x + z or z == x + y:\n            return True\n    return False"}
{"idx": 93, "completion": "vowels = \"aeiou\"\n    encoded_message = \"\"\n    for char in message:\n        if char.isalpha():\n            if char.lower() in vowels:\n                # Find the index of the vowel in the vowels string\n                index = vowels.find(char.lower())\n                # Find the next vowel by wrapping around using modulo\n                next_vowel = vowels[(index + 2) % len(vowels)]\n                # Preserve the case of the original character\n                if char.isupper():\n                    encoded_message += next_vowel.upper()\n                else:\n                    encoded_message += next_vowel\n            else:\n                # Swap the case of the consonant\n                if char.isupper():\n                    encoded_message += char.lower()\n                else:\n                    encoded_message += char.upper()\n        else:\n            # Non-alphabetic characters remain unchanged\n            encoded_message += char\n    return encoded_message"}
{"idx": 94, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n\n    if max_prime == -1:\n        return 0\n\n    return sum(int(digit) for digit in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if not all(isinstance(key, str) for key in keys):\n        return False\n    \n    if all(key.islower() for key in keys):\n        return True\n    elif all(key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digits\n    unit_digit_a = abs(a) % 10\n    unit_digit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_digit_a * unit_digit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    vowels = {'A', 'E', 'I', 'O', 'U'}\n    for i, char in enumerate(s):\n        if i % 2 == 0 and char.isupper() and char in vowels:\n            count += 1\n    return count"}
{"idx": 99, "completion": "number = float(value)\n    if number % 1 == 0.5:\n        if number > 0:\n            return int(number) + 1\n        else:\n            return int(number) - 1\n    else:\n        return round(number)"}
{"idx": 100, "completion": "stones = []\n    current = n\n    while len(stones) < n:\n        stones.append(current)\n        if current % 2 == 0:\n            current += 2\n        else:\n            current += 2\n    return stones"}
{"idx": 101, "completion": "# Split the string by both commas and spaces\n    words = s.replace(',', ' ').split()\n    return words"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    for num in range(y, x-1, -1):\n        if num % 2 == 0:\n            return num\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = (n + m) // 2\n    if (n + m) % 2 != 0:\n        avg += 1\n    return bin(avg)"}
{"idx": 104, "completion": "def has_even_digit(n):\n        while n > 0:\n            digit = n % 10\n            if digit % 2 == 0:\n                return True\n            n = n // 10\n        return False\n\n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()\n    return result"}
{"idx": 105, "completion": "# Filter out numbers that are not between 1 and 9\n    filtered_arr = [num for num in arr if 1 <= num <= 9]\n    \n    # Sort the filtered array\n    sorted_arr = sorted(filtered_arr)\n    \n    # Reverse the sorted array\n    reversed_arr = sorted_arr[::-1]\n    \n    # Map each number to its corresponding name\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    # Replace each digit by its corresponding name\n    result = [number_names[num] for num in reversed_arr]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Calculate factorial of i\n            factorial = 1\n            for j in range(1, i+1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum of numbers from 1 to i\n            total = 0\n            for j in range(1, i+1):\n                total += j\n            result.append(total)\n    return result"}
{"idx": 107, "completion": "def is_palindrome(x):\n        return str(x) == str(x)[::-1]\n\n    even_count = 0\n    odd_count = 0\n\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            signed_digits = [-int(d) for d in str(num)]\n        else:\n            signed_digits = [int(d) for d in str(num)]\n        if sum(signed_digits) > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n\n    n = len(arr)\n    sorted_arr = sorted(arr)\n\n    # Find the index of the minimum element in the original array\n    min_index = arr.index(min(arr))\n\n    # Rotate the original array so that the minimum element is at the start\n    rotated_arr = arr[min_index:] + arr[:min_index]\n\n    # Check if the rotated array is sorted\n    if rotated_arr == sorted_arr:\n        return True\n    else:\n        return False"}
{"idx": 110, "completion": "# Check if lst1 is already all even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n\n    # Check if lst2 has any even numbers to replace odd numbers in lst1\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n\n    # Count the number of odd numbers in lst1\n    odd_count_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n\n    # Count the number of even numbers in lst2\n    even_count_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n\n    # If there are enough even numbers in lst2 to replace all odd numbers in lst1\n    if even_count_lst2 >= odd_count_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    # Split the string into individual words\n    words = test.split()\n    \n    # Create a dictionary to store the count of each letter\n    letter_count = {}\n    \n    for word in words:\n        for letter in word:\n            if letter in letter_count:\n                letter_count[letter] += 1\n            else:\n                letter_count[letter] = 1\n    \n    # Find the maximum count\n    max_count = max(letter_count.values(), default=0)\n    \n    # Filter the dictionary to only include letters with the maximum count\n    result = {letter: count for letter, count in letter_count.items() if count == max_count}\n    \n    return result"}
{"idx": 112, "completion": "# Step 1: Remove characters from s that are in c\n    result_string = ''.join([char for char in s if char not in c])\n    \n    # Step 2: Check if the result string is a palindrome\n    is_palindrome = result_string == result_string[::-1]\n    \n    # Step 3: Return the result as a tuple\n    return (result_string, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for i, s in enumerate(lst):\n        odd_count = sum(1 for c in s if int(c) % 2 != 0)\n        result.append(f\"the number of odd elements {odd_count}n the str{odd_count}ng {odd_count} of the {odd_count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = nums[0]\n    current_sum = nums[0]\n    for i in range(1, len(nums)):\n        current_sum = min(nums[i], current_sum + nums[i])\n        min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"idx": 115, "completion": "total_water = 0\n    for row in grid:\n        total_water += sum(row)\n    return math.ceil(total_water / capacity)"}
{"idx": 116, "completion": "# Check if the array contains only non-negative integers\n    if any(x < 0 for x in arr):\n        # If there are negative integers, sort them in descending order\n        return sorted(arr, reverse=True)\n    else:\n        # If all integers are non-negative, sort them based on the number of ones in their binary representation\n        # and then by their decimal value\n        return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "# Split the string into words\n    words = s.split()\n    \n    # Define a set of vowels for quick lookup\n    vowels = set(\"aeiouAEIOU\")\n    \n    # Initialize an empty list to store the result\n    result = []\n    \n    # Iterate over each word\n    for word in words:\n        # Count the number of consonants in the word\n        consonant_count = sum(1 for char in word if char not in vowels and char.isalpha())\n        \n        # If the consonant count matches n, add the word to the result list\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = set(\"aeiouAEIOU\")\n    consonants = set(\"bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ\")\n    for i in range(len(word)-1, 0, -1):\n        if word[i] in vowels:\n            left = i - 1\n            right = i + 1\n            while left >= 0 and word[left] not in consonants:\n                left -= 1\n            while right < len(word) and word[right] not in consonants:\n                right += 1\n            if left >= 0 and right < len(word):\n                return word[i]\n    return \"\""}
{"idx": 119, "completion": "def is_good(s):\n        balance = 0\n        for c in s:\n            if c == '(':\n                balance += 1\n            else:\n                balance -= 1\n            if balance < 0:\n                return False\n        return balance == 0\n\n    s1, s2 = lst\n    if is_good(s1 + s2) or is_good(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "# Sort the array in ascending order\n    sorted_arr = sorted(arr)\n    \n    # Take the last k elements from the sorted array\n    max_k = sorted_arr[-k:]\n    \n    return max_k"}
{"idx": 121, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            total += lst[i]\n    return total"}
{"idx": 122, "completion": "# Initialize a variable to store the sum\n    total_sum = 0\n\n    # Iterate over the first k elements of the array\n    for i in range(min(k, len(arr))):\n        # Check if the current element has at most two digits\n        if arr[i] < 100 and arr[i] > -100:\n            # Add the element to the total sum\n            total_sum += arr[i]\n\n    # Return the total sum\n    return total_sum"}
{"idx": 123, "completion": "if n <= 0:\n        raise ValueError(\"Input must be a positive integer.\")\n    \n    collatz_sequence = []\n    while n != 1:\n        collatz_sequence.append(n)\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n    collatz_sequence.append(1)\n    \n    odd_numbers = sorted([x for x in collatz_sequence if x % 2 != 0])\n    return odd_numbers"}
{"idx": 124, "completion": "import re\n    from datetime import datetime\n    \n    # Check if the date string is not empty\n    if not date:\n        return False\n    \n    # Check if the date string matches the mm-dd-yyyy format\n    if not re.match(r'^\\d{2}-\\d{2}-\\d{4}$', date):\n        return False\n    \n    # Split the date string into month, day, and year\n    month, day, year = map(int, date.split('-'))\n    \n    # Check if the month is between 1 and 12\n    if month < 1 or month > 12:\n        return False\n    \n    # Check if the day is valid for the given month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        # Check for leap year\n        is_leap = (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0)\n        if is_leap:\n            if day < 1 or day > 29:\n                return False\n        else:\n            if day < 1 or day > 28:\n                return False\n    \n    # If all checks pass, return True\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        odd_count = 0\n        for char in txt:\n            if char.islower():\n                if ord(char) % 2 != 0:\n                    odd_count += 1\n        return odd_count"}
{"idx": 126, "completion": "if len(lst) == 1:\n        return True\n    for i in range(len(lst)-1):\n        if lst[i] > lst[i+1]:\n            return False\n        if lst[i] == lst[i+1]:\n            return False\n    return True"}
{"idx": 127, "completion": "# Extract the start and end points of both intervals\n    start1, end1 = interval1\n    start2, end2 = interval2\n    \n    # Find the start of the intersection\n    intersection_start = max(start1, start2)\n    \n    # Find the end of the intersection\n    intersection_end = min(end1, end2)\n    \n    # If the intersection is valid (i.e., start <= end)\n    if intersection_start <= intersection_end:\n        # Calculate the length of the intersection\n        intersection_length = intersection_end - intersection_start + 1\n        \n        # Check if the length is a prime number\n        if is_prime(intersection_length):\n            return \"YES\"\n        else:\n            return \"NO\"\n    else:\n        # If the intervals do not intersect\n        return \"NO\""}
{"idx": 128, "completion": "if not arr:\n        return None\n\n    product_of_signs = 1\n    sum_of_magnitudes = 0\n\n    for num in arr:\n        sign = 0 if num == 0 else (1 if num > 0 else -1)\n        product_of_signs *= sign\n        sum_of_magnitudes += abs(num)\n\n    return product_of_signs * sum_of_magnitudes"}
{"idx": 129, "completion": "N = len(grid)\n    min_path = None\n\n    def dfs(i, j, path, length):\n        nonlocal min_path\n        if length == k:\n            if not min_path or path < min_path:\n                min_path = path.copy()\n            return\n        for ni, nj in [(i-1, j), (i+1, j), (i, j-1), (i, j+1)]:\n            if 0 <= ni < N and 0 <= nj < N:\n                path.append(grid[ni][nj])\n                dfs(ni, nj, path, length + 1)\n                path.pop()\n\n    for i in range(N):\n        for j in range(N):\n            dfs(i, j, [grid[i][j]], 1)\n\n    return min_path"}
{"idx": 130, "completion": "if n < 0:\n        return []\n    \n    tribonacci = [1, 3]\n    \n    if n == 0:\n        return tribonacci\n    \n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            tribonacci.append(1 + i // 2)\n        else:\n            tribonacci.append(tribonacci[i - 1] + tribonacci[i - 2] + tribonacci[i + 1])\n    \n    return tribonacci"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    while n > 0:\n        digit = n % 10\n        if digit % 2 == 1:\n            product *= digit\n            has_odd = True\n        n //= 10\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack:\n                stack.pop()\n            else:\n                return False\n    return False if not stack else True"}
{"idx": 133, "completion": "# Round each element in the list to the upper int (Ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Calculate the sum of squared numbers\n    sum_of_squares = sum(x ** 2 for x in rounded_lst)\n    \n    return sum_of_squares"}
{"idx": 134, "completion": "if txt:\n        if txt[-1].isalpha():\n            if txt.endswith(' '):\n                return False\n            else:\n                return True\n        else:\n            return False\n    else:\n        return False"}
{"idx": 135, "completion": "for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negative_integers = [x for x in lst if x < 0]\n    positive_integers = [x for x in lst if x > 0]\n    \n    a = max(negative_integers) if negative_integers else None\n    b = min(positive_integers) if positive_integers else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Normalize the input to handle different representations\n    def normalize(value):\n        if isinstance(value, str):\n            # Replace comma with dot for floating point numbers\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return value\n        return value\n\n    a_norm = normalize(a)\n    b_norm = normalize(b)\n\n    # Compare the normalized values\n    if a_norm > b_norm:\n        return a\n    elif b_norm > a_norm:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "# Check if n is less than 8, since the smallest sum of 4 positive even numbers is 8 (2+2+2+2)\n    if n < 8:\n        return False\n    # Check if n is even, since the sum of 4 even numbers is always even\n    if n % 2 != 0:\n        return False\n    # If n is divisible by 2 and greater than or equal to 8, it can be expressed as the sum of 4 even numbers\n    return True"}
{"idx": 139, "completion": "def factorial(x):\n        if x == 0 or x == 1:\n            return 1\n        else:\n            return x * factorial(x - 1)\n\n    result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(\" \", \"_\")\n    \n    # Find all sequences of more than 2 underscores\n    while \"___\" in text:\n        # Replace sequences of more than 2 underscores with a single hyphen\n        text = text.replace(\"___\", \"-\")\n    \n    return text"}
{"idx": 141, "completion": "# Split the file name into the name and extension\n    name, extension = file_name.split('.')\n    \n    # Check if there is exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Check if the name starts with a latin alphapet letter\n    if not name or not name[0].isalpha():\n        return 'No'\n    \n    # Check if there are not more than three digits in the name\n    if sum(c.isdigit() for c in name) > 3:\n        return 'No'\n    \n    # Check if the extension is one of the allowed ones\n    if extension not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "for i in range(len(lst)):\n        if i % 3 == 0:\n            lst[i] = lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            lst[i] = lst[i] ** 3\n    return sum(lst)"}
{"idx": 143, "completion": "def is_prime(n):\n        if n <= 1:\n            return False\n        if n <= 3:\n            return True\n        if n % 2 == 0 or n % 3 == 0:\n            return False\n        i = 5\n        while i * i <= n:\n            if n % i == 0 or n % (i + 2) == 0:\n                return False\n            i += 6\n        return True\n\n    words = sentence.split()\n    prime_words = [word for word in words if is_prime(len(word))]\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "# Split the input strings into numerator and denominator\n    x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    # Calculate the product of the numerators and denominators\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    # Check if the product is a whole number\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n\n    def digit_sum(num):\n        return sum(int(d) for d in str(abs(num)))\n\n    return sorted(nums, key=lambda x: (digit_sum(x), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if int(num_str[0]) % 2 != 0 and int(num_str[-1]) % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    start = planets.index(planet1)\n    end = planets.index(planet2)\n    if start > end:\n        start, end = end, start\n    return tuple(planets[start+1:end])"}
{"idx": 149, "completion": "# Delete strings with odd lengths\n    lst = [s for s in lst if len(s) % 2 == 0]\n    \n    # Sort the list first by length ascending, then alphabetically\n    lst.sort(key=lambda x: (len(x), x))\n    \n    return lst"}
{"idx": 150, "completion": "if is_prime(n):\n        return x\n    else:\n        return y"}
{"idx": 151, "completion": "sum_of_squares = 0\n    for number in lst:\n        if isinstance(number, int) and number > 0 and number % 2 != 0:\n            sum_of_squares += number ** 2\n    return sum_of_squares"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = None\n    strongest_extension = None\n    \n    for extension in extensions:\n        CAP = sum(1 for char in extension if char.isupper())\n        SM = sum(1 for char in extension if char.islower())\n        strength = CAP - SM\n        \n        if (max_strength is None) or (strength > max_strength):\n            max_strength = strength\n            strongest_extension = extension\n    \n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if len(b) > len(a):\n        return False\n    for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "even_count = 0\n    odd_count = 0\n    num = abs(num)\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n        num = num // 10\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "roman_numerals = {\n        1000: 'm',\n        900: 'cm',\n        500: 'd',\n        400: 'cd',\n        100: 'c',\n        90: 'xc',\n        50: 'l',\n        40: 'xl',\n        10: 'x',\n        9: 'ix',\n        5: 'v',\n        4: 'iv',\n        1: 'i'\n    }\n\n    roman_string = ''\n    for value, numeral in sorted(roman_numerals.items(), reverse=True):\n        while number >= value:\n            roman_string += numeral\n            number -= value\n    return roman_string"}
{"idx": 157, "completion": "# First, we need to check if the given sides can form a triangle.\n    # The sum of the lengths of any two sides must be greater than the length of the remaining side.\n    if a + b <= c or a + c <= b or b + c <= a:\n        return False\n    \n    # To determine if the triangle is a right-angled triangle, we can use the Pythagorean theorem.\n    # The theorem states that in a right-angled triangle, the square of the length of the hypotenuse\n    # (the longest side) is equal to the sum of squares of the other two sides.\n    # We will check all combinations:\n    if a**2 + b**2 == c**2:\n        return True\n    if a**2 + c**2 == b**2:\n        return True\n    if b**2 + c**2 == a**2:\n        return True\n    \n    # If none of the above conditions are met, the triangle is not a right-angled triangle.\n    return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = f\"{operand[0]}\"\n    for i in range(1, len(operand)):\n        expression += f\" {operator[i-1]} {operand[i]}\"\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join(c.swapcase() if c.isalpha() else c for c in s)"}
{"idx": 162, "completion": "if text == \"\":\n        return None\n    else:\n        import hashlib\n        return hashlib.md5(text.encode()).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    return [i for i in range(a, b+1) if all(int(c)%2 == 0 for c in str(i))]"}
