{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    current_group = []\n    for char in paren_string:\n        if char == '(':\n            current_group.append(char)\n        elif char == ')':\n            if current_group:\n                current_group.append(char)\n                result.append(''.join(current_group))\n                current_group = []\n        else:\n            pass\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n                else:\n                    # Handle invalid cases where there's an extra ')'\n                    pass\n        max_depths.append(max_depth)\n    return max_depths"}
{"idx": 7, "completion": "return [s for s in strings if substring in s]"}
{"idx": 8, "completion": "sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]  # should never be reached"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length.\")\n    \n    result = []\n    for bit_a, bit_b in zip(a, b):\n        if bit_a == '1' and bit_b == '1':\n            result.append('0')\n        elif bit_a == '1' or bit_b == '1':\n            result.append('1')\n        else:\n            result.append('0')\n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_len = -1\n    longest_str = None\n    for s in strings:\n        if len(s) > max_len:\n            max_len = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_dict = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note in note_dict:\n            beats.append(note_dict[note])\n        else:\n            raise ValueError(f\"Invalid note: {note}\")\n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list_sorted = sorted(numbers_list, key=lambda x: number_map[x])\n    return ' '.join(numbers_list_sorted)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / range_val for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "length = 0\n    for _ in string:\n        length += 1\n    return length"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    if n == 1:\n        return factors\n    # Start with the smallest prime number\n    divisor = 2\n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "seen = {}\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen[num] = 1\n            result.append(num)\n        else:\n            seen[num] += 1\n    return result"}
{"idx": 27, "completion": "new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    a, b = -1, 1\n    while poly(xs, a) * poly(xs, b) > 0:\n        a, b = a * 2, b * 2\n\n    while (b - a) > 1e-10:  # 1e-10 is epsilon error threshold\n        mid = (a + b) / 2\n        if poly(xs, a) * poly(xs, mid) > 0:\n            a = mid\n        else:\n            b = mid\n    return a"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = []\n    even_values = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            even_indicies.append(i)\n            even_values.append(l[i])\n    even_values = sorted(even_values)\n    for i in range(len(even_indicies)):\n        l[even_indicies[i]] = even_values[i]\n    return l"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int) -> bool:\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fibs = [1, 1]\n    primes = []\n    while len(primes) < n:\n        next_fib = fibs[-1] + fibs[-2]\n        fibs.append(next_fib)\n        if is_prime(next_fib):\n            primes.append(next_fib)\n    return primes[n-1]"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))"}
{"idx": 45, "completion": "return (a * h) / 2"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "text = text.lower()\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x * y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "increasing = True\n    decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            increasing = False\n        if l[i] < l[i + 1]:\n            decreasing = False\n    return increasing or decreasing"}
{"idx": 58, "completion": "common_elements = set(l1) & set(l2)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function is not working properly. The first doctest passes, but the second doesn't.\n    # The second doctest should return 2, but it returns 1. Fix the function so it works properly.\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "if not xs or len(xs) == 1:\n        return []\n    return [i * x for i, x in enumerate(xs[1:], 1)]"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n+1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i in range(len(s_lower)):\n        if s_lower[i] in vowels:\n            count += 1\n        elif i == len(s_lower) - 1 and s_lower[i] == 'y':\n            count += 1\n    return count"}
{"idx": 65, "completion": "s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[-shift:] + s[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "# Your code here\n    for i in range(len(lst)):\n        if lst.count(i) >= i:\n            return i\n    return -1"}
{"idx": 70, "completion": "sorted_list = []\n    while lst:\n        min_val = min(lst)\n        sorted_list.append(min_val)\n        lst.remove(min_val)\n        if lst:\n            max_val = max(lst)\n            sorted_list.append(max_val)\n            lst.remove(max_val)\n    return sorted_list"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    sum_elements = sum(q)\n    \n    # Determine if the object will fly based on the conditions\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    # Create a 2D array to store the minimum changes required for subarrays\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the table for subarrays of length 2\n    for i in range(n - 1):\n        if arr[i] != arr[i + 1]:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for subarrays of length > 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for num in range(2, a + 1):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        power *= n\n        if power == x:\n            return True\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    # Determine the absolute value to handle negative numbers\n    abs_a = abs(a)\n    # Iterate through possible cube roots\n    for i in range(0, abs_a + 1):\n        if i ** 3 == abs_a:\n            return True\n        if i ** 3 > abs_a:\n            return False\n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 1) + 10 ** (n - 1) - 9 ** (n - 1)"}
{"idx": 84, "completion": "# Sum the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the sum to binary and return as a string\n    return bin(digit_sum)[2:]"}
{"idx": 85, "completion": "sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum"}
{"idx": 86, "completion": "words = s.split(' ')\n    result = []\n    for word in words:\n        sorted_chars = sorted(word, key=lambda x: ord(x))\n        sorted_word = ''.join(sorted_chars)\n        result.append(sorted_word)\n    return ' '.join(result)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    first = array[0]\n    last = array[-1]\n    total = first + last\n    \n    if total % 2 == 1:\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted_char = chr(((ord(char) - ord('a') + 4) % 26) + ord('a'))\n            encrypted += shifted_char\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    sorted_lst = sorted(lst)\n    if sorted_lst[0] == sorted_lst[1]:\n        return None\n    return sorted_lst[1]"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    return sum(1 for sentence in sentences if sentence.strip().startswith('I'))"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = 'aeiouAEIOU'\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving 2 places ahead\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            encoded.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.islower():\n                encoded.append(char.upper())\n            else:\n                encoded.append(char.lower())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    if max_prime == -1:\n        return 0  # assuming there are no primes, though per problem statement there is at least one\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "return (a % 10) * (b % 10)"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Split the string into the integer and fractional parts\n    if '.' in value:\n        integer_part, fractional_part = value.split('.', 1)\n    else:\n        integer_part = value\n        fractional_part = '0'\n    \n    # Convert the integer part to an integer\n    integer_value = int(integer_part)\n    \n    # Check if there's a fractional part\n    if fractional_part != '0' and fractional_part:\n        # Determine if the fractional part is 0.5 or more\n        fractional_value = float('0.' + fractional_part)\n        if fractional_value >= 0.5:\n            if integer_value >= 0:\n                return integer_value + 1\n            else:\n                return integer_value - 1\n        elif fractional_value <= -0.5:\n            if integer_value >= 0:\n                return integer_value - 1\n            else:\n                return integer_value + 1\n        else:\n            return integer_value\n    else:\n        return integer_value"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if y - 1 >= x:\n        return y - 1\n    return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    count = 0\n    for num in range(n, m+1):\n        total += num\n        count += 1\n    average = total / count\n    rounded = round(average)\n    binary = bin(rounded)\n    return binary"}
{"idx": 104, "completion": "def has_even_digit(n):\n        for digit in str(n):\n            if int(digit) % 2 == 0:\n                return True\n        return False\n    \n    result = [num for num in x if not has_even_digit(num)]\n    result.sort()\n    return result"}
{"idx": 105, "completion": "# Your code here\n    if not arr:\n        return []\n    new_arr = []\n    for i in arr:\n        if i >= 1 and i <= 9:\n            new_arr.append(i)\n    new_arr.sort()\n    new_arr.reverse()\n    result = []\n    for i in new_arr:\n        if i == 1:\n            result.append(\"One\")\n        elif i == 2:\n            result.append(\"Two\")\n        elif i == 3:\n            result.append(\"Three\")\n        elif i == 4:\n            result.append(\"Four\")\n        elif i == 5:\n            result.append(\"Five\")\n        elif i == 6:\n            result.append(\"Six\")\n        elif i == 7:\n            result.append(\"Seven\")\n        elif i == 8:\n            result.append(\"Eight\")\n        elif i == 9:\n            result.append(\"Nine\")\n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Compute sum for odd i\n            sum_i = 0\n            for j in range(1, i + 1):\n                sum_i += j\n            result.append(sum_i)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n    \n    # If there are odd numbers in lst1 and even numbers in lst2, it's possible to exchange\n    return \"YES\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        count = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char not in vowels and char.isalpha():\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    if len(s1) == 0 or len(s2) == 0:\n        return 'Yes'\n    if s1[0] == ')' and s2[-1] == '(':\n        return 'No'\n    if s1[-1] == '(' and s2[0] == ')':\n        return 'No'\n    return 'Yes'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "if n == 1:\n        return [1]\n    collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [x for x in collatz_sequence if x % 2 != 0]\n    odd_numbers_sorted = sorted(odd_numbers)\n    return odd_numbers_sorted"}
{"idx": 124, "completion": "# Check if the date string is empty\n    if not date:\n        return False\n    \n    # Check the format of the date string\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    \n    month_str, day_str, year_str = parts\n    \n    # Check if month, day, and year are numeric\n    if not (month_str.isdigit() and day_str.isdigit() and year_str.isdigit()):\n        return False\n    \n    month = int(month_str)\n    day = int(day_str)\n    year = int(year_str)\n    \n    # Check if the month is valid (1-12)\n    if month < 1 or month > 12:\n        return False\n    \n    # Check if the day is valid based on the month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    elif month == 2:\n        # Check for leap year for February\n        if (year % 400 == 0) or (year % 100 != 0 and year % 4 == 0):\n            if day < 1 or day > 29:\n                return False\n        else:\n            if day < 1 or day > 28:\n                return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    # Check if the list is sorted in ascending order\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    start = max(start1, start2)\n    end = min(end1, end2)\n\n    # Check if the intervals overlap\n    if start > end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = end - start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    for num in arr:\n        if num < 0:\n            product *= -1\n        elif num == 0:\n            product *= 0\n        else:\n            product *= 1\n    return sum(abs(num) for num in arr) * product"}
{"idx": 129, "completion": "n = len(grid)\n    min_path = None\n\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            visited = set([(i, j)])\n            min_path = dfs(grid, i, j, k, path, visited, min_path)\n    \n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        res = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                res.append(1 + i // 2)\n            else:\n                res.append(res[i - 1] + res[i - 2] + res[i + 1])\n        return res"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        if int(d) % 2 != 0:\n            product *= int(d)\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack) == 0 and string.count('[') >= 2 and string.count(']') >= 2"}
{"idx": 133, "completion": "# Round each number in the list to the nearest integer (ceiling)\n    rounded = [math.ceil(num) for num in lst]\n    \n    # Square each number in the rounded list\n    squared = [num ** 2 for num in rounded]\n    \n    # Sum all the squared numbers\n    total = sum(squared)\n    \n    return total"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "largest_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            largest_index = i\n    return largest_index"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to a common type (float) for comparison\n    def parse_value(value):\n        if isinstance(value, (int, float)):\n            return float(value)\n        elif isinstance(value, str):\n            # Replace comma with dot for string representations\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        else:\n            return None\n    \n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n    \n    if a_parsed is None or b_parsed is None:\n        return None\n    \n    if a_parsed == b_parsed:\n        return None\n    elif a_parsed > b_parsed:\n        return a\n    else:\n        return b"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a hyphen\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Check the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    before_dot, after_dot = file_name.split('.', 1)\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            s = str(abs(num))\n            if int(s[0]) % 2 == 1 and int(s[-1]) % 2 == 1:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1+1:index2])\n    else:\n        return tuple(planets[index2+1:index1])"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x ** 2 for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "return [abs(score - guess) for score, guess in zip(game, guess)]"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n        elif strength == max_strength:\n            # In case of tie, choose the first one encountered\n            if extensions.index(extension) < extensions.index(strongest_extension):\n                strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the second word is a substring of the first word\n    if b in a:\n        return True\n    \n    # Generate all rotations of the second word and check if any is a substring of the first word\n    for i in range(1, len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    \n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even_count = 0\n    odd_count = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    result = []\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            result.append(roman_numerals[value])\n            number -= value\n    return ''.join(result).lower()"}
{"idx": 157, "completion": "# Sort the sides to identify the hypotenuse (the longest side)\n    sides = sorted([a, b, c])\n    # Check if the sum of the squares of the two shorter sides equals the square of the longest side\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique = len(set(word))\n        if unique > max_unique:\n            max_unique = unique\n            max_word = word\n        elif unique == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i+1])\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    else:\n        return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    stack = []\n    current_group = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            current_group.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                current_group.append(char)\n                if not stack:\n                    result.append(''.join(current_group))\n                    current_group = []\n        elif char != ' ':\n            current_group.append(char)\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(num - mean) for num in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i in range(len(numbers)):\n        if i != 0:\n            result.append(delimeter)\n        result.append(numbers[i])\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    max_levels = []\n    for group in groups:\n        max_level = 0\n        current_level = 0\n        for char in group:\n            if char == '(':\n                current_level += 1\n                if current_level > max_level:\n                    max_level = current_level\n            elif char == ')':\n                if current_level > 0:\n                    current_level -= 1\n                else:\n                    # Unbalanced parentheses, handle as needed\n                    pass\n        max_levels.append(max_level)\n    return max_levels"}
{"idx": 7, "completion": "filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings"}
{"idx": 8, "completion": "sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "max_so_far = -float('infinity')\n    result = []\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    max_len = 0\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            max_len = len(string) - i\n            break\n    return string + string[:max_len - 1][::-1]"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length.\")\n    \n    result = []\n    for bit_a, bit_b in zip(a, b):\n        if bit_a == '1' and bit_b == '1':\n            result.append('0')\n        elif bit_a == '1' or bit_b == '1':\n            result.append('1')\n        else:\n            result.append('0')\n    \n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_len = -1\n    longest_str = None\n    for s in strings:\n        if len(s) > max_len:\n            max_len = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    beats = [note_to_beats[note] for note in notes]\n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9,\n    }\n    numbers_list = numbers.split()\n    numbers_list_sorted = sorted(numbers_list, key=lambda x: number_map[x])\n    return ' '.join(numbers_list_sorted)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "return 0"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "# Use a dictionary to count the occurrences of each number\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    \n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    \n    return result"}
{"idx": 27, "completion": "new_string = []\n    for char in string:\n        if char.isupper():\n            new_string.append(char.lower())\n        else:\n            new_string.append(char.upper())\n    return ''.join(new_string)"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n\n    left = -1\n    right = 1\n    while poly(xs, left) * poly(xs, right) > 0:\n        left *= 2\n        right *= 2\n\n    while right - left > 1e-6:\n        mid = (left + right) / 2\n        if poly(xs, mid) * poly(xs, right) > 0:\n            right = mid\n        else:\n            left = mid\n\n    return left"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = l[::2]\n    even_indicies_sorted = sorted(even_indicies)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indicies_sorted[i//2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 1, 1\n    while count < n:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n    return a"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "s = set(l)\n    for x in l:\n        if -x in s and x != 0:\n            return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(digits[::-1])"}
{"idx": 45, "completion": "return 0.5 * a * h"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "text = text.lower()\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    without_vowels = \"\"\n    for char in text:\n        if char not in vowels:\n            without_vowels += char\n    return without_vowels"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x * y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) == 1:\n        return True\n    else:\n        if l[0] < l[1]:\n            for i in range(len(l)-1):\n                if l[i] > l[i+1]:\n                    return False\n            return True\n        elif l[0] > l[1]:\n            for i in range(len(l)-1):\n                if l[i] < l[i+1]:\n                    return False\n            return True\n        else:\n            for i in range(len(l)-1):\n                if l[i] != l[i+1]:\n                    return False\n            return True"}
{"idx": 58, "completion": "common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "i = 2\n    while i * i <= n:\n        while n % i == 0:\n            n = n // i\n        i = i + 1\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "return [x * i for i, x in enumerate(xs[1:], 1)]"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = ['a', 'e', 'i', 'o', 'u']\n    count = 0\n    s = s.lower()\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i] == 'y':\n            count += 1\n    return count"}
{"idx": 65, "completion": "s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[-shift:] + s[:-shift]"}
{"idx": 66, "completion": "sum = 0\n    for char in s:\n        if char.isupper():\n            sum += ord(char)\n    return sum"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    # Find the smallest even value and its indices\n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n            elif num == min_even and i < min_index:\n                min_index = i\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "# Your code here\n    max_num = max(lst)\n    for i in range(max_num, 0, -1):\n        if lst.count(i) >= i:\n            return i\n    return -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_sorted = sorted(lst)\n    left = 0\n    right = len(lst_sorted) - 1\n    while left <= right:\n        if left == right:\n            sorted_lst.append(lst_sorted[left])\n        else:\n            sorted_lst.append(lst_sorted[left])\n            sorted_lst.append(lst_sorted[right])\n        left += 1\n        right -= 1\n    return sorted_lst"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    if q != q[::-1]:\n        return False\n    \n    # Check if the sum of the elements is less than or equal to the maximum weight\n    if sum(q) > w:\n        return False\n    \n    return True"}
{"idx": 73, "completion": "n = len(arr)\n    if n == 0:\n        return 0\n    # Create a 2D array to store the minimum changes required\n    # dp[i][j] will represent the minimum changes needed for the subarray arr[i..j]\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table for subarrays of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a // i):\n                    if (a // i) % k == 0:\n                        break\n                else:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a special case\n    if a == 0:\n        return True\n    \n    # Calculate the absolute value of a to handle negative numbers\n    abs_a = abs(a)\n    \n    # Iterate through possible cube roots\n    for i in range(0, abs_a + 1):\n        cube = i ** 3\n        if cube == abs_a:\n            return True\n        if cube > abs_a:\n            break\n    \n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 1) + 9 * 10 ** (n - 2) - 9 * 10 ** (n - 2)"}
{"idx": 84, "completion": "total = sum(int(d) for d in str(N))\n    return bin(total)[2:]"}
{"idx": 85, "completion": "sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum"}
{"idx": 86, "completion": "words = s.split(' ')\n    result = []\n    for word in words:\n        if word:\n            sorted_word = ''.join(sorted(word, key=lambda x: ord(x)))\n            result.append(sorted_word)\n        else:\n            result.append('')\n    return ' '.join(result)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    first = array[0]\n    last = array[-1]\n    total = first + last\n    \n    if total % 2 == 1:\n        # Sort in ascending order\n        return sorted(array)\n    else:\n        # Sort in descending order\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = []\n    for char in s:\n        if char.isalpha():\n            shifted_char = chr(ord(char) + 4)\n            encrypted.append(shifted_char)\n        else:\n            encrypted.append(char)\n    return ''.join(encrypted)"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    unique_sorted = sorted(list(set(lst)))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]"}
{"idx": 91, "completion": "sentences = re.split(r'[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = 'aeiouAEIOU'\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving 2 places ahead\n            new_char = chr(ord(char) + 2)\n            # Handle wrap around for 'y' and 'z' or 'Y' and 'Z'\n            if (char.lower() == 'y' or char.lower() == 'z'):\n                new_char = chr(ord(char) - 24)  # 'a' or 'A' after 'y' or 'z'\n            # Ensure the case is preserved\n            if char.isupper():\n                new_char = new_char.upper()\n            else:\n                new_char = new_char.lower()\n            encoded.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.isupper():\n                encoded.append(char.lower())\n            else:\n                encoded.append(char.upper())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    if max_prime == -1:\n        return 0  # assuming no primes found, though problem examples suggest there's always one\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 2:\n        return []\n    primes = [2]\n    for i in range(3, n):\n        is_prime = True\n        for p in primes:\n            if i % p == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes"}
{"idx": 97, "completion": "return (abs(a) % 10) * (abs(b) % 10)"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Split the string into the integer and decimal parts\n    if '.' in value:\n        integer_part, decimal_part = value.split('.', 1)\n    else:\n        integer_part = value\n        decimal_part = '0'\n    \n    # Convert the integer part to an integer\n    int_num = int(integer_part)\n    \n    # Check if the decimal part is 0.5 or -0.5\n    if decimal_part == '5' or decimal_part == '-5':\n        # Round away from zero\n        if int_num >= 0:\n            return int_num + 1\n        else:\n            return int_num - 1\n    else:\n        # Round to the nearest integer\n        return round(float(value))"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    avg = round((n + m) / 2)\n    return bin(avg)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    return [digit_names[x-1] for x in filtered]"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            factorial = 1\n            for num in range(1, i + 1):\n                factorial *= num\n            result.append(factorial)\n        else:\n            # Compute sum for odd i\n            sum_num = 0\n            for num in range(1, i + 1):\n                sum_num += num\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)"}
{"idx": 108, "completion": "if not arr:\n        return 0\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    for i in range(n):\n        if arr == sorted_arr:\n            return True\n        arr = [arr[-1]] + arr[:-1]\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Count the number of odd numbers in lst1 and even numbers in lst2\n    odd_in_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If the number of odd numbers in lst1 is less than or equal to the number of even numbers in lst2, return \"YES\"\n    if odd_in_lst1 <= even_in_lst2:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        odd_digits = [d for d in s if int(d) % 2 != 0]\n        count = len(odd_digits)\n        phrase = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(phrase)\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the total number of operations to 0\n    total_operations = 0\n    \n    # Iterate over each well (each row in the grid)\n    for well in grid:\n        # Calculate the total water in the current well\n        water = sum(well)\n        # Calculate the number of operations needed for this well\n        # which is the ceiling of (water / capacity)\n        operations = math.ceil(water / capacity) if capacity != 0 else 0\n        # Add to the total operations\n        total_operations += operations\n    \n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char not in vowels and char.isalpha():\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word towards the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    if len(s1) == 0 or len(s2) == 0:\n        return 'Yes'\n    if s1[0] == ')' and s2[-1] == '(':\n        return 'No'\n    if s1[-1] == '(' and s2[0] == ')':\n        return 'No'\n    return 'Yes'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum_ = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum_ += arr[i]\n    return sum_"}
{"idx": 123, "completion": "if n == 1:\n        return [1]\n    collatz = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz.append(n)\n    odd_collatz = [x for x in collatz if x % 2 != 0]\n    odd_collatz.sort()\n    return odd_collatz"}
{"idx": 124, "completion": "# Check if the date string is empty\n    if not date:\n        return False\n    \n    # Check the format of the date string\n    if len(date) != 10 or date[2] != '-' or date[5] != '-':\n        return False\n    \n    # Split the date into month, day, and year\n    parts = date.split('-')\n    if len(parts) != 3:\n        return False\n    \n    # Check if month, day, and year are numeric\n    if not (parts[0].isdigit() and parts[1].isdigit() and parts[2].isdigit()):\n        return False\n    \n    month = int(parts[0])\n    day = int(parts[1])\n    year = int(parts[2])\n    \n    # Check if the month is valid\n    if month < 1 or month > 12:\n        return False\n    \n    # Check if the day is valid based on the month\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:  # February\n        # Check for leap year\n        if (year % 400 == 0) or (year % 100 != 0 and year % 4 == 0):\n            if day < 1 or day > 29:\n                return False\n        else:\n            if day < 1 or day > 28:\n                return False\n    \n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    # Check if the list is sorted in ascending order\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    overlap_start = max(start1, start2)\n    overlap_end = min(end1, end2)\n\n    # Check if there is an overlap\n    if overlap_start > overlap_end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = overlap_end - overlap_start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    \n    product = 1\n    magnitude_sum = 0\n    \n    for num in arr:\n        if num > 0:\n            product *= 1\n            magnitude_sum += num\n        elif num < 0:\n            product *= -1\n            magnitude_sum += -num  # magnitude is the absolute value\n        else:\n            product *= 0\n            # once a zero is encountered, the product will be zero\n            # but we still need to sum the magnitudes\n            magnitude_sum += 0\n    \n    return product * magnitude_sum"}
{"idx": 129, "completion": "n = len(grid)\n    min_path = None\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            if k > 1:\n                neighbors = get_neighbors(i, j, n)\n                min_neighbor = min(grid[x][y] for x, y in neighbors)\n                path.append(min_neighbor)\n                if k > 2:\n                    for _ in range(k - 2):\n                        neighbors = get_neighbors(i, j, n)\n                        min_neighbor = min(grid[x][y] for x, y in neighbors if (x, y) != (i, j))\n                        path.append(min_neighbor)\n            if min_path is None or path < min_path:\n                min_path = path\n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        sequence = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                next_term = 1 + i // 2\n            else:\n                next_term = sequence[i-1] + sequence[i-2] + (sequence[i+1] if i+1 < len(sequence) else 0)\n            sequence.append(next_term)\n        return sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        d = int(d)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "count = 0\n    for char in string:\n        if char == '[':\n            count += 1\n        else:\n            if count > 0:\n                count -= 1\n    return count > 0"}
{"idx": 133, "completion": "# Round each element in the list to the upper integer (ceiling)\n    rounded_lst = [math.ceil(x) for x in lst]\n    \n    # Square each element in the rounded list\n    squared_lst = [x ** 2 for x in rounded_lst]\n    \n    # Sum all the squared elements\n    total = sum(squared_lst)\n    \n    return total"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "largest_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            largest_index = i\n    return largest_index"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to the same type (float) for comparison\n    def parse_value(value):\n        if isinstance(value, (int, float)):\n            return float(value)\n        elif isinstance(value, str):\n            # Replace comma with dot for string representations\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        return None\n    \n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n    \n    if a_parsed is None or b_parsed is None:\n        return None\n    \n    if a_parsed > b_parsed:\n        return a\n    elif b_parsed > a_parsed:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Check the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    before_dot, after_dot = file_name.split('.', 1)\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    valid_extensions = ['txt', 'exe', 'dll']\n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1 + 1:index2])\n    else:\n        return tuple(planets[index2 + 1:index1])"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    filtered_list.sort(key=lambda x: (len(x), x))\n    \n    return filtered_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x ** 2 for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)"}
{"idx": 156, "completion": "# Create a dictionary to map integers to their corresponding Roman numerals\n    roman_numerals = {\n        1: 'i',\n        4: 'iv',\n        5: 'v',\n        9: 'ix',\n        10: 'x',\n        40: 'xl',\n        50: 'l',\n        90: 'xc',\n        100: 'c',\n        400: 'cd',\n        500: 'd',\n        900: 'cm',\n        1000: 'm'\n    }\n    \n    # Initialize an empty string to store the Roman numeral\n    roman_numeral = ''\n    \n    # Iterate through the dictionary in descending order of keys\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        # While the current value is less than or equal to the number\n        while number >= value:\n            # Subtract the value from the number and append the corresponding Roman numeral\n            roman_numeral += roman_numerals[value]\n            number -= value\n    \n    return roman_numeral"}
{"idx": 157, "completion": "# Check if the sides form a right-angled triangle\n    sides = [a, b, c]\n    sides.sort()  # Sort the sides to identify the hypotenuse (largest side)\n    if sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2:\n        return True\n    else:\n        return False"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for oprt, oprd in zip(operator, operand[1:]):\n        expression += oprt + str(oprd)\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join(c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s)"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for num in range(a, b + 1):\n        if all(digit % 2 == 0 for digit in map(int, str(num))):\n            result.append(num)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    current_group = []\n    for char in paren_string:\n        if char == '(':\n            current_group.append(char)\n        elif char == ')':\n            if current_group:\n                current_group.append(char)\n                result.append(''.join(current_group))\n                current_group = []\n        else:\n            continue\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i, num in enumerate(numbers):\n        if i != 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n                else:\n                    # Unbalanced parentheses, handle as needed\n                    pass\n        result.append(max_depth)\n    return result"}
{"idx": 7, "completion": "filtered_strings = []\n    for s in strings:\n        if substring in s:\n            filtered_strings.append(s)\n    return filtered_strings"}
{"idx": 8, "completion": "sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    max_len = 0\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            max_len = len(string) - i\n            break\n    return string + string[:max_len][::-1]"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length.\")\n    \n    result = []\n    for char_a, char_b in zip(a, b):\n        if char_a == '1' and char_b == '1':\n            result.append('0')\n        elif char_a == '0' and char_b == '0':\n            result.append('0')\n        else:\n            result.append('1')\n    \n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_length = 0\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)"}
{"idx": 17, "completion": "note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    return [note_to_beats[note] for note in music_string.split()]"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9,\n    }\n    numbers = numbers.split(' ')\n    numbers = [number_map[number] for number in numbers]\n    numbers = sorted(numbers)\n    numbers = [str(number) for number in numbers]\n    return ' '.join(numbers)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    result = (0.0, 0.0)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            result = (numbers[i], numbers[i+1])\n    return result"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / range_val for x in numbers]"}
{"idx": 22, "completion": "result = []\n    for value in values:\n        if isinstance(value, int) and not isinstance(value, bool):\n            result.append(value)\n    return result"}
{"idx": 23, "completion": "length = 0\n    for _ in string:\n        length += 1\n    return length"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "result = []\n    for num in numbers:\n        if num not in result:\n            result.append(num)\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "positive = []\n    for num in l:\n        if num > 0:\n            positive.append(num)\n    return positive"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    lo = -1\n    hi = 1\n    while poly(xs, lo) * poly(xs, hi) > 0:\n        lo *= 2\n        hi *= 2\n    while hi - lo > 1e-10:  # 1 \u00d7 10^\u22126 is common for floating points\n        mid = (lo + hi) / 2\n        if poly(xs, lo) * poly(xs, mid) <= 0:\n            hi = mid\n        else:\n            lo = mid\n    return lo"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indices = l[::2]\n    even_indices_sorted = sorted(even_indices)\n    l_prime = l.copy()\n    for i in range(len(even_indices_sorted)):\n        l_prime[2 * i] = even_indices_sorted[i]\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 1, 1\n    while count < n:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n    return a"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n ** 2"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i + 1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))"}
{"idx": 45, "completion": "return 0.5 * a * h"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    new_text = \"\"\n    for char in text:\n        if char not in vowels:\n            new_text += char\n    return new_text"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x - y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) == 1:\n        return True\n    if l[0] < l[1]:\n        for i in range(1, len(l)-1):\n            if l[i] > l[i+1]:\n                return False\n        return True\n    elif l[0] > l[1]:\n        for i in range(1, len(l)-1):\n            if l[i] < l[i+1]:\n                return False\n        return True\n    else:\n        for i in range(1, len(l)-1):\n            if l[i] != l[i+1]:\n                return False\n        return True"}
{"idx": 58, "completion": "common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function first checks if the number is even. If it is, it keeps dividing by 2 until it's no longer even, and sets the largest factor to 2.\n    # Then, it checks for odd factors starting from 3 up to the square root of the remaining number. For each factor found, it divides the number by that factor until it can't anymore, and updates the largest factor.\n    # If the remaining number is still greater than 2, it means that number itself is a prime and is the largest prime factor.\n    # This approach efficiently narrows down the factors by eliminating even numbers early and then checking potential odd divisors in a step-wise manner.\n\n    largest = 1\n    # Check for even factors first\n    if n % 2 == 0:\n        largest = 2\n        while n % 2 == 0:\n            n = n // 2\n    # Now check for odd factors up to sqrt(n)\n    i = 3\n    max_factor = int(n**0.5) + 1\n    while i <= max_factor:\n        if n % i == 0:\n            largest = i\n            while n % i == 0:\n                n = n // i\n            max_factor = int(n**0.5) + 1\n        i += 2\n    if n > 1:\n        largest = n\n    return largest"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * i)\n    return result"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = \"aeiouAEIOU\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' or s[i] == 'Y' and i == len(s)-1:\n            count += 1\n    return count"}
{"idx": 65, "completion": "x = str(x)\n    if shift > len(x):\n        return x[::-1]\n    else:\n        return x[-shift:] + x[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into parts\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[2])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n            elif num == min_even and i < min_index:\n                min_index = i\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "from collections import Counter\n    counts = Counter(lst)\n    candidates = [num for num in counts if counts[num] >= num]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_sorted = sorted(lst)\n    while len(lst_sorted) > 0:\n        if len(lst_sorted) == 1:\n            sorted_lst.append(lst_sorted[0])\n            break\n        min_val = lst_sorted[0]\n        max_val = lst_sorted[-1]\n        sorted_lst.append(min_val)\n        sorted_lst.append(max_val)\n        lst_sorted = lst_sorted[1:-1]\n    return sorted_lst"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is balanced (palindromic)\n    is_balanced = q == q[::-1]\n    \n    # Calculate the sum of the elements\n    sum_elements = sum(q)\n    \n    # Determine if the object will fly\n    return is_balanced and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    if n == 0:\n        return 0\n    # Create a 2D array to store the number of changes needed\n    # dp[i][j] represents the minimum changes needed for the subarray arr[i..j]\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table for all subarrays of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for num in range(2, a + 1):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    # Determine the absolute value to handle negative numbers\n    abs_a = abs(a)\n    # Iterate through possible cube roots\n    for i in range(0, abs_a + 1):\n        if i ** 3 == abs_a:\n            return True\n        if i ** 3 > abs_a:\n            return False\n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 10 ** (n - 1)"}
{"idx": 84, "completion": "# Sum the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_rep = bin(digit_sum)[2:]\n    \n    return binary_rep"}
{"idx": 85, "completion": "return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return array\n    \n    first = array[0]\n    last = array[-1]\n    sum_fl = first + last\n    \n    if sum_fl % 2 == 1:\n        # Sort in ascending order\n        return sorted(array)\n    else:\n        # Sort in descending order\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted_char = chr(ord(char) + 4)\n            if char.islower():\n                if shifted_char > 'z':\n                    shifted_char = chr(ord(shifted_char) - 26)\n            elif char.isupper():\n                if shifted_char > 'Z':\n                    shifted_char = chr(ord(shifted_char) - 26)\n            encrypted += shifted_char\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    unique_sorted = sorted(list(set(lst)))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = 'aeiouAEIOU'\n    encoded = []\n    for char in message:\n        if char in vowels:\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            encoded.append(new_char)\n        else:\n            encoded.append(char.swapcase())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "a = abs(a)\n    b = abs(b)\n    a = a % 10\n    b = b % 10\n    return a * b"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Split the string into the integer and decimal parts\n    if '.' in value:\n        integer_part, decimal_part = value.split('.')\n    else:\n        integer_part = value\n        decimal_part = '0'\n    \n    # Convert the integer part to an integer\n    integer_value = int(integer_part)\n    \n    # Convert the decimal part to a float\n    decimal_value = float('0.' + decimal_part)\n    \n    # Determine the closest integer\n    if decimal_value > 0.5:\n        closest = integer_value + 1\n    elif decimal_value < 0.5:\n        closest = integer_value\n    else:\n        # If exactly 0.5, round away from zero\n        if integer_value >= 0:\n            closest = integer_value + 1\n        else:\n            closest = integer_value - 1\n    \n    return closest"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    else:\n        for num in range(y, x-1, -1):\n            if num % 2 == 0:\n                return num\n        return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = total / (m - n + 1)\n    rounded = round(average)\n    return bin(rounded)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    \n    # Filter and sort the array\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    \n    # Map numbers to their corresponding names\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    result = [number_names[num] for num in filtered]\n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Calculate factorial for even i\n            factorial = 1\n            for num in range(1, i+1):\n                factorial *= num\n            result.append(factorial)\n        else:\n            # Calculate sum for odd i\n            sum_num = 0\n            for num in range(1, i+1):\n                sum_num += num\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -int(str(num)[0])\n            for digit in str(num)[1:]:\n                sum_digits += int(digit)\n        else:\n            sum_digits = 0\n            for digit in str(num):\n                sum_digits += int(digit)\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    for i in range(n):\n        if arr == sorted_arr:\n            return True\n        arr = [arr[-1]] + arr[:-1]\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Count the number of odd numbers in lst1 and even numbers in lst2\n    odd_in_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If there are enough even numbers in lst2 to replace the odd numbers in lst1, return \"YES\"\n    if even_in_lst2 >= odd_in_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    letters = test.split()\n    \n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        count = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "# Handle non-negative integers\n    non_neg = [x for x in arr if x >= 0]\n    non_neg_sorted = sorted(non_neg, key=lambda x: (bin(x).count('1'), x))\n    \n    # Handle negative integers\n    neg = [x for x in arr if x < 0]\n    neg_sorted = sorted(neg, key=lambda x: (bin(abs(x)).count('1'), -x), reverse=True)\n    \n    # Combine the results\n    return non_neg_sorted + neg_sorted"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word towards the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    # Check if either string is balanced\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    # Check if concatenation in any order is balanced\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers_sorted = sorted(odd_numbers)\n    return odd_numbers_sorted"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if day < 1 or day > 29:\n            return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n\n    # Check if the list is sorted in ascending order\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    overlap_start = max(start1, start2)\n    overlap_end = min(end1, end2)\n\n    if overlap_start > overlap_end:\n        return \"NO\"\n\n    length = overlap_end - overlap_start + 1\n\n    if length < 2:\n        return \"NO\"\n\n    # Check if the length is a prime number\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    for num in arr:\n        if num > 0:\n            product *= 1\n        elif num < 0:\n            product *= -1\n        else:\n            product *= 0\n    return sum(abs(num) for num in arr) * product"}
{"idx": 129, "completion": "n = len(grid)\n    min_path = None\n\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            visited = set([(i, j)])\n\n            for _ in range(k - 1):\n                min_val = float('inf')\n                next_pos = None\n\n                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                        if grid[ni][nj] < min_val:\n                            min_val = grid[ni][nj]\n                            next_pos = (ni, nj)\n\n                if next_pos is None:\n                    break\n\n                i, j = next_pos\n                path.append(min_val)\n                visited.add((i, j))\n\n            if len(path) == k and (min_path is None or path < min_path):\n                min_path = path\n\n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        sequence = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                next_term = 1 + i // 2\n            else:\n                next_term = sequence[i-1] + sequence[i-2] + (1 + (i + 1) // 2)\n            sequence.append(next_term)\n        return sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        d = int(d)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            if stack[-1] == '[':\n                stack.pop()\n                if stack and stack[-1] == '[':\n                    return True\n    return False"}
{"idx": 133, "completion": "total = 0\n    for num in lst:\n        rounded_num = math.ceil(num)\n        total += rounded_num ** 2\n    return total"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to strings for processing\n    a_str = str(a).replace(',', '.')\n    b_str = str(b).replace(',', '.')\n    \n    # Try to convert to float, if possible\n    try:\n        a_float = float(a_str)\n    except ValueError:\n        a_float = None\n    \n    try:\n        b_float = float(b_str)\n    except ValueError:\n        b_float = None\n    \n    # If both can be converted to float, compare numerically\n    if a_float is not None and b_float is not None:\n        if a_float > b_float:\n            return a\n        elif b_float > a_float:\n            return b\n        else:\n            return None\n    else:\n        # If at least one cannot be converted to float, compare as strings\n        if a_str > b_str:\n            return a\n        elif b_str > a_str:\n            return b\n        else:\n            return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    while '__' in text:\n        text = text.replace('__', '-')\n    \n    return text"}
{"idx": 141, "completion": "# Check the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    \n    before_dot, after_dot = parts\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    valid_extensions = ['txt', 'exe', 'dll']\n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1+1:index2])\n    else:\n        return tuple(planets[index2+1:index1])"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "sum_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            sum_squares += num ** 2\n    return sum_squares"}
{"idx": 152, "completion": "return [abs(score - guess) for score, guess in zip(game, guess)]"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the second word is a substring of the first word\n    if b in a:\n        return True\n    \n    # Generate all rotations of the second word\n    rotations = []\n    for i in range(1, len(b)):\n        rotation = b[i:] + b[:i]\n        rotations.append(rotation)\n    \n    # Check if any rotation of the second word is a substring of the first word\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)"}
{"idx": 156, "completion": "if not 1 <= number <= 1000:\n        raise ValueError(\"Number must be between 1 and 1000\")\n    \n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# Sort the sides to identify the hypotenuse (longest side)\n    sides = sorted([a, b, c])\n    # Check Pythagoras' theorem\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(remaining - need, 0)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for oprt, oprd in zip(operator, operand[1:]):\n        expression += oprt + str(oprd)\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    else:\n        return ''.join(c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s)"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                if not stack:\n                    result.append('()')\n            else:\n                return []\n        elif char != ' ':\n            return []\n    if stack:\n        return []\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n                else:\n                    # Handle invalid cases where closing parenthesis doesn't match any opening\n                    pass\n        result.append(max_depth)\n    return result"}
{"idx": 7, "completion": "return [s for s in strings if substring in s]"}
{"idx": 8, "completion": "sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    if is_palindrome(string):\n        return string\n    for i in range(1, len(string)+1):\n        if is_palindrome(string[-i:]):\n            return string + string[:-i][::-1]\n    return string  # unreachable"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length.\")\n    \n    result = []\n    for bit_a, bit_b in zip(a, b):\n        if bit_a == '1' and bit_b == '1':\n            result.append('0')\n        elif bit_a == '1' or bit_b == '1':\n            result.append('1')\n        else:\n            result.append('0')\n    \n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_length = 0\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "distinct_chars = set()\n    for char in string:\n        distinct_chars.add(char.lower())\n    return len(distinct_chars)"}
{"idx": 17, "completion": "note_dict = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    beats = [note_dict[note] for note in notes]\n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9,\n    }\n    numbers_list = numbers.split()\n    numbers_list.sort(key=lambda x: number_map[x])\n    return ' '.join(numbers_list)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    closest_pair = (numbers[0], numbers[1])\n    min_diff = abs(numbers[1] - numbers[0])\n\n    for i in range(1, len(numbers) - 1):\n        diff = abs(numbers[i + 1] - numbers[i])\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / range_val for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "length = 0\n    for _ in string:\n        length += 1\n    return length"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "# Create a dictionary to keep track of the count of each number\n    count_dict = {}\n    # Iterate through the list to populate the dictionary\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    # Create a new list with numbers that have a count of 1, in the original order\n    result = [num for num in numbers if count_dict[num] == 1]\n    return result"}
{"idx": 27, "completion": "new_string = []\n    for char in string:\n        if char.isupper():\n            new_string.append(char.lower())\n        else:\n            new_string.append(char.upper())\n    return ''.join(new_string)"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "positive = []\n    for num in l:\n        if num > 0:\n            positive.append(num)\n    return positive"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "if len(xs) % 2 != 0 or len(xs) == 0 or xs[-1] == 0:\n        return None\n\n    left = -1\n    right = 1\n    while poly(xs, left) * poly(xs, right) > 0:\n        left *= 2\n        right *= 2\n\n    while right - left > 1e-6:  # 10^(-6) is a good enough precision\n        mid = (left + right) / 2\n        if poly(xs, mid) * poly(xs, right) > 0:\n            right = mid\n        else:\n            left = mid\n\n    return left"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = []\n    even_values = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            even_indicies.append(i)\n            even_values.append(l[i])\n    even_values = sorted(even_values)\n    for i in range(len(even_indicies)):\n        l[even_indicies[i]] = even_values[i]\n    return l"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fib_prev, fib_curr = 1, 1\n    count = 0\n    while True:\n        fib_prev, fib_curr = fib_curr, fib_prev + fib_curr\n        if is_prime(fib_curr):\n            count += 1\n            if count == n:\n                return fib_curr"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(digits[::-1])"}
{"idx": 45, "completion": "return (a * h) / 2"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l_sorted = sorted(l)\n    if len(l_sorted) % 2 == 1:\n        return l_sorted[len(l_sorted) // 2]\n    else:\n        return (l_sorted[len(l_sorted) // 2 - 1] + l_sorted[len(l_sorted) // 2]) / 2"}
{"idx": 48, "completion": "text = text.lower()\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x * y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) == 1:\n        return True\n    if l[0] < l[1]:\n        for i in range(1, len(l) - 1):\n            if l[i] > l[i + 1]:\n                return False\n    elif l[0] > l[1]:\n        for i in range(1, len(l) - 1):\n            if l[i] < l[i + 1]:\n                return False\n    else:\n        for i in range(1, len(l) - 1):\n            if l[i] != l[i + 1]:\n                return False\n    return True"}
{"idx": 58, "completion": "common_elements = set(l1) & set(l2)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "i = 2\n    while i * i <= n:\n        while n % i == 0:\n            n = n // i\n        i = i + 1\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "return [x * i for i, x in enumerate(xs[1:], 1)]"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = \"aeiouAEIOU\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i].lower() == 'y':\n            count += 1\n    return count"}
{"idx": 65, "completion": "s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[-shift:] + s[:-shift]"}
{"idx": 66, "completion": "sum_ = 0\n    for char in s:\n        if char.isupper():\n            sum_ += ord(char)\n    return sum_"}
{"idx": 67, "completion": "# Split the string into parts\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[2])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n    \n    return [min_even, min_index] if min_even is not None else []"}
{"idx": 69, "completion": "# Your code here\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    max_num = -1\n    for num in freq:\n        if num <= freq[num] and num > max_num:\n            max_num = num\n    return max_num"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_copy = lst.copy()\n    while lst_copy:\n        min_val = min(lst_copy)\n        sorted_lst.append(min_val)\n        lst_copy.remove(min_val)\n        if lst_copy:\n            max_val = max(lst_copy)\n            sorted_lst.append(max_val)\n            lst_copy.remove(max_val)\n    return sorted_lst"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    sum_elements = sum(q)\n    \n    # Determine if the object will fly\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    if n == 0:\n        return 0\n    # Create a 2D array to store the minimum changes needed\n    # dp[i][j] will represent the minimum changes needed for the subarray arr[i..j]\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table for subarrays of length 2\n    for i in range(n - 1):\n        if arr[i] != arr[i + 1]:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for subarrays of length > 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a // i):\n                    if (a // i) % k == 0:\n                        break\n                else:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    \n    # Calculate the absolute value of a to handle negative numbers\n    abs_a = abs(a)\n    \n    # Iterate through possible cube roots\n    for i in range(0, abs_a + 1):\n        # Calculate the cube of the current integer\n        cube = i ** 3\n        \n        # If the cube matches the absolute value of a, return True\n        if cube == abs_a:\n            return True\n        \n        # If the cube exceeds the absolute value of a, break the loop\n        if cube > abs_a:\n            break\n    \n    # If no cube root is found, return False\n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 9 * 10 ** (n - 2) - 9 * 9 * 10 ** (n - 3)"}
{"idx": 84, "completion": "# Sum the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_rep = bin(digit_sum)[2:]\n    \n    return binary_rep"}
{"idx": 85, "completion": "return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return array\n    \n    first = array[0]\n    last = array[-1]\n    total = first + last\n    \n    if total % 2 == 1:\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n            encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    lst = sorted(lst)\n    if lst[0] == lst[1]:\n        return None\n    return lst[1]"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving two places ahead\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            result.append(new_char)\n        else:\n            # Swap the case of the character\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n    return ''.join(result)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    if max_prime == -1:\n        return 0  # or handle as per requirements, though problem says there is a prime\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 2:\n        return []\n    primes = [2]\n    for num in range(3, n):\n        is_prime = True\n        for p in primes:\n            if num % p == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "return (a % 10) * (b % 10)"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Convert the string to a float\n    num = float(value)\n    \n    # Get the floor and ceiling values\n    floor_val = int(num // 1)\n    ceil_val = int((num // 1) + 1) if num > 0 else int((num // 1) - 1)\n    \n    # Calculate the distances\n    dist_floor = abs(num - floor_val)\n    dist_ceil = abs(num - ceil_val)\n    \n    # Determine the closest integer\n    if dist_floor < dist_ceil:\n        return floor_val\n    elif dist_ceil < dist_floor:\n        return ceil_val\n    else:\n        # If equidistant, round away from zero\n        return ceil_val if num > 0 else floor_val"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if \",\" in s:\n        return s.replace(\",\", \" \").split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    else:\n        for num in range(y, x-1, -1):\n            if num % 2 == 0:\n                return num\n        return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = round(total / (m - n + 1))\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even = True\n                break\n        if not has_even:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    result = [digit_names[x-1] for x in filtered]\n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            fact = 1\n            for j in range(1, i + 1):\n                fact *= j\n            result.append(fact)\n        else:\n            # Compute sum for odd i\n            sum_num = 0\n            for j in range(1, i + 1):\n                sum_num += j\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    n = len(arr)\n    min_index = arr.index(min(arr))\n    if min_index == 0:\n        return arr == sorted(arr)\n    rotated = arr[min_index:] + arr[:min_index]\n    return rotated == sorted(arr)"}
{"idx": 110, "completion": "# Count the number of odd numbers in lst1\n    odd_in_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    \n    # Count the number of even numbers in lst2\n    even_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If the number of odd numbers in lst1 is less than or equal to the number of even numbers in lst2, return \"YES\"\n    if odd_in_lst1 <= even_in_lst2:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    letters = test.split()\n    \n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        odd_digits = [d for d in s if int(d) % 2 != 0]\n        count = len(odd_digits)\n        replaced = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(replaced)\n    return result"}
{"idx": 114, "completion": "min_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"idx": 115, "completion": "# The problem requires us to calculate the minimum number of times we need to lower the buckets\n    # to empty all the wells. Each bucket can carry up to 'capacity' units of water per trip.\n    # The approach is to sum the total number of 1s (units of water) in each well, then determine\n    # how many full-capacity trips are needed for each well, and sum these across all wells.\n\n    total_operations = 0\n    for well in grid:\n        # Count the number of 1s in the current well (units of water to remove)\n        water_units = sum(well)\n        if water_units == 0:\n            continue  # no need to lower the bucket for this well\n        # Calculate the number of times the bucket needs to be lowered for this well\n        operations = math.ceil(water_units / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    # Check if either string is balanced\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    # Check if concatenation in any order is balanced\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [x for x in collatz_sequence if x % 2 != 0]\n    odd_numbers_sorted = sorted(odd_numbers)\n    return odd_numbers_sorted"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if day < 1 or day > 29:\n            return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n\n    # Check if the list is sorted in ascending order\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    start = max(start1, start2)\n    end = min(end1, end2)\n\n    # Check if there is an overlap\n    if start > end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = end - start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    for num in arr:\n        if num > 0:\n            product *= 1\n        elif num < 0:\n            product *= -1\n        else:\n            product *= 0\n    return sum(abs(num) for num in arr) * product"}
{"idx": 129, "completion": "n = len(grid)\n    min_path = None\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            if k > 1:\n                neighbors = get_neighbors(i, j, n)\n                min_neighbor = min(grid[x][y] for x, y in neighbors)\n                path.append(min_neighbor)\n                if k > 2:\n                    for _ in range(k - 2):\n                        neighbors = get_neighbors(i, j, n)\n                        min_neighbor = min(grid[x][y] for x, y in neighbors)\n                        path.append(min_neighbor)\n            if min_path is None or path < min_path:\n                min_path = path\n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        res = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                res.append(1 + i // 2)\n            else:\n                res.append(res[i - 1] + res[i - 2] + res[i + 1])\n        return res"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        d = int(d)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    if not has_odd:\n        return 0\n    return product"}
{"idx": 132, "completion": "# Check if the string is empty or has only one pair of brackets\n    if len(string) < 4:\n        return False\n    \n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    \n    # After processing all characters, the stack should be empty for a valid nested structure\n    return len(stack) == 0 and string.count('[') >= 2 and string.count(']') >= 2"}
{"idx": 133, "completion": "rounded_lst = [math.ceil(num) for num in lst]\n    squared_lst = [num ** 2 for num in rounded_lst]\n    return sum(squared_lst)"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "def parse_value(value):\n        if isinstance(value, str):\n            # Replace comma with dot for parsing\n            value = value.replace(',', '.')\n            # Check if the string can be parsed as an integer or float\n            if '.' in value:\n                return float(value)\n            else:\n                return int(value)\n        return value\n\n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n\n    if a_parsed == b_parsed:\n        return None\n\n    if a_parsed > b_parsed:\n        return a\n    else:\n        return b"}
{"idx": 138, "completion": "if n % 2 != 0:\n        return False\n    if n < 8:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Count the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    \n    # Check if there are more than three digits\n    if digit_count > 3:\n        return 'No'\n    \n    # Check if there's exactly one dot\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    before_dot, after_dot = file_name.split('.')\n    \n    # Check if the part before the dot is not empty and starts with a letter\n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check if the part after the dot is one of the allowed extensions\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # If all checks passed, return 'Yes'\n    return 'Yes'"}
{"idx": 142, "completion": "sum = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            sum += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            sum += lst[i] ** 3\n        else:\n            sum += lst[i]\n    return sum"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    numerator = x_num * n_num\n    denominator = x_den * n_den\n    \n    if denominator == 0:\n        return False\n    \n    return numerator % denominator == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1+1:index2])\n    else:\n        return tuple(planets[index2+1:index1])"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if not b:\n        return True  # empty string is always a substring\n    \n    len_b = len(b)\n    doubled_b = b + b  # This helps in checking all possible rotations\n    \n    for i in range(len_b):\n        rotated = doubled_b[i:i+len_b]\n        if rotated in a:\n            return True\n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n        num = num // 10\n    return (even, odd)"}
{"idx": 156, "completion": "# Create a dictionary to map numbers to their corresponding Roman numerals\n    roman_numerals = {\n        1: 'i',\n        4: 'iv',\n        5: 'v',\n        9: 'ix',\n        10: 'x',\n        40: 'xl',\n        50: 'l',\n        90: 'xc',\n        100: 'c',\n        400: 'cd',\n        500: 'd',\n        900: 'cm',\n        1000: 'm'\n    }\n    \n    # Initialize an empty string to store the Roman numeral\n    roman_numeral = ''\n    \n    # Iterate through the dictionary in descending order of keys\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        # While the number is greater than or equal to the current value\n        while number >= value:\n            # Subtract the value from the number and append the corresponding Roman numeral\n            roman_numeral += roman_numerals[value]\n            number -= value\n    \n    return roman_numeral"}
{"idx": 157, "completion": "# Sort the sides to identify the hypotenuse (the longest side)\n    sides = sorted([a, b, c])\n    # Check if the sum of the squares of the two shorter sides equals the square of the longest side\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    remaining_after = max(remaining - need, 0)\n    return [total_eaten, remaining_after]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for oprt, oprd in zip(operator, operand[1:]):\n        expression += oprt + str(oprd)\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    else:\n        return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for num in range(a, b + 1):\n        if all(int(digit) % 2 == 0 for digit in str(num)):\n            result.append(num)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    stack = []\n    current_group = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            current_group.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                current_group.append(char)\n                if not stack:\n                    result.append(''.join(current_group))\n                    current_group = []\n        elif char != ' ':\n            if stack:\n                current_group.append(char)\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i, num in enumerate(numbers):\n        if i != 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n                else:\n                    # Unbalanced parentheses, handle as needed\n                    pass\n        max_depths.append(max_depth)\n    return max_depths"}
{"idx": 7, "completion": "filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    if is_palindrome(string):\n        return string\n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # Append the reverse of the prefix before the palindromic suffix\n            return string + string[:i][::-1]\n    return string  # Should never reach here for non-empty strings"}
{"idx": 11, "completion": "return ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_length = -1\n    result = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            result = s\n    return result"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "beat_mapping = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note in beat_mapping:\n            beats.append(beat_mapping[note])\n        else:\n            raise ValueError(f\"Invalid note: {note}\")\n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list_sorted = sorted(numbers_list, key=lambda x: number_map[x])\n    return ' '.join(numbers_list_sorted)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = None\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / range_val for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "pass"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "# Use a dictionary to count occurrences\n    count = {}\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    # Filter out numbers that occur more than once\n    result = [num for num in numbers if count[num] == 1]\n    return result"}
{"idx": 27, "completion": "return string.swapcase()"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n\n    left = -1\n    right = 1\n    while poly(xs, left) * poly(xs, right) > 0:\n        left *= 2.0\n        right *= 2.0\n\n    while left + 1e-10 < right:\n        mid = (left + right) / 2\n        if poly(xs, mid) * poly(xs, right) > 0:\n            right = mid\n        else:\n            left = mid\n\n    return left"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = []\n    even_values = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            even_indicies.append(i)\n            even_values.append(l[i])\n    even_values = sorted(even_values)\n    l_prime = []\n    for i in range(len(l)):\n        if i in even_indicies:\n            l_prime.append(even_values[even_indicies.index(i)])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 1, 1\n    while count < n:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n    return a"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n ** 2"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))"}
{"idx": 45, "completion": "return (a * h) / 2"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "if len(text) == 0:\n        return True\n    if text[0] != text[-1]:\n        return False\n    return is_palindrome(text[1:-1])"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = []\n    for char in text:\n        if char not in vowels:\n            result.append(char)\n    return ''.join(result)"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x - y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b\n\n    return 0"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) == 1:\n        return True\n    if l[0] < l[1]:\n        for i in range(1, len(l) - 1):\n            if l[i] > l[i + 1]:\n                return False\n    elif l[0] > l[1]:\n        for i in range(1, len(l) - 1):\n            if l[i] < l[i + 1]:\n                return False\n    else:\n        for i in range(1, len(l) - 1):\n            if l[i] != l[i + 1]:\n                return False\n    return True"}
{"idx": 58, "completion": "common_elements = list(set(l1) & set(l2))\n    common_elements.sort()\n    return common_elements"}
{"idx": 59, "completion": "# The function starts by initializing i to 2, which is the smallest prime number.\n    i = 2\n    # The while loop continues as long as i squared is less than or equal to n. This is because a larger factor of the number n would be a multiple of a smaller factor that has already been checked.\n    while i * i <= n:\n        # Inside the loop, the function checks if i is a factor of n by checking if n is divisible by i (n % i == 0).\n        if n % i == 0:\n            # If i is a factor of n, the function divides n by i (n = n // i) to reduce the problem to finding the largest prime factor of the smaller number.\n            n = n // i\n        else:\n            # If i is not a factor of n, the function increments i by 1 to check the next integer.\n            i += 1\n    # Once the loop ends, the function returns the remaining value of n, which is the largest prime factor.\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * i)\n    return result"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n+1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i in range(len(s_lower)):\n        if s_lower[i] in vowels:\n            count += 1\n        if i == len(s_lower) - 1 and s_lower[i] == 'y':\n            count += 1\n    return count"}
{"idx": 65, "completion": "digits = str(x)\n    if shift > len(digits):\n        return digits[::-1]\n    else:\n        return digits[-shift:] + digits[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n            elif num == min_even and i < min_index:\n                min_index = i\n    \n    return [min_even, min_index] if min_even is not None else []"}
{"idx": 69, "completion": "from collections import Counter\n    counts = Counter(lst)\n    candidates = [num for num, cnt in counts.items() if num <= cnt]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    lst_sorted = []\n    lst_copy = lst.copy()\n    while lst_copy:\n        min_val = min(lst_copy)\n        lst_sorted.append(min_val)\n        lst_copy.remove(min_val)\n        if lst_copy:\n            max_val = max(lst_copy)\n            lst_sorted.append(max_val)\n            lst_copy.remove(max_val)\n    return lst_sorted"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        # Heron's formula\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    sum_elements = sum(q)\n    \n    # Return True if the list is a palindrome and the sum is less than or equal to the maximum weight, False otherwise\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a // i):\n                    if (a // i) % k == 0:\n                        break\n                else:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the absolute value of 'a' has an integer cube root\n    # A number 'a' is a cube if there exists an integer 'b' such that b^3 = a\n    # For negative numbers, the cube root is also negative, so we take the absolute value first\n    a_abs = abs(a)\n    # Find the cube root of the absolute value of 'a' and round it to the nearest integer\n    b = round(a_abs ** (1/3))\n    # Check if the cube of the rounded value equals the absolute value of 'a'\n    # Also, handle the case when 'a' is zero\n    return b ** 3 == a_abs or a == 0"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 10 ** (n - 1) - 9 * 10 ** (n - 2)"}
{"idx": 84, "completion": "# Sum the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_representation = bin(digit_sum)[2:]\n    \n    return binary_representation"}
{"idx": 85, "completion": "return sum([num for i, num in enumerate(lst) if i % 2 != 0 and num % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    first = array[0]\n    last = array[-1]\n    sum_fl = first + last\n    \n    if sum_fl % 2 == 1:  # Odd sum, sort in ascending order\n        return sorted(array)\n    else:  # Even sum, sort in descending order\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted_char = chr(ord(char) + 4)\n            if char.islower():\n                if shifted_char > 'z':\n                    shifted_char = chr(ord(shifted_char) - 26)\n            elif char.isupper():\n                if shifted_char > 'Z':\n                    shifted_char = chr(ord(shifted_char) - 26)\n            encrypted += shifted_char\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    sorted_lst = sorted(lst)\n    if sorted_lst[0] == sorted_lst[1]:\n        return None\n    return sorted_lst[1]"}
{"idx": 91, "completion": "sentences = re.split(r'[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if words and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = \"aeiouAEIOU\"\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving 2 places ahead\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            encoded.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.islower():\n                encoded.append(char.upper())\n            else:\n                encoded.append(char.lower())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    if max_prime == -1:\n        return 0  # assuming there are no primes, though problem says \"largest prime\"\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digit of each number\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_a * unit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Split the string into integer and fractional parts\n    if '.' in value:\n        integer_part, fractional_part = value.split('.')\n    else:\n        integer_part = value\n        fractional_part = '0'\n    \n    # Convert the integer part to an integer\n    integer_value = int(integer_part)\n    \n    # If there's no fractional part, return the integer as is\n    if fractional_part == '0':\n        return integer_value\n    \n    # Convert the fractional part to a float\n    fractional_value = float('0.' + fractional_part)\n    \n    # Determine the closest integer\n    if fractional_value > 0.5:\n        return integer_value + 1\n    elif fractional_value < 0.5:\n        return integer_value\n    else:\n        # If exactly 0.5, round away from zero\n        if integer_value >= 0:\n            return integer_value + 1\n        else:\n            return integer_value - 1"}
{"idx": 100, "completion": "levels = []\n    current = n\n    for _ in range(n):\n        levels.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return levels"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = round(total / (m - n + 1))\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even = True\n                break\n        if not has_even:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    # Filter and sort the array\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    # Map numbers to their corresponding names\n    number_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    result = [number_names[x-1] for x in filtered]\n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            factorial = 1\n            for num in range(1, i+1):\n                factorial *= num\n            result.append(factorial)\n        else:\n            # Compute sum for odd i\n            sum_i = 0\n            for num in range(1, i+1):\n                sum_i += num\n            result.append(sum_i)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if is_palindrome(num):\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -int(str(num)[0])\n            for digit in str(num)[1:]:\n                sum_digits += int(digit)\n        else:\n            sum_digits = 0\n            for digit in str(num):\n                sum_digits += int(digit)\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    for i in range(n):\n        if arr == sorted_arr:\n            return True\n        arr = [arr[-1]] + arr[:-1]\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n    \n    # If there are odd numbers in lst1 and even numbers in lst2, it's possible to exchange\n    return \"YES\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        count = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1') if x >= 0 else bin(-x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    # Check if either string is balanced\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    # Check if concatenating in any order can be balanced\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers_sorted = sorted(odd_numbers)\n    return odd_numbers_sorted"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if day < 1 or day > 29:\n            return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    # Check if sorted\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    overlap_start = max(start1, start2)\n    overlap_end = min(end1, end2)\n\n    # Check if there is an overlap\n    if overlap_start > overlap_end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = overlap_end - overlap_start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    \n    product = 1\n    sum_magnitudes = 0\n    \n    for num in arr:\n        if num > 0:\n            product *= 1\n            sum_magnitudes += num\n        elif num < 0:\n            product *= -1\n            sum_magnitudes += -num\n        else:\n            product *= 0\n            sum_magnitudes += 0\n    \n    return product * sum_magnitudes"}
{"idx": 129, "completion": "n = len(grid)\n    min_val = float('inf')\n    min_path = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_path = [grid[i][j]]\n    \n    if k == 1:\n        return min_path\n    \n    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = set()\n    queue = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == min_val:\n                queue.append((i, j, [grid[i][j]]))\n                visited.add((i, j))\n    \n    while queue:\n        i, j, path = queue.pop(0)\n        if len(path) == k:\n            return path\n        for di, dj in neighbors:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                visited.add((ni, nj))\n                new_path = path + [grid[ni][nj]]\n                queue.append((ni, nj, new_path))\n    \n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        res = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                res.append(1 + i // 2)\n            else:\n                res.append(res[i - 1] + res[i - 2] + res[i + 1])\n        return res"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        d = int(d)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            if stack[-1] == '[':\n                stack.pop()\n            else:\n                stack.append(char)\n        else:\n            stack.append(char)\n    return len(stack) == 0 and string.count('[') >= 2 and string.count(']') >= 2"}
{"idx": 133, "completion": "return sum([math.ceil(x)**2 for x in lst])"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "def parse_value(value):\n        if isinstance(value, str):\n            # Replace comma with dot for parsing\n            value = value.replace(',', '.')\n            # Check if it's a float or int\n            if '.' in value:\n                return float(value)\n            else:\n                return int(value)\n        else:\n            return value\n\n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n\n    if a_parsed == b_parsed:\n        return None\n    elif a_parsed > b_parsed:\n        return a\n    else:\n        return b"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Count the number of digits in the file name\n    num_digits = sum(c.isdigit() for c in file_name)\n    if num_digits > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    before_dot, after_dot = file_name.split('.', 1)\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    valid_extensions = ['txt', 'exe', 'dll']\n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "sum = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            sum += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            sum += lst[i] ** 3\n        else:\n            sum += lst[i]\n    return sum"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        length = len(word)\n        if is_prime(length):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1+1:index2])\n    else:\n        return tuple(planets[index2+1:index1])"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    filtered_list.sort(key=lambda x: (len(x), x))\n    \n    return filtered_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x * x for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "return [abs(score - guess) for score, guess in zip(game, guess)]"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "if not a or not b:\n        return False\n    \n    doubled_a = a + a\n    return b in doubled_a"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)"}
{"idx": 156, "completion": "roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    result = []\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            result.append(roman_numerals[value])\n            number -= value\n    return ''.join(result).lower()"}
{"idx": 157, "completion": "# Sort the sides in ascending order to identify the hypotenuse\n    sides = sorted([a, b, c])\n    # Check if the sum of the squares of the two smaller sides equals the square of the largest side\n    return sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    remaining_after = max(remaining - need, 0)\n    return [total_eaten, remaining_after]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for oprt, oprd in zip(operator, operand[1:]):\n        expression += oprt + str(oprd)\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    current_group = []\n    open_parens = 0\n\n    for char in paren_string:\n        if char == '(':\n            open_parens += 1\n            current_group.append(char)\n        elif char == ')':\n            if open_parens > 0:\n                open_parens -= 1\n                current_group.append(char)\n                if open_parens == 0:\n                    result.append(''.join(current_group))\n                    current_group = []\n        # Ignore spaces\n\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i, num in enumerate(numbers):\n        if i > 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    max_levels = []\n    for group in groups:\n        max_level = 0\n        current_level = 0\n        for char in group:\n            if char == '(':\n                current_level += 1\n                if current_level > max_level:\n                    max_level = current_level\n            elif char == ')':\n                if current_level > 0:\n                    current_level -= 1\n                else:\n                    # Invalid case, more closing than opening, but per problem statement, assume valid\n                    pass\n        max_levels.append(max_level)\n    return max_levels"}
{"idx": 7, "completion": "return [s for s in strings if substring in s]"}
{"idx": 8, "completion": "sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]   # should never be reached"}
{"idx": 11, "completion": "return ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(a, b))"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_length = 0\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    return [note_to_beats[note] for note in music_string.split()]"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list_sorted = sorted(numbers_list, key=lambda x: number_map[x])\n    return ' '.join(numbers_list_sorted)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    closest_pair = None\n    min_diff = float('inf')\n\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n\n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / range_val for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "count = 0\n    for _ in string:\n        count += 1\n    return count"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors"}
{"idx": 26, "completion": "# Create a dictionary to keep track of the count of each number\n    count = {}\n    # Iterate through the list and count each number\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    # Create a new list with only the numbers that have a count of 1\n    result = [num for num in numbers if count[num] == 1]\n    return result"}
{"idx": 27, "completion": "new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n\n    left = -1\n    right = 1\n    while poly(xs, left) * poly(xs, right) > 0:\n        left *= 2.0\n        right *= 2.0\n\n    while left <= right:\n        mid = (left + right) / 2.0\n        val = poly(xs, mid)\n        if val * poly(xs, right) > 0:\n            right = mid\n        else:\n            left = mid\n        if abs(val) < 1e-6:\n            return mid\n    return 0.0"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = l[::2]\n    even_indicies_sorted = sorted(even_indicies)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indicies_sorted[i//2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fibs = [0, 1]\n    primes = []\n    while len(primes) < n:\n        next_fib = fibs[-1] + fibs[-2]\n        fibs.append(next_fib)\n        if is_prime(next_fib):\n            primes.append(next_fib)\n    return primes[n-1]"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n ** 2"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))"}
{"idx": 45, "completion": "return 0.5 * a * h"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            e = a + b + c + d\n            a, b, c, d = b, c, d, e\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "text = text.lower()\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x * y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(n - 1):\n            a, b = b, a + b\n        return b"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "if len(l) < 2:\n        return True\n    if l[0] < l[1]:\n        for i in range(1, len(l) - 1):\n            if l[i] > l[i + 1]:\n                return False\n    elif l[0] > l[1]:\n        for i in range(1, len(l) - 1):\n            if l[i] < l[i + 1]:\n                return False\n    else:\n        for i in range(1, len(l) - 1):\n            if l[i] != l[i + 1]:\n                return False\n    return True"}
{"idx": 58, "completion": "common_elements = set(l1) & set(l2)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function first checks if the number is even, and if so, it divides the number by 2 until it's no longer divisible by 2. \n    # Then, it checks for odd divisors starting from 3 up to the square root of the number. \n    # If a divisor is found, the function divides the number by this divisor and repeats the process. \n    # The largest prime factor found during this process is returned.\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * i)\n    return result"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif i == len(s) - 1 and (s[i] == 'y' or s[i] == 'Y'):\n            count += 1\n    return count"}
{"idx": 65, "completion": "s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[-shift:] + s[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n            elif num == min_even and i < min_index:\n                min_index = i\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "from collections import Counter\n    counts = Counter(lst)\n    candidates = [num for num in counts if counts[num] >= num]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_sorted = sorted(lst)\n    while lst_sorted:\n        if len(lst_sorted) == 1:\n            sorted_lst.append(lst_sorted[0])\n            break\n        min_val = lst_sorted.pop(0)\n        max_val = lst_sorted.pop(-1)\n        sorted_lst.append(min_val)\n        sorted_lst.append(max_val)\n    return sorted_lst"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    sum_elements = sum(q)\n    \n    # Return True if the list is a palindrome and the sum is less than or equal to the maximum weight, False otherwise\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    if n == 0:\n        return 0\n    # Create a 2D array to store the minimum changes needed for subarrays\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the table for subarrays of length 2\n    for i in range(n - 1):\n        dp[i][i + 1] = 0 if arr[i] == arr[i + 1] else 1\n    \n    # Fill the table for subarrays of length > 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a//i):\n                    if (a//i) % k == 0:\n                        break\n                else:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    # Check if the input is positive\n    elif a > 0:\n        # Iterate through possible cube roots from 0 to a\n        for i in range(0, a + 1):\n            # If the cube of the current number equals the input, return True\n            if i ** 3 == a:\n                return True\n            # If the cube of the current number exceeds the input, return False\n            elif i ** 3 > a:\n                return False\n    # Handle negative numbers\n    else:\n        # Iterate through possible cube roots from 0 to the absolute value of a\n        for i in range(0, abs(a) + 1):\n            # If the cube of the negative current number equals the input, return True\n            if (-i) ** 3 == a:\n                return True\n            # If the cube of the negative current number is less than the input, return False\n            elif (-i) ** 3 < a:\n                return False\n    # If no cube root is found, return False\n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 10 ** (n - 1) - 9 ** (n - 1)"}
{"idx": 84, "completion": "# Sum the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_str = bin(digit_sum)[2:]\n    \n    return binary_str"}
{"idx": 85, "completion": "return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    first = array[0]\n    last = array[-1]\n    total = first + last\n    \n    if total % 2 == 1:\n        # Sort in ascending order\n        return sorted(array)\n    else:\n        # Sort in descending order\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4  # Shift down by two multiplied by two (2*2=4)\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    unique_sorted = sorted(list(set(lst)))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = \"aeiouAEIOU\"\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving 2 places ahead\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            encoded.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.islower():\n                encoded.append(char.upper())\n            else:\n                encoded.append(char.lower())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = -1\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    if max_prime == -1:\n        return 0  # assuming no primes found, though problem says there's at least one\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "return (a % 10) * (b % 10)"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Convert the string to a float\n    num = float(value)\n    # Get the integer part of the number\n    integer_part = int(num)\n    # Get the fractional part of the number\n    fractional_part = num - integer_part\n    \n    # Determine the closest integer based on the fractional part\n    if fractional_part == 0.5:\n        # If the number is exactly halfway between two integers, round away from zero\n        if num > 0:\n            return integer_part + 1\n        else:\n            return integer_part - 1\n    elif fractional_part < 0.5:\n        # If the fractional part is less than 0.5, round down\n        return integer_part\n    else:\n        # If the fractional part is greater than 0.5, round up\n        if num > 0:\n            return integer_part + 1\n        else:\n            return integer_part - 1"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    else:\n        for num in range(y, x - 1, -1):\n            if num % 2 == 0:\n                return num\n        return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = round(total / (m - n + 1))\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    \n    # Filter and sort the array\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    \n    # Map numbers to their corresponding names\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    result = [number_names[num] for num in filtered]\n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Calculate factorial for even i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Calculate sum for odd i\n            sum_num = 0\n            for j in range(1, i + 1):\n                sum_num += j\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange with odd numbers in lst1\n    if any(num % 2 == 0 for num in lst2):\n        return \"YES\"\n    \n    # If no even numbers in lst2, check if there are any odd numbers in lst1 that can be exchanged with even numbers in lst2\n    if any(num % 2 != 0 for num in lst1) and any(num % 2 == 0 for num in lst2):\n        return \"YES\"\n    \n    # If none of the above conditions are met, return \"NO\"\n    return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        odd_digits = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                odd_digits += 1\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word towards the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            # Check if the characters before and after are consonants\n            if word[i-1] in consonants and word[i+1] in consonants:\n                return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    # Check if either string is balanced\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    # Check if concatenation in any order is balanced\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [x for x in collatz_sequence if x % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if day < 1 or day > 29:\n            return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n\n    # Check if the list is sorted in ascending order\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n\n    return True"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    start = max(start1, start2)\n    end = min(end1, end2)\n\n    # Check if there is an overlap\n    if start > end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = end - start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    \n    product = 1\n    total = 0\n    \n    for num in arr:\n        if num > 0:\n            product *= 1\n            total += num\n        elif num < 0:\n            product *= -1\n            total += -num  # add the magnitude (absolute value)\n        else:\n            product = 0\n            # once a zero is encountered, the product will remain zero\n            # but we still need to process the rest to get the total magnitude\n            # however, since the product is zero, the final result will be zero\n            # so we can break early for efficiency\n            break\n    \n    # if product is zero, the result is zero regardless of total\n    if product == 0:\n        return 0\n    else:\n        return product * total"}
{"idx": 129, "completion": "n = len(grid)\n    min_val = float('inf')\n    min_path = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_path = [grid[i][j]]\n    \n    if k == 1:\n        return min_path\n    \n    for _ in range(k - 1):\n        next_val = float('inf')\n        next_i, next_j = -1, -1\n        for i in range(n):\n            for j in range(n):\n                if (i, j) in [(x, y) for x, y in get_neighbors(n, min_path[-1][0], min_path[-1][1])]:\n                    if grid[i][j] < next_val:\n                        next_val = grid[i][j]\n                        next_i, next_j = i, j\n        min_path.append(grid[next_i][next_j])\n    \n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        sequence = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                next_num = 1 + i // 2\n            else:\n                next_num = sequence[i - 1] + sequence[i - 2] + sequence[i + 1 - 3]  # Adjusted index for tri(n+1)\n            sequence.append(next_num)\n        return sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        d = int(d)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if len(stack) > 0 and stack[-1] == '[':\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack) == 0 and string.count('[') >= 2 and string.count(']') >= 2"}
{"idx": 133, "completion": "squared_sum = 0\n    for num in lst:\n        ceiling = math.ceil(num)\n        squared_sum += ceiling ** 2\n    return squared_sum"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "def parse_value(value):\n        if isinstance(value, str):\n            # Replace comma with dot for consistent parsing\n            value = value.replace(',', '.')\n            if '.' in value:\n                return float(value)\n            else:\n                return int(value)\n        return value\n\n    val_a = parse_value(a)\n    val_b = parse_value(b)\n\n    if val_a == val_b:\n        return None\n    elif val_a > val_b:\n        return a\n    else:\n        return b"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    i = 0\n    while i < len(text) - 2:\n        if text[i] == '_' and text[i+1] == '_' and text[i+2] == '_':\n            # Find the end of the consecutive underscores\n            j = i + 3\n            while j < len(text) and text[j] == '_':\n                j += 1\n            # Replace the consecutive underscores with a dash\n            text = text[:i] + '-' + text[j:]\n            # Move the index to the character after the dash\n            i = j - (j - i - 1)\n        else:\n            i += 1\n    \n    return text"}
{"idx": 141, "completion": "# Count the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    \n    # Check if there are more than three digits\n    if digit_count > 3:\n        return 'No'\n    \n    # Split the file name into parts before and after the dot\n    parts = file_name.split('.')\n    \n    # Check if there is exactly one dot\n    if len(parts) != 2:\n        return 'No'\n    \n    before_dot, after_dot = parts\n    \n    # Check if the part before the dot is not empty and starts with a letter\n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check if the part after the dot is one of the allowed extensions\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # If all checks passed, return 'Yes'\n    return 'Yes'"}
{"idx": 142, "completion": "if not lst:\n        return 0\n    sum = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            sum += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            sum += lst[i] ** 3\n        else:\n            sum += lst[i]\n    return sum"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_numerator, x_denominator = map(int, x.split('/'))\n    n_numerator, n_denominator = map(int, n.split('/'))\n    \n    product_numerator = x_numerator * n_numerator\n    product_denominator = x_denominator * n_denominator\n    \n    return product_numerator % product_denominator == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "# List of planets in order from the Sun\n    planets_order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are in the list\n    if planet1 not in planets_order or planet2 not in planets_order:\n        return ()\n    \n    # Find the indices of the two planets\n    index1 = planets_order.index(planet1)\n    index2 = planets_order.index(planet2)\n    \n    # Determine the start and end indices\n    start = min(index1, index2) + 1\n    end = max(index1, index2)\n    \n    # Extract the planets between the two indices\n    if start > end:\n        return ()\n    result = planets_order[start:end]\n    \n    # Return the result as a tuple\n    return tuple(result)"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "return [abs(score - guess) for score, guess in zip(game, guess)]"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Generate all rotations of the second word\n    rotations = set()\n    n = len(b)\n    for i in range(n):\n        rotation = b[i:] + b[:i]\n        rotations.add(rotation)\n    \n    # Check if any rotation is a substring of the first word\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)"}
{"idx": 156, "completion": "# Create a dictionary to map integers to their corresponding Roman numerals\n    roman_numerals = {\n        1: 'i',\n        4: 'iv',\n        5: 'v',\n        9: 'ix',\n        10: 'x',\n        40: 'xl',\n        50: 'l',\n        90: 'xc',\n        100: 'c',\n        400: 'cd',\n        500: 'd',\n        900: 'cm',\n        1000: 'm'\n    }\n    \n    # Initialize an empty string to store the Roman numeral\n    roman_numeral = ''\n    \n    # Iterate through the dictionary in descending order of keys\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        # While the current number is greater than or equal to the current value\n        while number >= value:\n            # Subtract the value from the number and append the corresponding Roman numeral\n            roman_numeral += roman_numerals[value]\n            number -= value\n    \n    return roman_numeral"}
{"idx": 157, "completion": "# Check if the sides form a right-angled triangle\n    sides = sorted([a, b, c])\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    carrots_left = max(0, remaining - need)\n    return [total_eaten, carrots_left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i+1])\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for num in range(a, b + 1):\n        if all(digit % 2 == 0 for digit in map(int, str(num))):\n            result.append(num)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    current_group = []\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n            current_group.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                current_group.append(char)\n                if not stack:\n                    result.append(''.join(current_group))\n                    current_group = []\n        elif char != ' ':\n            current_group.append(char)\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i in range(len(numbers)):\n        if i > 0:\n            result.append(delimeter)\n        result.append(numbers[i])\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    max_levels = []\n    for group in groups:\n        max_level = 0\n        current_level = 0\n        for char in group:\n            if char == '(':\n                current_level += 1\n                if current_level > max_level:\n                    max_level = current_level\n            elif char == ')':\n                if current_level > 0:\n                    current_level -= 1\n                else:\n                    # Unbalanced parentheses, handle as needed\n                    pass\n        max_levels.append(max_level)\n    return max_levels"}
{"idx": 7, "completion": "return [s for s in strings if substring in s]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    return (sum(numbers), 1 if not numbers else __import__('functools').reduce(lambda x, y: x * y, numbers))"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    if is_palindrome(string):\n        return string\n    # Find the longest palindromic suffix\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            # Found the longest palindromic suffix\n            # Append to the string the reverse of the string prefix that comes before the palindromic suffix\n            return string + string[:i][::-1]\n    return string  # Should never reach here for non-empty string"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must have the same length.\")\n    \n    result = []\n    for bit_a, bit_b in zip(a, b):\n        if bit_a == '1' and bit_b == '1':\n            result.append('0')\n        elif bit_a == '1' or bit_b == '1':\n            result.append('1')\n        else:\n            result.append('0')\n    \n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_length = 0\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    return [note_to_beats[note] for note in music_string.split()]"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list_sorted = sorted(numbers_list, key=lambda x: number_map[x])\n    return ' '.join(numbers_list_sorted)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "length = 0\n    for _ in string:\n        length += 1\n    return length"}
{"idx": 24, "completion": "for d in range(n - 1, 0, -1):\n        if n % d == 0:\n            return d\n    return 1"}
{"idx": 25, "completion": "factors = []\n    if n == 1:\n        return factors\n    # Start with the smallest prime number\n    divisor = 2\n    while divisor * divisor <= n:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "# Create a dictionary to keep track of the count of each number\n    count_dict = {}\n    # Iterate through the list to populate the dictionary\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    # Create a new list with numbers that have a count of 1, in the original order\n    result = [num for num in numbers if count_dict[num] == 1]\n    return result"}
{"idx": 27, "completion": "new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    lo = -1\n    hi = 1\n    while poly(xs, lo) * poly(xs, hi) > 0:\n        lo *= 2\n        hi *= 2\n    while hi - lo > 1e-10:  # 1 \u00d7 10^\u221210 = 0.0000000001\n        mid = (lo + hi) / 2\n        if poly(xs, lo) * poly(xs, mid) <= 0:\n            hi = mid\n        else:\n            lo = mid\n    return lo"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = l[::2]\n    even_indicies_sorted = sorted(even_indicies)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indicies_sorted[i//2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fib = [0, 1]\n    primes = []\n    while len(primes) < n:\n        next_fib = fib[-1] + fib[-2]\n        fib.append(next_fib)\n        if is_prime(next_fib):\n            primes.append(next_fib)\n    return primes[n-1]"}
{"idx": 40, "completion": "n = len(l)\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(reversed(digits))"}
{"idx": 45, "completion": "return 0.5 * a * h"}
{"idx": 46, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 0\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n+1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "text = text.lower()\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = []\n    for char in text:\n        if char not in vowels:\n            result.append(char)\n    return ''.join(result)"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x - y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        a, b = 0, 1\n        for _ in range(2, n+1):\n            a, b = b, a + b\n        return b"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) <= 2:\n        return True\n    increasing = True\n    decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            increasing = False\n        if l[i] < l[i + 1]:\n            decreasing = False\n    return increasing or decreasing"}
{"idx": 58, "completion": "common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function starts by initializing a variable i to 2, which is the smallest prime number.\n    i = 2\n    # The while loop continues as long as i squared is less than or equal to n. This is because if i is larger than the square root of n, then i cannot be a factor of n that hasn't been checked already.\n    while i * i <= n:\n        # Inside the loop, the function checks if i is a factor of n. If it is, it divides n by i. This effectively reduces n to the largest possible value that is not divisible by i, thus removing all factors of i from n.\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    # Once the loop ends, the remaining value of n is the largest prime factor. This is because all smaller factors have been divided out, and the loop stops when i exceeds the square root of the remaining n, which means the remaining n is prime.\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "return [x * i for i, x in enumerate(xs[1:], 1)]"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n+1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = \"aeiouAEIOU\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i].lower() == 'y':\n            count += 1\n    return count"}
{"idx": 65, "completion": "x = str(x)\n    if shift > len(x):\n        return x[::-1]\n    else:\n        return x[-shift:] + x[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for index, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = index\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "# Your code here\n    for i in range(len(lst)):\n        if lst.count(i) >= i:\n            return i\n    return -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_sorted = sorted(lst)\n    while lst_sorted:\n        if len(lst_sorted) == 1:\n            sorted_lst.append(lst_sorted[0])\n            break\n        min_val = lst_sorted.pop(0)\n        max_val = lst_sorted.pop(-1)\n        sorted_lst.append(min_val)\n        sorted_lst.append(max_val)\n    return sorted_lst"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements in the list\n    sum_elements = sum(q)\n    \n    # Return True if the list is a palindrome and the sum is less than or equal to w, False otherwise\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    # Create a 2D array to store the number of changes needed\n    # dp[i][j] will represent the minimum changes needed for the subarray arr[i..j]\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the table for subarrays of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a//i):\n                    if (a//i) % k == 0:\n                        break\n                else:\n                    if is_prime(i) and is_prime(a//i):\n                        return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the absolute value of 'a' has an integer cube root\n    # If 'a' is 0, it's a special case since 0^3 is 0\n    if a == 0:\n        return True\n    # Find the cube root of the absolute value of 'a' and round it to the nearest integer\n    cube_root = round(abs(a) ** (1/3))\n    # Check if the cube of the rounded value equals the absolute value of 'a'\n    return cube_root ** 3 == abs(a)"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 10 ** (n - 1) - 9 * 10 ** (n - 2)"}
{"idx": 84, "completion": "# Calculate the sum of the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the digit sum to binary and return as a string\n    return bin(digit_sum)[2:]"}
{"idx": 85, "completion": "sum = 0\n    for i in range(1, len(lst), 2):\n        if lst[i] % 2 == 0:\n            sum += lst[i]\n    return sum"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    first = array[0]\n    last = array[-1]\n    total = first + last\n    \n    if total % 2 == 1:\n        # Sort in ascending order\n        return sorted(array)\n    else:\n        # Sort in descending order\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4  # Shift by 2 multiplied by 2 (i.e., 4)\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n            else:\n                if shifted > ord('Z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    unique_sorted = sorted(list(set(lst)))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = \"aeiouAEIOU\"\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving 2 places ahead\n            new_char = chr(ord(char) + 2)\n            # Handle overflow (e.g., 'y' becomes 'a', 'Y' becomes 'A')\n            if (char.islower() and new_char > 'z') or (char.isupper() and new_char > 'Z'):\n                new_char = chr(ord(new_char) - 26)\n            encoded.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.islower():\n                encoded.append(char.upper())\n            else:\n                encoded.append(char.lower())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n < 2:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digit of each number\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_a * unit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "num = float(value)\n    if num - int(num) == 0.5:\n        if num > 0:\n            return int(num) + 1\n        else:\n            return int(num) - 1\n    else:\n        return round(num)"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    else:\n        for num in range(y, x-1, -1):\n            if num % 2 == 0:\n                return num\n        return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    count = 0\n    for num in range(n, m+1):\n        total += num\n        count += 1\n    average = round(total / count)\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    \n    # Filter and sort the array\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    \n    # Map numbers to their corresponding names\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    result = [number_names[num] for num in filtered]\n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            fact = 1\n            for j in range(1, i+1):\n                fact *= j\n            result.append(fact)\n        else:\n            # Compute sum for odd i\n            sum_num = 0\n            for j in range(1, i+1):\n                sum_num += j\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    for i in range(n):\n        if arr == sorted_arr:\n            return True\n        arr = [arr[-1]] + arr[:-1]\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 that can be exchanged with odd numbers in lst1\n    for num in lst1:\n        if num % 2 != 0:\n            # Look for an even number in lst2 to exchange\n            for i in range(len(lst2)):\n                if lst2[i] % 2 == 0:\n                    # Exchange the numbers\n                    lst1.remove(num)\n                    lst1.append(lst2[i])\n                    lst2.remove(lst2[i])\n                    lst2.append(num)\n                    # Recursively check if the exchange leads to all even numbers in lst1\n                    if exchange(lst1, lst2) == \"YES\":\n                        return \"YES\"\n                    # Backtrack if the exchange doesn't work\n                    lst1.remove(lst2[-1])\n                    lst1.append(num)\n                    lst2.remove(num)\n                    lst2.append(lst1[-1])\n                    break\n            else:\n                # No even number found in lst2 to exchange\n                return \"NO\"\n    \n    # After all possible exchanges, check if lst1 is all even\n    return \"YES\" if all(num % 2 == 0 for num in lst1) else \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        odd_digits = [d for d in s if int(d) % 2 != 0]\n        count = len(odd_digits)\n        replaced = f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\"\n        result.append(replaced)\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "# Initialize the total number of bucket dips to 0\n    total_dips = 0\n    \n    # Iterate over each well in the grid\n    for well in grid:\n        # Calculate the total units of water in the current well\n        water_units = sum(well)\n        # Determine the number of times the bucket needs to be dipped for this well\n        # This is the ceiling of water_units divided by the bucket's capacity\n        dips = math.ceil(water_units / capacity) if capacity != 0 else 0\n        # Add the dips for this well to the total\n        total_dips += dips\n    \n    return total_dips"}
{"idx": 116, "completion": "# Handle the empty array case\n    if not arr:\n        return []\n\n    # Separate negative and non-negative numbers\n    negative_nums = [x for x in arr if x < 0]\n    non_negative_nums = [x for x in arr if x >= 0]\n\n    # Sort negative numbers in descending order (since -6 < -5, but we want -6 first)\n    negative_nums_sorted = sorted(negative_nums, reverse=False)\n\n    # Sort non-negative numbers based on the number of 1's in their binary representation\n    # For numbers with the same number of 1's, sort by their decimal value\n    def key_func(x):\n        return (bin(x).count('1'), x)\n\n    non_negative_sorted = sorted(non_negative_nums, key=key_func)\n\n    # Combine the results: negative numbers first, then non-negative numbers\n    return negative_nums_sorted + non_negative_sorted"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word towards the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    if len(s1) == 0 or len(s2) == 0:\n        return 'Yes'\n    if s1[0] == ')' and s2[-1] == '(':\n        return 'No'\n    if s1[-1] == '(' and s2[0] == ')':\n        return 'No'\n    return 'Yes'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 == 1:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum_ = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum_ += arr[i]\n    return sum_"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [x for x in collatz_sequence if x % 2 != 0]\n    odd_numbers_sorted = sorted(odd_numbers)\n    return odd_numbers_sorted"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if day < 1 or day > 29:\n                return False\n        else:\n            if day < 1 or day > 28:\n                return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    # Check if sorted\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return \"NO\"\n    length = end - start + 1\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    for num in arr:\n        if num > 0:\n            product *= 1\n        elif num < 0:\n            product *= -1\n        else:\n            product *= 0\n    return sum(abs(num) for num in arr) * product"}
{"idx": 129, "completion": "n = len(grid)\n    min_path = None\n\n    for i in range(n):\n        for j in range(n):\n            path = [grid[i][j]]\n            visited = set([(i, j)])\n\n            for _ in range(k - 1):\n                min_val = float('inf')\n                next_pos = None\n\n                for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                    ni, nj = i + di, j + dj\n                    if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                        if grid[ni][nj] < min_val:\n                            min_val = grid[ni][nj]\n                            next_pos = (ni, nj)\n\n                if next_pos is None:\n                    break\n\n                i, j = next_pos\n                path.append(min_val)\n                visited.add((i, j))\n\n            if len(path) == k and (min_path is None or path < min_path):\n                min_path = path\n\n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        res = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                res.append(1 + i // 2)\n            else:\n                res.append(res[i - 1] + res[i - 2] + res[i + 1])\n        return res"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n            has_odd = True\n    if has_odd:\n        return product\n    else:\n        return 0"}
{"idx": 132, "completion": "# Check if the string is empty or has only one pair of brackets\n    if len(string) < 4:\n        return False\n    \n    stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if not stack:\n                return False\n            stack.pop()\n    \n    # After processing all characters, if the stack is not empty, it means there are unmatched opening brackets\n    if stack:\n        return False\n    \n    # Now, check if there is at least one pair of nested brackets\n    # We can do this by checking if the string contains the pattern '[[]' or ']]' or any other valid nested pattern\n    # But a more efficient way is to look for any occurrence of '[' followed by '[' before a corresponding ']'\n    # So, we can look for the pattern '[[' anywhere in the string\n    if '[[' in string or ']]' in string:\n        return True\n    else:\n        return False"}
{"idx": 133, "completion": "import math\n    return sum([math.ceil(x)**2 for x in lst])"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "largest_index = -1\n    for i in range(1, len(arr)):\n        if arr[i] < arr[i-1]:\n            largest_index = i\n    return largest_index"}
{"idx": 136, "completion": "negatives = [num for num in lst if num < 0]\n    positives = [num for num in lst if num > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to strings for processing\n    str_a = str(a)\n    str_b = str(b)\n    \n    # Replace commas with periods to handle different decimal representations\n    str_a_processed = str_a.replace(',', '.')\n    str_b_processed = str_b.replace(',', '.')\n    \n    try:\n        # Attempt to convert processed strings to floats\n        num_a = float(str_a_processed)\n        num_b = float(str_b_processed)\n        \n        if num_a == num_b:\n            return None\n        elif num_a > num_b:\n            return a\n        else:\n            return b\n    except ValueError:\n        # In case conversion fails (unlikely based on problem statement)\n        return None"}
{"idx": 138, "completion": "if n % 2 != 0:\n        return False\n    if n < 8:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    while '__' in text:\n        text = text.replace('__', '-')\n    \n    return text"}
{"idx": 141, "completion": "# Count the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    \n    # Check if there are more than three digits\n    if digit_count > 3:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    parts = file_name.split('.')\n    \n    # Check if there is exactly one dot\n    if len(parts) != 2:\n        return 'No'\n    \n    before_dot, after_dot = parts\n    \n    # Check if the part before the dot is not empty and starts with a letter\n    if not before_dot or not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check if the part after the dot is one of the allowed extensions\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    # If all checks passed, return 'Yes'\n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    primes = []\n    for word in words:\n        if is_prime(len(word)):\n            primes.append(word)\n    return ' '.join(primes)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    numerator = x_num * n_num\n    denominator = x_den * n_den\n    \n    return numerator % denominator == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "planets = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    if planet1 not in planets or planet2 not in planets:\n        return ()\n    index1 = planets.index(planet1)\n    index2 = planets.index(planet2)\n    if index1 < index2:\n        return tuple(planets[index1+1:index2])\n    else:\n        return tuple(planets[index2+1:index1])"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n < 2:\n        return y\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x**2 for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the second word is a substring of the first word\n    if b in a:\n        return True\n    \n    # Generate all rotations of the second word and check if any is a substring of the first word\n    for i in range(1, len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    \n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    while num > 0:\n        digit = num % 10\n        if digit % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n        num = num // 10\n    return (even, odd)"}
{"idx": 156, "completion": "# Define the mapping of integers to Roman numerals\n    roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    # Sort the keys in descending order to handle the largest values first\n    sorted_keys = sorted(roman_numerals.keys(), reverse=True)\n    \n    result = []\n    \n    for key in sorted_keys:\n        while number >= key:\n            result.append(roman_numerals[key])\n            number -= key\n    \n    return ''.join(result).lower()"}
{"idx": 157, "completion": "# Sort the sides to identify the hypotenuse (longest side)\n    sides = sorted([a, b, c])\n    # Check if the sum of the squares of the two shorter sides equals the square of the longest side\n    return sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "if remaining >= need:\n        total = number + need\n        left = remaining - need\n    else:\n        total = number + remaining\n        left = 0\n    return [total, left]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i+1])\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    else:\n        return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                if not stack:\n                    result.append('()')\n            else:\n                pass  # unbalanced, ignore\n        elif char == ' ':\n            pass  # ignore spaces\n        else:\n            pass  # invalid character, ignore\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n\n    return mad"}
{"idx": 5, "completion": "if not numbers:\n        return []\n    \n    result = []\n    for i in range(len(numbers) - 1):\n        result.append(numbers[i])\n        result.append(delimeter)\n    result.append(numbers[-1])\n    \n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n        result.append(max_depth)\n    return result"}
{"idx": 7, "completion": "filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    max_len = 0\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            max_len = len(string) - i\n            break\n    return string + string[:max_len - 1][::-1]"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length.\")\n    \n    result = []\n    for bit_a, bit_b in zip(a, b):\n        if bit_a == '1' and bit_b == '1':\n            result.append('0')\n        elif bit_a == '1' or bit_b == '1':\n            result.append('1')\n        else:\n            result.append('0')\n    \n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_len = -1\n    longest_str = None\n    for s in strings:\n        if len(s) > max_len:\n            max_len = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    return [note_to_beats[note] for note in music_string.split()]"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list.sort(key=lambda x: number_map[x])\n    return ' '.join(numbers_list)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    for i in range(len(numbers) - 1):\n        diff = numbers[i + 1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i + 1])\n    return closest_pair"}
{"idx": 21, "completion": "min_num = min(numbers)\n    max_num = max(numbers)\n    range_num = max_num - min_num\n    if range_num == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_num) / range_num for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "pass"}
{"idx": 24, "completion": "for d in range(n - 1, 0, -1):\n        if n % d == 0:\n            return d\n    return 1"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while n > 1:\n        while n % divisor == 0:\n            factors.append(divisor)\n            n //= divisor\n        divisor += 1\n    return factors"}
{"idx": 26, "completion": "# Create a dictionary to keep track of the count of each number\n    count = {}\n    # Iterate through the list to count each number\n    for num in numbers:\n        if num in count:\n            count[num] += 1\n        else:\n            count[num] = 1\n    # Create a new list with numbers that have a count of 1\n    result = [num for num in numbers if count[num] == 1]\n    return result"}
{"idx": 27, "completion": "new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    a, b = -1, 1\n    while poly(xs, a) * poly(xs, b) > 0:\n        a, b = a * 2, b * 2\n\n    while (b - a) > 1e-10:  # 1e-10 is epsilon error threshold\n        mid = (a + b) / 2\n        if poly(xs, a) * poly(xs, mid) > 0:\n            a = mid\n        else:\n            b = mid\n    return a"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = []\n    even_values = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            even_indicies.append(i)\n            even_values.append(l[i])\n    even_values = sorted(even_values)\n    for i in range(len(even_indicies)):\n        l[even_indicies[i]] = even_values[i]\n    return l"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    fib_numbers = [0, 1]\n    prime_fib_numbers = []\n    while len(prime_fib_numbers) < n:\n        next_fib = fib_numbers[-1] + fib_numbers[-2]\n        fib_numbers.append(next_fib)\n        if is_prime(next_fib):\n            prime_fib_numbers.append(next_fib)\n    return prime_fib_numbers[n-1]"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n * n"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "for i in range(len(l)):\n        for j in range(len(l)):\n            if i != j and l[i] + l[j] == 0:\n                return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(digits[::-1])"}
{"idx": 45, "completion": "return 0.5 * a * h"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x - y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == \"<\":\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) == 1:\n        return True\n    if l[0] < l[1]:\n        for i in range(1, len(l)-1):\n            if l[i] > l[i+1]:\n                return False\n        return True\n    elif l[0] > l[1]:\n        for i in range(1, len(l)-1):\n            if l[i] < l[i+1]:\n                return False\n        return True\n    else:\n        for i in range(1, len(l)-1):\n            if l[i] != l[i+1]:\n                return False\n        return True"}
{"idx": 58, "completion": "common_elements = set(l1) & set(l2)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function returns the largest prime factor of n. It does so by first finding the smallest prime factor of n, then dividing n by that factor, and repeating the process with the resulting quotient until it becomes 1. The largest prime factor found in this process is returned.\n    # For example, when n is 13195, the smallest prime factor is 5, so we divide 13195 by 5 to get 2639. The smallest prime factor of 2639 is 7, so we divide 2639 by 7 to get 377. The smallest prime factor of 377 is 13, so we divide 377 by 13 to get 29. The smallest prime factor of 29 is 29, so we divide 29 by 29 to get 1. The largest prime factor found is 29.\n    # The function works by iterating from 2 upwards, checking if each number is a factor of the current n. If it is, it divides n by that number and repeats the process. The loop breaks when i*i exceeds the current n, at which point the remaining n is the largest prime factor if it's greater than 1.\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "return [x * i for i, x in enumerate(xs[1:], 1)]"}
{"idx": 63, "completion": "if n == 0 or n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = {'a', 'e', 'i', 'o', 'u'}\n    s_lower = s.lower()\n    count = 0\n    for i in range(len(s_lower)):\n        if s_lower[i] in vowels:\n            count += 1\n        elif s_lower[i] == 'y' and i == len(s_lower) - 1:\n            count += 1\n    return count"}
{"idx": 65, "completion": "x = str(x)\n    if shift > len(x):\n        return x[::-1]\n    else:\n        return x[-shift:] + x[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n\n    smallest_even = None\n    smallest_index = -1\n\n    for index, value in enumerate(arr):\n        if value % 2 == 0:\n            if smallest_even is None or value < smallest_even or (value == smallest_even and index < smallest_index):\n                smallest_even = value\n                smallest_index = index\n\n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []"}
{"idx": 69, "completion": "# Your code here\n    for i in range(len(lst)):\n        if lst.count(i) >= i:\n            return i\n    return -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_sorted = sorted(lst)\n    while lst_sorted:\n        if len(lst_sorted) == 1:\n            sorted_lst.append(lst_sorted[0])\n            break\n        min_val = lst_sorted[0]\n        max_val = lst_sorted[-1]\n        sorted_lst.append(min_val)\n        sorted_lst.append(max_val)\n        lst_sorted = lst_sorted[1:-1]\n    return sorted_lst"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    if q != q[::-1]:\n        return False\n    # Check if the sum of the elements is less than or equal to the maximum weight\n    if sum(q) > w:\n        return False\n    return True"}
{"idx": 73, "completion": "n = len(arr)\n    if n == 0:\n        return 0\n    # Create a 2D array to store the number of changes needed\n    # dp[i][j] will represent the number of changes needed to make the subarray arr[i..j] palindromic\n    dp = [[0 for _ in range(n)] for _ in range(n)]\n    \n    # Fill the dp table for all subarrays of length 2 and more\n    for length in range(2, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a // i):\n                    if (a // i) % k == 0:\n                        break\n                else:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    # Check if the input is 1, which is a cube of 1\n    if a == 1:\n        return True\n    # Check if the input is -1, which is a cube of -1\n    if a == -1:\n        return True\n    # For other numbers, find the cube root and check if it's an integer\n    # We can use the absolute value to handle negative numbers\n    abs_a = abs(a)\n    # Find the cube root\n    cube_root = round(abs_a ** (1/3))\n    # Check if the cube of the cube root equals the original number\n    if cube_root ** 3 == abs_a:\n        return True\n    else:\n        return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length**0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 9 * 10 ** (n - 2) - 9 * 9 * 10 ** (n - 3)"}
{"idx": 84, "completion": "# Calculate the sum of the digits of N\n    digit_sum = sum(int(d) for d in str(N))\n    \n    # Convert the sum to binary and remove the '0b' prefix\n    binary_str = bin(digit_sum)[2:]\n    \n    return binary_str"}
{"idx": 85, "completion": "return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return array\n    first = array[0]\n    last = array[-1]\n    sum_fl = first + last\n    if sum_fl % 2 == 1:\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = ''\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4  # Shift each letter by 4 positions\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n                encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    unique_sorted = sorted(list(set(lst)))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    result = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by shifting 2 places ahead\n            if char.islower():\n                new_char = chr(((ord(char) - ord('a') + 2) % 26) + ord('a'))\n            else:\n                new_char = chr(((ord(char) - ord('A') + 2) % 26) + ord('A'))\n            result.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.islower():\n                result.append(char.upper())\n            else:\n                result.append(char.lower())\n    return ''.join(result)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 2:\n        return []\n    primes = [2]\n    for num in range(3, n):\n        is_prime = True\n        for prime in primes:\n            if num % prime == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digits\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_a * unit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Convert the string to a float\n    num = float(value)\n    \n    # Check if the number is equidistant from two integers\n    if num - int(num) == 0.5:\n        # Round away from zero\n        if num > 0:\n            return int(num) + 1\n        else:\n            return int(num) - 1\n    else:\n        # Use the built-in round function for other cases\n        return round(num)"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    else:\n        for num in range(y, x-1, -1):\n            if num % 2 == 0:\n                return num\n        return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = round(total / (m - n + 1))\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    \n    # Filter and sort the array\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered_sorted = sorted(filtered)\n    filtered_sorted_reversed = filtered_sorted[::-1]\n    \n    # Map numbers to their corresponding names\n    number_names = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\"\n    }\n    \n    result = [number_names[num] for num in filtered_sorted_reversed]\n    \n    return result"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            factorial = 1\n            for num in range(1, i + 1):\n                factorial *= num\n            result.append(factorial)\n        else:\n            # Compute sum for odd i\n            sum_num = 0\n            for num in range(1, i + 1):\n                sum_num += num\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even = 0\n    odd = 0\n    for i in range(1, n + 1):\n        if str(i) == str(i)[::-1]:\n            if i % 2 == 0:\n                even += 1\n            else:\n                odd += 1\n    return (even, odd)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Count the number of odd numbers in lst1 and even numbers in lst2\n    odd_in_lst1 = sum(1 for num in lst1 if num % 2 != 0)\n    even_in_lst2 = sum(1 for num in lst2 if num % 2 == 0)\n    \n    # If there are enough even numbers in lst2 to replace the odd numbers in lst1, return \"YES\"\n    if even_in_lst2 >= odd_in_lst1:\n        return \"YES\"\n    else:\n        return \"NO\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        odd_digits = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                odd_digits += 1\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word to the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    # Check if either string is balanced on its own\n    if is_balanced(s1) or is_balanced(s2):\n        return 'Yes'\n    # Check if concatenating in either order gives a balanced string\n    if is_balanced(s1 + s2) or is_balanced(s2 + s1):\n        return 'Yes'\n    return 'No'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [num for num in collatz_sequence if num % 2 != 0]\n    odd_numbers_sorted = sorted(odd_numbers)\n    return odd_numbers_sorted"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if day < 1 or day > 29:\n                return False\n        else:\n            if day < 1 or day > 28:\n                return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n\n    # Check if the list is sorted in ascending order\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    start = max(start1, start2)\n    end = min(end1, end2)\n\n    # Check if there is an overlap\n    if start > end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = end - start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    magnitude_sum = 0\n    for num in arr:\n        if num > 0:\n            product *= 1\n            magnitude_sum += num\n        elif num < 0:\n            product *= -1\n            magnitude_sum += -num\n        else:\n            product = 0\n            magnitude_sum += 0\n    return product * magnitude_sum"}
{"idx": 129, "completion": "n = len(grid)\n    min_val = float('inf')\n    min_path = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_path = [grid[i][j]]\n    \n    if k == 1:\n        return min_path\n    \n    for _ in range(k - 1):\n        next_val = float('inf')\n        next_i, next_j = -1, -1\n        \n        for i in range(n):\n            for j in range(n):\n                if (i, j) in [(x, y) for x, y in get_neighbors(min_path[-1][0], min_path[-1][1], n)]:\n                    if grid[i][j] < next_val:\n                        next_val = grid[i][j]\n                        next_i, next_j = i, j\n        \n        min_path.append(grid[next_i][next_j])\n    \n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        sequence = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                next_term = 1 + i // 2\n            else:\n                next_term = sequence[i - 1] + sequence[i - 2] + sequence[i + 1 - 3]  # Adjusted index for i+1\n            sequence.append(next_term)\n        return sequence"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        if int(d) % 2 == 1:\n            product *= int(d)\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n    return len(stack) >= 2"}
{"idx": 133, "completion": "return sum([math.ceil(x) ** 2 for x in lst])"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to appropriate numeric types if they are strings\n    def parse_value(value):\n        if isinstance(value, str):\n            # Replace comma with dot to handle both decimal separators\n            value = value.replace(',', '.')\n            try:\n                if '.' in value:\n                    return float(value)\n                else:\n                    return int(value)\n            except ValueError:\n                return None\n        return value\n    \n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n    \n    # Check if parsing was successful\n    if a_parsed is None or b_parsed is None:\n        return None\n    \n    # Compare the parsed values\n    if a_parsed > b_parsed:\n        return a\n    elif b_parsed > a_parsed:\n        return b\n    else:\n        return None"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n + 1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Check the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    before_dot, after_dot = file_name.split('.', 1)\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    valid_extensions = ['txt', 'exe', 'dll']\n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    \n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    \n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            if len(num_str) > 0:\n                first_digit = int(num_str[0])\n                last_digit = int(num_str[-1])\n                if first_digit % 2 != 0 and last_digit % 2 != 0:\n                    count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "# List of planets in order from the Sun\n    planets_order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are in the list\n    if planet1 not in planets_order or planet2 not in planets_order:\n        return ()\n    \n    # Find the indices of the two planets\n    index1 = planets_order.index(planet1)\n    index2 = planets_order.index(planet2)\n    \n    # Determine the start and end indices\n    start = min(index1, index2) + 1\n    end = max(index1, index2)\n    \n    # Extract the planets between the two indices\n    result = planets_order[start:end]\n    \n    # Return the result as a tuple\n    return tuple(result)"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n < 2:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "return sum(x * x for x in lst if x > 0 and x % 2 != 0 and isinstance(x, int))"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for ext in extensions:\n        cap = sum(1 for c in ext if c.isupper())\n        sm = sum(1 for c in ext if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = ext\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the second word is a substring of the first word\n    if b in a:\n        return True\n    \n    # Generate all rotations of the second word and check if any is a substring of the first word\n    for i in range(1, len(b)):\n        rotated = b[i:] + b[:i]\n        if rotated in a:\n            return True\n    \n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even_count = 0\n    odd_count = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 156, "completion": "if not 1 <= number <= 1000:\n        raise ValueError(\"Number must be between 1 and 1000\")\n    \n    val = [\n        1000, 900, 500, 400,\n        100, 90, 50, 40,\n        10, 9, 5, 4,\n        1\n    ]\n    syb = [\n        \"m\", \"cm\", \"d\", \"cd\",\n        \"c\", \"xc\", \"l\", \"xl\",\n        \"x\", \"ix\", \"v\", \"iv\",\n        \"i\"\n    ]\n    roman_num = ''\n    i = 0\n    while number > 0:\n        for _ in range(number // val[i]):\n            roman_num += syb[i]\n            number -= val[i]\n        i += 1\n    return roman_num"}
{"idx": 157, "completion": "# Sort the sides in ascending order\n    sides = sorted([a, b, c])\n    \n    # Check if the sum of the squares of the two smaller sides equals the square of the largest side\n    return sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    remaining_after = max(remaining - need, 0)\n    return [total_eaten, remaining_after]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for i in range(len(operator)):\n        expression += operator[i] + str(operand[i+1])\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    else:\n        return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    stack = []\n    for char in paren_string:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                if not stack:\n                    result.append('()')\n            else:\n                pass  # unbalanced, but we are to ignore per problem statement\n        elif char == ' ':\n            pass  # ignore spaces\n        else:\n            pass  # invalid character, but we are to ignore per problem statement\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i, num in enumerate(numbers):\n        if i != 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    max_depths = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n                else:\n                    # Handle invalid cases where closing parenthesis appears without a matching opening\n                    pass\n        max_depths.append(max_depth)\n    return max_depths"}
{"idx": 7, "completion": "filtered_strings = []\n    for string in strings:\n        if substring in string:\n            filtered_strings.append(string)\n    return filtered_strings"}
{"idx": 8, "completion": "sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "max_so_far = numbers[0]\n    result = []\n    for num in numbers:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    if is_palindrome(string):\n        return string\n    # Find the longest palindromic suffix\n    suffix_length = 1\n    while not is_palindrome(string[-suffix_length:]):\n        suffix_length += 1\n    # The prefix comes before the palindromic suffix\n    prefix = string[:-suffix_length]\n    return string + prefix[::-1]"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError('Inputs must be of the same length')\n    return ''.join([str(int(a[i]) ^ int(b[i])) for i in range(len(a))])"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_length = 0\n    longest_str = None\n    for s in strings:\n        if len(s) > max_length:\n            max_length = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "if a == 0:\n        return b\n    elif b == 0:\n        return a\n    elif a >= b:\n        return greatest_common_divisor(a % b, b)\n    else:\n        return greatest_common_divisor(a, b % a)"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_to_beats = {'o': 4, 'o|': 2, '.|': 1}\n    notes = music_string.split()\n    beats = []\n    for note in notes:\n        if note in note_to_beats:\n            beats.append(note_to_beats[note])\n        else:\n            raise ValueError(f\"Invalid note: {note}\")\n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_words = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    numbers_list = numbers.split()\n    numbers_list.sort(key=lambda x: number_words[x])\n    return ' '.join(numbers_list)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    if min_val == max_val:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / (max_val - min_val) for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "count = 0\n    for _ in string:\n        count += 1\n    return count"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "# Create a dictionary to keep track of the count of each number\n    count_dict = {}\n    # Iterate through the list to populate the dictionary\n    for num in numbers:\n        if num in count_dict:\n            count_dict[num] += 1\n        else:\n            count_dict[num] = 1\n    # Create a new list with numbers that have a count of 1, in the original order\n    result = [num for num in numbers if count_dict[num] == 1]\n    return result"}
{"idx": 27, "completion": "new_string = []\n    for char in string:\n        if char.isupper():\n            new_string.append(char.lower())\n        else:\n            new_string.append(char.upper())\n    return ''.join(new_string)"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "positive = []\n    for num in l:\n        if num > 0:\n            positive.append(num)\n    return positive"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    lo = -1\n    hi = 1\n    while poly(xs, lo) * poly(xs, hi) > 0:\n        lo *= 2\n        hi *= 2\n    while hi - lo > 1e-10:  # floating epsilon\n        mid = (lo + hi) / 2\n        if poly(xs, lo) * poly(xs, mid) > 0:\n            lo = mid\n        else:\n            hi = mid\n    return lo"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = l[::2]\n    even_indicies_sorted = sorted(even_indicies)\n    l_prime = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            l_prime.append(even_indicies_sorted[i//2])\n        else:\n            l_prime.append(l[i])\n    return l_prime"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 1, 1\n    while True:\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a\n        a, b = b, a + b"}
{"idx": 40, "completion": "\"*** YOUR CODE HERE ***\"\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n ** 2"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "s = set(l)\n    for x in l:\n        if -x in s and x != 0:\n            return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(digits[::-1])"}
{"idx": 45, "completion": "return (a * h) / 2"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) // 2]\n    else:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2"}
{"idx": 48, "completion": "text = text.lower()\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = []\n    for char in text:\n        if char not in vowels:\n            result.append(char)\n    return ''.join(result)"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x - y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) == 1:\n        return True\n    else:\n        if l[0] < l[1]:\n            for i in range(len(l)-1):\n                if l[i] > l[i+1]:\n                    return False\n            return True\n        elif l[0] > l[1]:\n            for i in range(len(l)-1):\n                if l[i] < l[i+1]:\n                    return False\n            return True\n        else:\n            for i in range(len(l)-1):\n                if l[i] != l[i+1]:\n                    return False\n            return True"}
{"idx": 58, "completion": "common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function is not implemented yet. To be implemented in the future.\n    # The idea is to divide n by all possible factors starting from 2, and keep track of the largest factor that divides n.\n    # The loop can stop when i*i > n, because if n is not 1 by then, it must be a prime number.\n    # The largest prime factor is the last factor that divides n, or n itself if it is a prime.\n    i = 2\n    while i * i <= n:\n        if n % i:\n            i += 1\n        else:\n            n //= i\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    count = 0\n    for bracket in brackets:\n        if bracket == \"(\":\n            count += 1\n        else:\n            count -= 1\n        if count < 0:\n            return False\n    return count == 0"}
{"idx": 62, "completion": "result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * i)\n    return result"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = \"aeiouAEIOU\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        elif s[i] == 'y' or s[i] == 'Y':\n            if i == len(s) - 1:\n                count += 1\n    return count"}
{"idx": 65, "completion": "s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[-shift:] + s[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into a list of words\n    words = s.split()\n    # Extract the number of apples and oranges\n    apples = int(words[0])\n    oranges = int(words[2])\n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    min_even = None\n    min_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if min_even is None or num < min_even:\n                min_even = num\n                min_index = i\n            elif num == min_even and i < min_index:\n                min_index = i\n    \n    if min_even is not None:\n        return [min_even, min_index]\n    else:\n        return []"}
{"idx": 69, "completion": "# Your code here\n    # Create a dictionary to store the frequency of each integer\n    freq = {}\n    for num in lst:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    # Iterate through the dictionary to find the greatest integer that meets the condition\n    max_num = -1\n    for num in freq:\n        if num <= freq[num] and num > max_num:\n            max_num = num\n    return max_num"}
{"idx": 70, "completion": "if not lst:\n        return []\n    lst = sorted(lst)\n    result = []\n    while lst:\n        if len(lst) == 1:\n            result.append(lst[0])\n            break\n        result.append(lst[0])\n        result.append(lst[-1])\n        lst = lst[1:-1]\n    return result"}
{"idx": 71, "completion": "if a + b > c and a + c > b and b + c > a:\n        s = (a + b + c) / 2\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements\n    sum_elements = sum(q)\n    \n    # Determine if the object will fly\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    changes = 0\n    for i in range(n // 2):\n        if arr[i] != arr[n - 1 - i]:\n            changes += 1\n    return changes"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    primes = []\n    for num in range(2, a + 1):\n        if all(num % i != 0 for i in range(2, int(num ** 0.5) + 1)):\n            primes.append(num)\n    for i in range(len(primes)):\n        for j in range(i, len(primes)):\n            for k in range(j, len(primes)):\n                if primes[i] * primes[j] * primes[k] == a:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        if power == x:\n            return True\n        power *= n\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    \n    # Find the absolute value of the input to handle negative numbers\n    abs_a = abs(a)\n    \n    # Iterate through possible cube roots from 0 to the absolute value of the input\n    for i in range(0, abs_a + 1):\n        # Check if the cube of the current number matches the absolute value of the input\n        if i ** 3 == abs_a:\n            return True\n        # If the cube of the current number exceeds the absolute value of the input, break the loop\n        if i ** 3 > abs_a:\n            break\n    \n    # If no cube root is found, return False\n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 2) + 10 ** (n - 1)"}
{"idx": 84, "completion": "total = sum(int(d) for d in str(N))\n    return bin(total)[2:]"}
{"idx": 85, "completion": "return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return array\n    \n    first = array[0]\n    last = array[-1]\n    sum_val = first + last\n    \n    if sum_val % 2 == 1:\n        return sorted(array)\n    else:\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = \"\"\n    for char in s:\n        if char.isalpha():\n            shifted_char = chr(ord(char) + 4)\n            if (char.islower() and shifted_char > 'z') or (char.isupper() and shifted_char > 'Z'):\n                shifted_char = chr(ord(shifted_char) - 26)\n            encrypted += shifted_char\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    unique_sorted = sorted(list(set(lst)))\n    if len(unique_sorted) < 2:\n        return None\n    return unique_sorted[1]"}
{"idx": 91, "completion": "sentences = re.split(r'[.!?]', S)\n    count = 0\n    for sentence in sentences:\n        words = sentence.strip().split()\n        if len(words) > 0 and words[0] == 'I':\n            count += 1\n    return count"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Shift the vowel 2 places ahead\n            if char == 'y':\n                new_char = 'a'\n            elif char == 'Y':\n                new_char = 'A'\n            else:\n                new_char = chr(ord(char) + 2)\n            # Ensure wrapping around for 'y' and 'z'\n            if (char.lower() == 'y' and new_char > 'z') or (char == 'Y' and new_char > 'Z'):\n                new_char = chr(ord(new_char) - 26)\n            encoded_char = new_char\n        else:\n            # Swap the case of non-vowel letters\n            encoded_char = char.swapcase()\n        encoded.append(encoded_char)\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "# Extract the unit digit of each number\n    unit_a = abs(a) % 10\n    unit_b = abs(b) % 10\n    \n    # Multiply the unit digits\n    product = unit_a * unit_b\n    \n    return product"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "num = float(value)\n    if num >= 0:\n        return int(num + 0.5)\n    else:\n        return int(num - 0.5)"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.replace(',', ' ').split()\n    return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return y - 1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = round(total / (m - n + 1))\n    return bin(average)"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even = True\n                break\n        if not has_even:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    return [digit_names[i-1] for i in filtered]"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n + 1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            factorial = 1\n            for j in range(1, i + 1):\n                factorial *= j\n            result.append(factorial)\n        else:\n            # Compute sum for odd i\n            sum_num = 0\n            for j in range(1, i + 1):\n                sum_num += j\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -1\n        else:\n            sum_digits = 0\n        while num > 0:\n            sum_digits += num % 10\n            num = num // 10\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    n = len(arr)\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    for i in range(n - 1):\n        if arr[i] > arr[i + 1]:\n            break\n    else:\n        return True\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n    \n    # If there are odd numbers in lst1 and even numbers in lst2, it's possible to exchange\n    return \"YES\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    letters = test.split()\n    \n    for letter in letters:\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    if not letter_counts:\n        return {}\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        count = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                count += 1\n        result.append(f\"the number of odd elements {count}n the str{count}ng {count} of the {count}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum += num\n        if current_sum < min_sum:\n            min_sum = current_sum\n        if current_sum > 0:\n            current_sum = 0\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1'), x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word towards the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    if len(s1) == 0 or len(s2) == 0:\n        return 'Yes'\n    if s1[0] == ')' and s2[-1] == '(':\n        return 'No'\n    if s1[-1] == '(' and s2[0] == ')':\n        return 'No'\n    return 'Yes'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst), 2):\n        if lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "if n == 1:\n        return [1]\n    collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [x for x in collatz_sequence if x % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if day < 1 or day > 29:\n            return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    \n    # Check if the list is sorted in ascending order\n    for i in range(len(lst) - 1):\n        if lst[i] > lst[i + 1]:\n            return False\n    \n    return True"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n    # Determine the overlapping interval\n    start = max(start1, start2)\n    end = min(end1, end2)\n    if start > end:\n        return \"NO\"\n    length = end - start\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    sum_magnitudes = 0\n    for num in arr:\n        if num > 0:\n            product *= 1\n            sum_magnitudes += num\n        elif num < 0:\n            product *= -1\n            sum_magnitudes += abs(num)\n        else:\n            product *= 0\n    return product * sum_magnitudes"}
{"idx": 129, "completion": "n = len(grid)\n    min_val = float('inf')\n    min_path = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_path = [grid[i][j]]\n    \n    if k == 1:\n        return min_path\n    \n    def get_neighbors(i, j):\n        neighbors = []\n        if i > 0:\n            neighbors.append((i-1, j))\n        if i < n-1:\n            neighbors.append((i+1, j))\n        if j > 0:\n            neighbors.append((i, j-1))\n        if j < n-1:\n            neighbors.append((i, j+1))\n        return neighbors\n    \n    def dfs(i, j, path, visited):\n        if len(path) == k:\n            return path\n        neighbors = get_neighbors(i, j)\n        min_next_path = None\n        for ni, nj in neighbors:\n            if (ni, nj) not in visited:\n                new_visited = set(visited)\n                new_visited.add((ni, nj))\n                next_path = dfs(ni, nj, path + [grid[ni][nj]], new_visited)\n                if next_path is not None:\n                    if min_next_path is None or next_path < min_next_path:\n                        min_next_path = next_path\n        return min_next_path\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == min_val:\n                path = dfs(i, j, [min_val], set([(i, j)]))\n                if path is not None and (not min_path or path < min_path):\n                    min_path = path\n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    if n == 1:\n        return [1, 3]\n    if n == 2:\n        return [1, 3, 2]\n    res = [1, 3, 2]\n    for i in range(3, n + 1):\n        if i % 2 == 0:\n            res.append(1 + i // 2)\n        else:\n            res.append(res[i - 1] + res[i - 2] + res[i + 1])\n    return res"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for digit in str(n):\n        if int(digit) % 2 != 0:\n            product *= int(digit)\n            has_odd = True\n    if has_odd:\n        return product\n    else:\n        return 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']' and stack:\n            stack.pop()\n            if stack:\n                return True\n    return False"}
{"idx": 133, "completion": "# Round each number in the list up to the nearest integer\n    rounded = [math.ceil(x) for x in lst]\n    \n    # Square each number in the rounded list\n    squared = [x ** 2 for x in rounded]\n    \n    # Sum all the squared numbers\n    total = sum(squared)\n    \n    return total"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to floats if they are strings\n    def parse_value(value):\n        if isinstance(value, str):\n            value = value.replace(',', '.')\n            try:\n                return float(value)\n            except ValueError:\n                return None\n        elif isinstance(value, (int, float)):\n            return float(value)\n        else:\n            return None\n    \n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n    \n    if a_parsed is None or b_parsed is None:\n        return None\n    \n    if a_parsed == b_parsed:\n        return None\n    elif a_parsed > b_parsed:\n        return a\n    else:\n        return b"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace consecutive underscores with a dash\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Check the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    parts = file_name.split('.')\n    if len(parts) != 2:\n        return 'No'\n    \n    before_dot, after_dot = parts\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    valid_extensions = ['txt', 'exe', 'dll']\n    if after_dot not in valid_extensions:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    prime_words = []\n    for word in words:\n        if is_prime(len(word)):\n            prime_words.append(word)\n    return ' '.join(prime_words)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 == 1 and last_digit % 2 == 1:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "# List of planets in order from the Sun\n    planets_order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are in the list\n    if planet1 not in planets_order or planet2 not in planets_order:\n        return ()\n    \n    # Find the indices of the two planets\n    index1 = planets_order.index(planet1)\n    index2 = planets_order.index(planet2)\n    \n    # Determine the start and end indices\n    start = min(index1, index2) + 1\n    end = max(index1, index2)\n    \n    # Extract the planets between the two indices\n    result = planets_order[start:end]\n    \n    # Return the result as a tuple\n    return tuple(result)"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "sum_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            sum_squares += num ** 2\n    return sum_squares"}
{"idx": 152, "completion": "return [abs(score - guess) for score, guess in zip(game, guess)]"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n        elif strength == max_strength:\n            # In case of tie, choose the first one in the list\n            if extensions.index(extension) < extensions.index(strongest_extension):\n                strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "# Check if the second word is a substring of the first word\n    if b in a:\n        return True\n    \n    # Generate all rotations of the second word\n    rotations = []\n    for i in range(len(b)):\n        rotation = b[i:] + b[:i]\n        rotations.append(rotation)\n    \n    # Check if any rotation of the second word is a substring of the first word\n    for rotation in rotations:\n        if rotation in a:\n            return True\n    \n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)"}
{"idx": 156, "completion": "roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    result = []\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            result.append(roman_numerals[value])\n            number -= value\n    return ''.join(result).lower()"}
{"idx": 157, "completion": "# Sort the sides to identify the hypotenuse (longest side)\n    sides = sorted([a, b, c])\n    # Check if the sum of the squares of the two shorter sides equals the square of the longest side\n    return sides[0]**2 + sides[1]**2 == sides[2]**2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique_chars = len(set(word))\n        if unique_chars > max_unique:\n            max_unique = unique_chars\n            max_word = word\n        elif unique_chars == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "total_eaten = number + min(need, remaining)\n    remaining_after = max(remaining - need, 0)\n    return [total_eaten, remaining_after]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for oprt, oprd in zip(operator, operand[1:]):\n        expression += oprt + str(oprd)\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    return ''.join(c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s)"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for i in range(a, b + 1):\n        if i % 2 == 0:\n            result.append(i)\n    return result"}
{"idx": 0, "completion": "for i in range(len(numbers)):\n        for j in range(i + 1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"}
{"idx": 1, "completion": "result = []\n    stack = []\n    current_group = []\n    for char in paren_string:\n        if char == '(':\n            if not stack:\n                current_group = []\n            stack.append(char)\n        elif char == ')':\n            if stack:\n                stack.pop()\n                if not stack:\n                    result.append(''.join(current_group) + ')')\n            else:\n                if current_group:\n                    result.append(''.join(current_group))\n                    current_group = []\n        elif char != ' ':\n            current_group.append(char)\n    if current_group:\n        result.append(''.join(current_group))\n    return result"}
{"idx": 2, "completion": "return number - int(number)"}
{"idx": 3, "completion": "balance = 0\n    for op in operations:\n        balance += op\n        if balance < 0:\n            return True\n    return False"}
{"idx": 4, "completion": "if not numbers:\n        return 0.0\n\n    mean = sum(numbers) / len(numbers)\n    absolute_differences = [abs(x - mean) for x in numbers]\n    mad = sum(absolute_differences) / len(absolute_differences)\n    return mad"}
{"idx": 5, "completion": "result = []\n    for i, num in enumerate(numbers):\n        if i != 0:\n            result.append(delimeter)\n        result.append(num)\n    return result"}
{"idx": 6, "completion": "groups = paren_string.split()\n    result = []\n    for group in groups:\n        max_depth = 0\n        current_depth = 0\n        for char in group:\n            if char == '(':\n                current_depth += 1\n                if current_depth > max_depth:\n                    max_depth = current_depth\n            elif char == ')':\n                if current_depth > 0:\n                    current_depth -= 1\n                else:\n                    # Invalid case, but per problem description, we can assume it's valid\n                    pass\n        result.append(max_depth)\n    return result"}
{"idx": 7, "completion": "return [s for s in strings if substring in s]"}
{"idx": 8, "completion": "if not numbers:\n        return (0, 1)\n    sum_ = 0\n    product = 1\n    for num in numbers:\n        sum_ += num\n        product *= num\n    return (sum_, product)"}
{"idx": 9, "completion": "if not numbers:\n        return []\n    max_so_far = numbers[0]\n    result = [max_so_far]\n    for num in numbers[1:]:\n        if num > max_so_far:\n            max_so_far = num\n        result.append(max_so_far)\n    return result"}
{"idx": 10, "completion": "if not string:\n        return string\n    for i in range(len(string)):\n        if is_palindrome(string[i:]):\n            return string + string[:i][::-1]\n    return string + string[:-1][::-1]"}
{"idx": 11, "completion": "if len(a) != len(b):\n        raise ValueError(\"Input strings must be of the same length.\")\n    \n    result = []\n    for bit_a, bit_b in zip(a, b):\n        if bit_a == '1' and bit_b == '1':\n            result.append('0')\n        elif (bit_a == '1' and bit_b == '0') or (bit_a == '0' and bit_b == '1'):\n            result.append('1')\n        else:\n            result.append('0')\n    \n    return ''.join(result)"}
{"idx": 12, "completion": "if not strings:\n        return None\n    max_len = -1\n    longest_str = None\n    for s in strings:\n        if len(s) > max_len:\n            max_len = len(s)\n            longest_str = s\n    return longest_str"}
{"idx": 13, "completion": "while b != 0:\n        a, b = b, a % b\n    return a"}
{"idx": 14, "completion": "prefixes = []\n    for i in range(1, len(string) + 1):\n        prefixes.append(string[:i])\n    return prefixes"}
{"idx": 15, "completion": "return ' '.join(map(str, range(n + 1)))"}
{"idx": 16, "completion": "return len(set(string.lower()))"}
{"idx": 17, "completion": "note_to_beats = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split()\n    beats = [note_to_beats[note] for note in notes]\n    return beats"}
{"idx": 18, "completion": "count = 0\n    for i in range(len(string) - len(substring) + 1):\n        if string[i:i+len(substring)] == substring:\n            count += 1\n    return count"}
{"idx": 19, "completion": "number_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9,\n    }\n    numbers = numbers.split()\n    numbers = [number_map[number] for number in numbers]\n    numbers = sorted(numbers)\n    numbers = [str(number) for number in numbers]\n    return ' '.join(numbers)"}
{"idx": 20, "completion": "numbers = sorted(numbers)\n    min_diff = float('inf')\n    closest_pair = (0.0, 0.0)\n    \n    for i in range(len(numbers) - 1):\n        diff = numbers[i+1] - numbers[i]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i], numbers[i+1])\n    \n    return closest_pair"}
{"idx": 21, "completion": "min_val = min(numbers)\n    max_val = max(numbers)\n    range_val = max_val - min_val\n    if range_val == 0:\n        return [0.0] * len(numbers)\n    return [(x - min_val) / range_val for x in numbers]"}
{"idx": 22, "completion": "return [x for x in values if isinstance(x, int) and not isinstance(x, bool)]"}
{"idx": 23, "completion": "count = 0\n    for _ in string:\n        count += 1\n    return count"}
{"idx": 24, "completion": "for i in reversed(range(n)):\n        if n % i == 0:\n            return i\n    return 0"}
{"idx": 25, "completion": "factors = []\n    divisor = 2\n    while divisor * divisor <= n:\n        if n % divisor == 0:\n            factors.append(divisor)\n            n = n // divisor\n        else:\n            divisor += 1\n    if n > 1:\n        factors.append(n)\n    return factors"}
{"idx": 26, "completion": "seen = set()\n    result = []\n    for num in numbers:\n        if num not in seen:\n            seen.add(num)\n            result.append(num)\n    return result"}
{"idx": 27, "completion": "new_string = ''\n    for char in string:\n        if char.isupper():\n            new_string += char.lower()\n        else:\n            new_string += char.upper()\n    return new_string"}
{"idx": 28, "completion": "return ''.join(strings)"}
{"idx": 29, "completion": "return [s for s in strings if s.startswith(prefix)]"}
{"idx": 30, "completion": "return [x for x in l if x > 0]"}
{"idx": 31, "completion": "if n == 1:\n        return False\n    k = 2\n    while k < n:\n        if n % k == 0:\n            return False\n        k += 1\n    return True"}
{"idx": 32, "completion": "assert len(xs) % 2 == 0\n    assert xs[-1] != 0\n    a, b = -1, 1\n    while poly(xs, a) * poly(xs, b) > 0:\n        a, b = a * 2, b * 2\n\n    while (b - a) > 1e-10:  # 1e-10 is epsilon\n        mid = (a + b) / 2\n        if (poly(xs, a) * poly(xs, mid)) > 0:\n            a = mid\n        else:\n            b = mid\n\n    return a"}
{"idx": 33, "completion": "l_ = l.copy()\n    l_[::3] = sorted(l_[::3])\n    return l_"}
{"idx": 34, "completion": "return sorted(list(set(l)))"}
{"idx": 35, "completion": "return max(l)"}
{"idx": 36, "completion": "count = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            count += str(i).count('7')\n    return count"}
{"idx": 37, "completion": "even_indicies = []\n    even_values = []\n    for i in range(len(l)):\n        if i % 2 == 0:\n            even_indicies.append(i)\n            even_values.append(l[i])\n    even_values = sorted(even_values)\n    for i in range(len(even_indicies)):\n        l[even_indicies[i]] = even_values[i]\n    return l"}
{"idx": 38, "completion": "# split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[-1] + group[:-1]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"}
{"idx": 39, "completion": "def is_prime(num: int):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n\n    count = 0\n    a, b = 1, 1\n    while True:\n        a, b = b, a + b\n        if is_prime(a):\n            count += 1\n            if count == n:\n                return a"}
{"idx": 40, "completion": "n = len(l)\n    if n < 3:\n        return False\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"}
{"idx": 41, "completion": "return n ** 2"}
{"idx": 42, "completion": "return [x + 1 for x in l]"}
{"idx": 43, "completion": "s = set(l)\n    for x in l:\n        if -x in s and x != 0:\n            return True\n    return False"}
{"idx": 44, "completion": "if x == 0:\n        return '0'\n    digits = []\n    while x > 0:\n        digits.append(str(x % base))\n        x = x // base\n    return ''.join(digits[::-1])"}
{"idx": 45, "completion": "return (a * h) / 2"}
{"idx": 46, "completion": "if n == 0 or n == 1 or n == 3:\n        return 0\n    elif n == 2:\n        return 2\n    else:\n        a, b, c, d = 0, 0, 2, 0\n        for _ in range(4, n + 1):\n            a, b, c, d = b, c, d, a + b + c + d\n        return d"}
{"idx": 47, "completion": "l_sorted = sorted(l)\n    n = len(l_sorted)\n    if n % 2 == 1:\n        return l_sorted[n // 2]\n    else:\n        return (l_sorted[n // 2 - 1] + l_sorted[n // 2]) / 2"}
{"idx": 48, "completion": "if len(text) == 0:\n        return True\n    return text == text[::-1]"}
{"idx": 49, "completion": "result = 1\n    for _ in range(n):\n        result = (result * 2) % p\n    return result"}
{"idx": 50, "completion": "return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"}
{"idx": 51, "completion": "vowels = \"aeiouAEIOU\"\n    result = \"\"\n    for char in text:\n        if char not in vowels:\n            result += char\n    return result"}
{"idx": 52, "completion": "for num in l:\n        if num >= t:\n            return False\n    return True"}
{"idx": 53, "completion": "return x * y"}
{"idx": 54, "completion": "return set(s0) == set(s1)"}
{"idx": 55, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)"}
{"idx": 56, "completion": "balance = 0\n    for bracket in brackets:\n        if bracket == '<':\n            balance += 1\n        else:\n            balance -= 1\n        if balance < 0:\n            return False\n    return balance == 0"}
{"idx": 57, "completion": "\"*** YOUR CODE HERE ***\"\n    if len(l) <= 2:\n        return True\n    increasing = True\n    decreasing = True\n    for i in range(len(l) - 1):\n        if l[i] > l[i + 1]:\n            increasing = False\n        if l[i] < l[i + 1]:\n            decreasing = False\n    return increasing or decreasing"}
{"idx": 58, "completion": "common_elements = []\n    for element in l1:\n        if element in l2 and element not in common_elements:\n            common_elements.append(element)\n    return sorted(common_elements)"}
{"idx": 59, "completion": "# The function starts by initializing i to 2, which is the smallest prime number.\n    i = 2\n    # It then enters a loop that continues as long as i squared is less than or equal to n. \n    # This is because if n has a factor larger than its square root, the other factor must be smaller than the square root.\n    while i * i <= n:\n        # Inside the loop, it checks if i is a factor of n (i.e., if n is divisible by i).\n        if n % i:\n            # If i is not a factor of n, it increments i by 1 and continues the loop.\n            i += 1\n        else:\n            # If i is a factor of n, it divides n by i, effectively reducing n to the result of this division.\n            # This step removes all occurrences of the factor i from n.\n            n //= i\n    # Once the loop ends, the function returns the remaining value of n, which is the largest prime factor.\n    return n"}
{"idx": 60, "completion": "return n * (n + 1) // 2"}
{"idx": 61, "completion": "\"*** YOUR CODE HERE ***\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        else:\n            if not stack:\n                return False\n            stack.pop()\n    return not stack"}
{"idx": 62, "completion": "result = []\n    for i in range(1, len(xs)):\n        result.append(xs[i] * i)\n    return result"}
{"idx": 63, "completion": "if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        a, b, c = 0, 0, 1\n        for _ in range(3, n + 1):\n            a, b, c = b, c, a + b + c\n        return c"}
{"idx": 64, "completion": "vowels = \"aeiouAEIOU\"\n    count = 0\n    for i in range(len(s)):\n        if s[i] in vowels:\n            count += 1\n        if i == len(s) - 1 and s[i].lower() == 'y':\n            count += 1\n    return count"}
{"idx": 65, "completion": "x = str(x)\n    if shift > len(x):\n        return x[::-1]\n    return x[-shift:] + x[:-shift]"}
{"idx": 66, "completion": "return sum(ord(c) for c in s if c.isupper())"}
{"idx": 67, "completion": "# Split the string into parts\n    parts = s.split()\n    \n    # Extract the number of apples and oranges\n    apples = int(parts[0])\n    oranges = int(parts[2])\n    \n    # Calculate the number of mangoes\n    mangoes = n - apples - oranges\n    \n    return mangoes"}
{"idx": 68, "completion": "if not arr:\n        return []\n    \n    smallest_even = None\n    smallest_index = -1\n    \n    for i, num in enumerate(arr):\n        if num % 2 == 0:\n            if smallest_even is None or num < smallest_even:\n                smallest_even = num\n                smallest_index = i\n            elif num == smallest_even and i < smallest_index:\n                smallest_index = i\n    \n    if smallest_even is not None:\n        return [smallest_even, smallest_index]\n    else:\n        return []"}
{"idx": 69, "completion": "freq = {}\n    for num in lst:\n        if num > 0:\n            freq[num] = freq.get(num, 0) + 1\n    candidates = [num for num in freq if freq[num] >= num]\n    return max(candidates) if candidates else -1"}
{"idx": 70, "completion": "if not lst:\n        return []\n    sorted_lst = []\n    lst_sorted = sorted(lst)\n    while lst_sorted:\n        if len(lst_sorted) == 1:\n            sorted_lst.append(lst_sorted[0])\n            break\n        min_val = lst_sorted.pop(0)\n        max_val = lst_sorted.pop(-1)\n        sorted_lst.append(min_val)\n        sorted_lst.append(max_val)\n    return sorted_lst"}
{"idx": 71, "completion": "# Check if the sides form a valid triangle\n    if a + b > c and a + c > b and b + c > a:\n        # Calculate the semi-perimeter\n        s = (a + b + c) / 2\n        # Calculate the area using Heron's formula\n        area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n        # Round the area to 2 decimal places\n        return round(area, 2)\n    else:\n        return -1"}
{"idx": 72, "completion": "# Check if the list is a palindrome\n    is_palindrome = q == q[::-1]\n    \n    # Calculate the sum of the elements\n    sum_elements = sum(q)\n    \n    # Check if the list is balanced (palindrome) and the sum is less than or equal to the maximum weight\n    return is_palindrome and sum_elements <= w"}
{"idx": 73, "completion": "n = len(arr)\n    # Create a 2D array to store the minimum changes needed for subarrays\n    dp = [[0] * n for _ in range(n)]\n    \n    # Fill the table for subarrays of length 2\n    for i in range(n - 1):\n        if arr[i] != arr[i + 1]:\n            dp[i][i + 1] = 1\n    \n    # Fill the table for subarrays of length > 2\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i + length - 1\n            if arr[i] == arr[j]:\n                dp[i][j] = dp[i + 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i + 1][j], dp[i][j - 1])\n    \n    return dp[0][n - 1]"}
{"idx": 74, "completion": "# Calculate the total number of characters in each list\n    total_chars1 = sum(len(s) for s in lst1)\n    total_chars2 = sum(len(s) for s in lst2)\n    \n    # Determine which list to return based on the total characters\n    if total_chars1 < total_chars2:\n        return lst1\n    elif total_chars2 < total_chars1:\n        return lst2\n    else:\n        return lst1"}
{"idx": 75, "completion": "if a < 2:\n        return False\n    for i in range(2, a):\n        if a % i == 0:\n            for j in range(2, i):\n                if i % j == 0:\n                    break\n            else:\n                for k in range(2, a // i):\n                    if (a // i) % k == 0:\n                        break\n                else:\n                    return True\n    return False"}
{"idx": 76, "completion": "if x == 1:\n        return True\n    if n == 1:\n        return False\n    power = 1\n    while power <= x:\n        power *= n\n        if power == x:\n            return True\n    return False"}
{"idx": 77, "completion": "# Check if the input is 0, which is a cube of 0\n    if a == 0:\n        return True\n    \n    # Calculate the absolute value of a to handle negative numbers\n    abs_a = abs(a)\n    \n    # Iterate through possible cube roots\n    for i in range(0, abs_a + 1):\n        cube = i * i * i\n        # If the cube of the current number matches the absolute value of a, return True\n        if cube == abs_a:\n            return True\n        # If the cube exceeds the absolute value of a, break the loop\n        if cube > abs_a:\n            break\n    \n    # If no cube root is found, return False\n    return False"}
{"idx": 78, "completion": "primes = {'2', '3', '5', '7', 'B', 'D'}\n    count = 0\n    for digit in num:\n        if digit in primes:\n            count += 1\n    return count"}
{"idx": 79, "completion": "binary = bin(decimal)[2:]  # Convert to binary and remove the '0b' prefix\n    return f\"db{binary}db\""}
{"idx": 80, "completion": "if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] or s[i] == s[i+2] or s[i+1] == s[i+2]:\n            return False\n    return True"}
{"idx": 81, "completion": "letter_grades = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grades.append('A+')\n        elif gpa > 3.7:\n            letter_grades.append('A')\n        elif gpa > 3.3:\n            letter_grades.append('A-')\n        elif gpa > 3.0:\n            letter_grades.append('B+')\n        elif gpa > 2.7:\n            letter_grades.append('B')\n        elif gpa > 2.3:\n            letter_grades.append('B-')\n        elif gpa > 2.0:\n            letter_grades.append('C+')\n        elif gpa > 1.7:\n            letter_grades.append('C')\n        elif gpa > 1.3:\n            letter_grades.append('C-')\n        elif gpa > 1.0:\n            letter_grades.append('D+')\n        elif gpa > 0.7:\n            letter_grades.append('D')\n        elif gpa > 0.0:\n            letter_grades.append('D-')\n        else:\n            letter_grades.append('E')\n    return letter_grades"}
{"idx": 82, "completion": "length = len(string)\n    if length < 2:\n        return False\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return False\n    return True"}
{"idx": 83, "completion": "if n == 1:\n        return 1\n    return 9 * 10 ** (n - 1) + 9 * 10 ** (n - 2) * (n - 1)"}
{"idx": 84, "completion": "sum_digits = sum(int(d) for d in str(N))\n    return bin(sum_digits)[2:]"}
{"idx": 85, "completion": "return sum([x for i, x in enumerate(lst) if i % 2 != 0 and x % 2 == 0])"}
{"idx": 86, "completion": "words = s.split(' ')\n    ordered_words = []\n    for word in words:\n        ordered_word = ''.join(sorted(word, key=lambda x: ord(x)))\n        ordered_words.append(ordered_word)\n    return ' '.join(ordered_words)"}
{"idx": 87, "completion": "result = []\n    for i, row in enumerate(lst):\n        for j, val in enumerate(row):\n            if val == x:\n                result.append((i, j))\n    result.sort()\n    result.sort(key=lambda t: (t[0], -t[1]))\n    return result"}
{"idx": 88, "completion": "if not array:\n        return []\n    \n    first = array[0]\n    last = array[-1]\n    total = first + last\n    \n    if total % 2 == 1:\n        # Sort in ascending order\n        return sorted(array)\n    else:\n        # Sort in descending order\n        return sorted(array, reverse=True)"}
{"idx": 89, "completion": "encrypted = ''\n    for char in s:\n        if char.isalpha():\n            shifted = ord(char) + 4  # Shift each letter by 4 positions\n            if char.islower():\n                if shifted > ord('z'):\n                    shifted -= 26\n            elif char.isupper():\n                if shifted > ord('Z'):\n                    shifted -= 26\n            encrypted += chr(shifted)\n        else:\n            encrypted += char\n    return encrypted"}
{"idx": 90, "completion": "if len(lst) < 2:\n        return None\n    sorted_lst = sorted(lst)\n    for i in range(1, len(sorted_lst)):\n        if sorted_lst[i] != sorted_lst[0]:\n            return sorted_lst[i]\n    return None"}
{"idx": 91, "completion": "sentences = S.split('.') + S.split('?') + S.split('!')\n    return sum(1 for sentence in sentences if sentence.strip().startswith('I '))"}
{"idx": 92, "completion": "pass"}
{"idx": 93, "completion": "vowels = 'aeiouAEIOU'\n    encoded = []\n    for char in message:\n        if char in vowels:\n            # Determine the new character by moving 2 places ahead\n            new_char = chr(ord(char) + 2)\n            # Handle the case for 'y' and 'z' and their uppercase counterparts\n            if (char.lower() == 'y' or char.lower() == 'z'):\n                new_char = chr(ord(char) - 24)  # Wrap around to 'a' or 'A'\n            encoded.append(new_char)\n        else:\n            # Swap the case of non-vowel characters\n            if char.islower():\n                encoded.append(char.upper())\n            else:\n                encoded.append(char.lower())\n    return ''.join(encoded)"}
{"idx": 94, "completion": "def is_prime(n):\n        if n < 2:\n            return False\n        for i in range(2, int(n**0.5) + 1):\n            if n % i == 0:\n                return False\n        return True\n    \n    max_prime = 0\n    for num in lst:\n        if is_prime(num) and num > max_prime:\n            max_prime = num\n    \n    return sum(int(d) for d in str(max_prime))"}
{"idx": 95, "completion": "if not dict:\n        return False\n    \n    keys = list(dict.keys())\n    if all(isinstance(key, str) and key.islower() for key in keys):\n        return True\n    elif all(isinstance(key, str) and key.isupper() for key in keys):\n        return True\n    else:\n        return False"}
{"idx": 96, "completion": "if n <= 1:\n        return []\n    primes = []\n    for num in range(2, n):\n        is_prime = True\n        for i in range(2, int(num**0.5) + 1):\n            if num % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(num)\n    return primes"}
{"idx": 97, "completion": "return (a % 10) * (b % 10)"}
{"idx": 98, "completion": "count = 0\n    for i in range(0, len(s), 2):\n        if s[i] in 'AEIOU':\n            count += 1\n    return count"}
{"idx": 99, "completion": "# Split the string into integer and fractional parts\n    if '.' in value:\n        integer_part, fractional_part = value.split('.', 1)\n        fractional_part = fractional_part.rstrip('0')  # Remove trailing zeros\n    else:\n        integer_part = value\n        fractional_part = '0'\n    \n    # Determine the sign and the absolute value\n    is_negative = integer_part.startswith('-')\n    integer_part_abs = integer_part.lstrip('-')\n    \n    # Convert the integer part to an integer\n    if integer_part_abs:\n        int_value = int(integer_part_abs)\n    else:\n        int_value = 0\n    \n    # Process the fractional part\n    if fractional_part:\n        # The first digit after the decimal point\n        first_digit = int(fractional_part[0]) if fractional_part[0] != '' else 0\n    else:\n        first_digit = 0\n    \n    # Determine the rounding\n    if first_digit < 5:\n        # Round down\n        result = int_value\n    elif first_digit > 5:\n        # Round up\n        result = int_value + 1\n    else:\n        # Check if there are more digits after the first one\n        if len(fractional_part) > 1:\n            # There are more digits, round up\n            result = int_value + 1\n        else:\n            # Exactly .5, round away from zero\n            if int_value % 2 == 0:\n                result = int_value\n            else:\n                result = int_value + 1\n    \n    # Apply the sign\n    if is_negative:\n        result = -result\n    \n    return result"}
{"idx": 100, "completion": "pile = []\n    current = n\n    for _ in range(n):\n        pile.append(current)\n        if current % 2 == 1:\n            current += 2\n        else:\n            current += 1\n    return pile"}
{"idx": 101, "completion": "if not s:\n        return []\n    if ',' in s:\n        return s.split(', ')\n    else:\n        return s.split()"}
{"idx": 102, "completion": "if x > y:\n        return -1\n    else:\n        for num in range(y, x-1, -1):\n            if num % 2 == 0:\n                return num\n        return -1"}
{"idx": 103, "completion": "if n > m:\n        return -1\n    total = 0\n    for num in range(n, m+1):\n        total += num\n    average = total / (m - n + 1)\n    rounded = round(average)\n    binary = bin(rounded)\n    return binary"}
{"idx": 104, "completion": "result = []\n    for num in x:\n        has_even_digit = False\n        for digit in str(num):\n            if int(digit) % 2 == 0:\n                has_even_digit = True\n                break\n        if not has_even_digit:\n            result.append(num)\n    return sorted(result)"}
{"idx": 105, "completion": "if not arr:\n        return []\n    filtered = [x for x in arr if 1 <= x <= 9]\n    filtered.sort()\n    filtered.reverse()\n    digit_names = [\"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"]\n    return [digit_names[x-1] for x in filtered]"}
{"idx": 106, "completion": "result = []\n    for i in range(1, n+1):\n        if i % 2 == 0:\n            # Compute factorial for even i\n            factorial = 1\n            for num in range(1, i+1):\n                factorial *= num\n            result.append(factorial)\n        else:\n            # Compute sum for odd i\n            sum_num = 0\n            for num in range(1, i+1):\n                sum_num += num\n            result.append(sum_num)\n    return result"}
{"idx": 107, "completion": "even_count = 0\n    odd_count = 0\n    for num in range(1, n + 1):\n        if str(num) == str(num)[::-1]:\n            if num % 2 == 0:\n                even_count += 1\n            else:\n                odd_count += 1\n    return (even_count, odd_count)"}
{"idx": 108, "completion": "if not arr:\n        return 0\n    count = 0\n    for num in arr:\n        if num < 0:\n            num = -num\n            sum_digits = -int(str(num)[0])\n            for digit in str(num)[1:]:\n                sum_digits += int(digit)\n        else:\n            sum_digits = 0\n            for digit in str(num):\n                sum_digits += int(digit)\n        if sum_digits > 0:\n            count += 1\n    return count"}
{"idx": 109, "completion": "if not arr:\n        return True\n    sorted_arr = sorted(arr)\n    n = len(arr)\n    for i in range(n):\n        if arr == sorted_arr:\n            return True\n        arr = [arr[-1]] + arr[:-1]\n    return False"}
{"idx": 110, "completion": "# Check if all elements in lst1 are already even\n    if all(num % 2 == 0 for num in lst1):\n        return \"YES\"\n    \n    # Check if there are any even numbers in lst2 to exchange\n    if not any(num % 2 == 0 for num in lst2):\n        return \"NO\"\n    \n    # If there are odd numbers in lst1 and even numbers in lst2, it's possible to exchange\n    return \"YES\""}
{"idx": 111, "completion": "if not test:\n        return {}\n    \n    letter_counts = {}\n    for letter in test.split():\n        if letter in letter_counts:\n            letter_counts[letter] += 1\n        else:\n            letter_counts[letter] = 1\n    \n    max_count = max(letter_counts.values())\n    result = {k: v for k, v in letter_counts.items() if v == max_count}\n    \n    return result"}
{"idx": 112, "completion": "result = []\n    for char in s:\n        if char not in c:\n            result.append(char)\n    result = ''.join(result)\n    is_palindrome = result == result[::-1]\n    return (result, is_palindrome)"}
{"idx": 113, "completion": "result = []\n    for s in lst:\n        odd_digits = 0\n        for c in s:\n            if int(c) % 2 != 0:\n                odd_digits += 1\n        result.append(f\"the number of odd elements {odd_digits}n the str{odd_digits}ng {odd_digits} of the {odd_digits}nput.\")\n    return result"}
{"idx": 114, "completion": "min_sum = current_sum = nums[0]\n    for num in nums[1:]:\n        current_sum = min(num, current_sum + num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"}
{"idx": 115, "completion": "total_operations = 0\n    for well in grid:\n        total_water = sum(well)\n        if total_water == 0:\n            continue\n        operations = math.ceil(total_water / capacity)\n        total_operations += operations\n    return total_operations"}
{"idx": 116, "completion": "return sorted(arr, key=lambda x: (bin(x).count('1') if x >= 0 else bin(x)[0] == '-', x))"}
{"idx": 117, "completion": "if not s:\n        return []\n    \n    vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    words = s.split()\n    result = []\n    \n    for word in words:\n        consonant_count = 0\n        for char in word:\n            if char.isalpha() and char not in vowels:\n                consonant_count += 1\n        if consonant_count == n:\n            result.append(word)\n    \n    return result"}
{"idx": 118, "completion": "vowels = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')\n    \n    # Iterate from the end of the word towards the beginning\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels and word[i-1] in consonants and word[i+1] in consonants:\n            return word[i]\n    return \"\""}
{"idx": 119, "completion": "s1, s2 = lst\n    if len(s1) == 0 or len(s2) == 0:\n        return 'Yes'\n    if s1[0] == ')' and s2[-1] == '(':\n        return 'No'\n    if s1[-1] == '(' and s2[0] == ')':\n        return 'No'\n    return 'Yes'"}
{"idx": 120, "completion": "if k == 0:\n        return []\n    arr.sort()\n    return arr[-k:]"}
{"idx": 121, "completion": "sum = 0\n    for i in range(0, len(lst)):\n        if i % 2 == 0 and lst[i] % 2 != 0:\n            sum += lst[i]\n    return sum"}
{"idx": 122, "completion": "sum = 0\n    for i in range(k):\n        if len(str(arr[i])) <= 2:\n            sum += arr[i]\n    return sum"}
{"idx": 123, "completion": "collatz_sequence = [n]\n    while n != 1:\n        if n % 2 == 0:\n            n = n // 2\n        else:\n            n = 3 * n + 1\n        collatz_sequence.append(n)\n    odd_numbers = [x for x in collatz_sequence if x % 2 != 0]\n    odd_numbers.sort()\n    return odd_numbers"}
{"idx": 124, "completion": "if not date:\n        return False\n    if len(date) != 10:\n        return False\n    if date[2] != '-' or date[5] != '-':\n        return False\n    month, day, year = date.split('-')\n    if not month.isdigit() or not day.isdigit() or not year.isdigit():\n        return False\n    month = int(month)\n    day = int(day)\n    year = int(year)\n    if month < 1 or month > 12:\n        return False\n    if month in [1, 3, 5, 7, 8, 10, 12]:\n        if day < 1 or day > 31:\n            return False\n    elif month in [4, 6, 9, 11]:\n        if day < 1 or day > 30:\n            return False\n    else:\n        if year % 4 == 0 and (year % 100 != 0 or year % 400 == 0):\n            if day < 1 or day > 29:\n                return False\n        else:\n            if day < 1 or day > 28:\n                return False\n    return True"}
{"idx": 125, "completion": "if ' ' in txt:\n        return txt.split()\n    elif ',' in txt:\n        return txt.split(',')\n    else:\n        count = 0\n        for char in txt:\n            if char.islower() and (ord(char) - ord('a')) % 2 == 0:\n                count += 1\n        return count"}
{"idx": 126, "completion": "# Check for duplicates\n    if len(lst) != len(set(lst)):\n        return False\n    # Check if the list is sorted in ascending order\n    return lst == sorted(lst)"}
{"idx": 127, "completion": "start1, end1 = interval1\n    start2, end2 = interval2\n\n    # Determine the overlapping interval\n    start = max(start1, start2)\n    end = min(end1, end2)\n\n    # Check if there is an overlap\n    if start > end:\n        return \"NO\"\n\n    # Calculate the length of the intersection\n    length = end - start + 1\n\n    # Check if the length is a prime number\n    if length < 2:\n        return \"NO\"\n    for i in range(2, int(length ** 0.5) + 1):\n        if length % i == 0:\n            return \"NO\"\n    return \"YES\""}
{"idx": 128, "completion": "if not arr:\n        return None\n    product = 1\n    for num in arr:\n        if num > 0:\n            product *= 1\n        elif num < 0:\n            product *= -1\n        else:\n            product *= 0\n    return sum(abs(num) for num in arr) * product"}
{"idx": 129, "completion": "n = len(grid)\n    min_val = float('inf')\n    min_path = []\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] < min_val:\n                min_val = grid[i][j]\n                min_path = [grid[i][j]]\n    \n    if k == 1:\n        return min_path\n    \n    neighbors = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    visited = set()\n    \n    def dfs(i, j, path, visited):\n        if len(path) == k:\n            return path\n        min_next_path = None\n        for di, dj in neighbors:\n            ni, nj = i + di, j + dj\n            if 0 <= ni < n and 0 <= nj < n and (ni, nj) not in visited:\n                new_visited = visited.copy()\n                new_visited.add((ni, nj))\n                next_path = dfs(ni, nj, path + [grid[ni][nj]], new_visited)\n                if next_path is not None:\n                    if min_next_path is None or next_path < min_next_path:\n                        min_next_path = next_path\n        return min_next_path\n    \n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == min_val:\n                visited = set()\n                visited.add((i, j))\n                path = dfs(i, j, [min_val], visited)\n                if path is not None and (not min_path or path < min_path):\n                    min_path = path\n    \n    return min_path"}
{"idx": 130, "completion": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 3]\n    elif n == 2:\n        return [1, 3, 2]\n    else:\n        res = [1, 3, 2]\n        for i in range(3, n + 1):\n            if i % 2 == 0:\n                res.append(1 + i // 2)\n            else:\n                res.append(res[i - 1] + res[i - 2] + res[i + 1])\n        return res"}
{"idx": 131, "completion": "product = 1\n    has_odd = False\n    for d in str(n):\n        d = int(d)\n        if d % 2 == 1:\n            product *= d\n            has_odd = True\n    return product if has_odd else 0"}
{"idx": 132, "completion": "stack = []\n    for char in string:\n        if char == '[':\n            stack.append(char)\n        elif char == ']':\n            if stack and stack[-1] == '[':\n                stack.pop()\n            else:\n                stack.append(char)\n    return len(stack) >= 2 and string.count('[') >= 2 and string.count(']') >= 2"}
{"idx": 133, "completion": "return sum([math.ceil(x)**2 for x in lst])"}
{"idx": 134, "completion": "if not txt:\n        return False\n    last_char = txt[-1]\n    if not last_char.isalpha():\n        return False\n    if len(txt) == 1:\n        return True\n    if txt[-2] == ' ':\n        return True\n    return False"}
{"idx": 135, "completion": "for i in range(len(arr)-1, 0, -1):\n        if arr[i] < arr[i-1]:\n            return i\n    return -1"}
{"idx": 136, "completion": "negatives = [x for x in lst if x < 0]\n    positives = [x for x in lst if x > 0]\n    \n    a = max(negatives) if negatives else None\n    b = min(positives) if positives else None\n    \n    return (a, b)"}
{"idx": 137, "completion": "# Convert both inputs to appropriate types if they are strings\n    def parse_value(value):\n        if isinstance(value, str):\n            # Replace comma with dot to handle both decimal formats\n            value = value.replace(',', '.')\n            if '.' in value:\n                try:\n                    return float(value)\n                except ValueError:\n                    return value\n            else:\n                try:\n                    return int(value)\n                except ValueError:\n                    return value\n        return value\n    \n    a_parsed = parse_value(a)\n    b_parsed = parse_value(b)\n    \n    # Compare the parsed values\n    if a_parsed == b_parsed:\n        return None\n    else:\n        return a if a_parsed > b_parsed else b"}
{"idx": 138, "completion": "if n < 8:\n        return False\n    if n % 2 != 0:\n        return False\n    return True"}
{"idx": 139, "completion": "result = 1\n    for i in range(1, n+1):\n        result *= factorial(i)\n    return result"}
{"idx": 140, "completion": "# Replace all spaces with underscores\n    text = text.replace(' ', '_')\n    \n    # Replace any occurrence of 2 or more consecutive underscores with a dash\n    text = re.sub(r'_{2,}', '-', text)\n    \n    return text"}
{"idx": 141, "completion": "# Check the number of digits in the file name\n    digit_count = sum(c.isdigit() for c in file_name)\n    if digit_count > 3:\n        return 'No'\n    \n    # Check the number of dots in the file name\n    if file_name.count('.') != 1:\n        return 'No'\n    \n    # Split the file name into the part before and after the dot\n    before_dot, after_dot = file_name.split('.', 1)\n    \n    # Check the part before the dot\n    if not before_dot:\n        return 'No'\n    if not before_dot[0].isalpha():\n        return 'No'\n    \n    # Check the part after the dot\n    if after_dot not in ['txt', 'exe', 'dll']:\n        return 'No'\n    \n    return 'Yes'"}
{"idx": 142, "completion": "total = 0\n    for i in range(len(lst)):\n        if i % 3 == 0:\n            total += lst[i] ** 2\n        elif i % 4 == 0 and i % 3 != 0:\n            total += lst[i] ** 3\n        else:\n            total += lst[i]\n    return total"}
{"idx": 143, "completion": "words = sentence.split()\n    primes = []\n    for word in words:\n        if is_prime(len(word)):\n            primes.append(word)\n    return ' '.join(primes)"}
{"idx": 144, "completion": "x_num, x_den = map(int, x.split('/'))\n    n_num, n_den = map(int, n.split('/'))\n    product_num = x_num * n_num\n    product_den = x_den * n_den\n    return product_num % product_den == 0"}
{"idx": 145, "completion": "if not nums:\n        return []\n    return sorted(nums, key=lambda x: (sum(int(d) for d in str(abs(x))), nums.index(x)))"}
{"idx": 146, "completion": "count = 0\n    for num in nums:\n        if num > 10:\n            num_str = str(abs(num))\n            first_digit = int(num_str[0])\n            last_digit = int(num_str[-1])\n            if first_digit % 2 != 0 and last_digit % 2 != 0:\n                count += 1\n    return count"}
{"idx": 147, "completion": "a = [i * i - i + 1 for i in range(1, n + 1)]\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                if (a[i] + a[j] + a[k]) % 3 == 0:\n                    count += 1\n    return count"}
{"idx": 148, "completion": "# List of planets in order from the Sun\n    planets_order = [\"Mercury\", \"Venus\", \"Earth\", \"Mars\", \"Jupiter\", \"Saturn\", \"Uranus\", \"Neptune\"]\n    \n    # Check if both planets are in the list\n    if planet1 not in planets_order or planet2 not in planets_order:\n        return ()\n    \n    # Find the indices of the two planets\n    index1 = planets_order.index(planet1)\n    index2 = planets_order.index(planet2)\n    \n    # Determine the start and end indices\n    start = min(index1, index2) + 1\n    end = max(index1, index2)\n    \n    # Extract the planets between the two indices\n    if start > end:\n        return ()\n    result = tuple(planets_order[start:end])\n    \n    return result"}
{"idx": 149, "completion": "# Filter out strings with odd lengths\n    filtered_list = [word for word in lst if len(word) % 2 == 0]\n    \n    # Sort the filtered list first by length, then alphabetically\n    sorted_list = sorted(filtered_list, key=lambda x: (len(x), x))\n    \n    return sorted_list"}
{"idx": 150, "completion": "if n == 1:\n        return y\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return y\n    return x"}
{"idx": 151, "completion": "sum_squares = 0\n    for num in lst:\n        if isinstance(num, int) and num > 0 and num % 2 != 0:\n            sum_squares += num ** 2\n    return sum_squares"}
{"idx": 152, "completion": "result = []\n    for i in range(len(game)):\n        if game[i] == guess[i]:\n            result.append(0)\n        else:\n            result.append(abs(game[i] - guess[i]))\n    return result"}
{"idx": 153, "completion": "max_strength = -float('inf')\n    strongest_extension = None\n    for extension in extensions:\n        cap = sum(1 for c in extension if c.isupper())\n        sm = sum(1 for c in extension if c.islower())\n        strength = cap - sm\n        if strength > max_strength:\n            max_strength = strength\n            strongest_extension = extension\n    return f\"{class_name}.{strongest_extension}\""}
{"idx": 154, "completion": "for i in range(len(b)):\n        if b in a:\n            return True\n        b = b[-1] + b[:-1]\n    return False"}
{"idx": 155, "completion": "num = abs(num)\n    even = 0\n    odd = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)"}
{"idx": 156, "completion": "roman_numerals = {\n        1: 'i', 4: 'iv', 5: 'v', 9: 'ix', 10: 'x', 40: 'xl', 50: 'l',\n        90: 'xc', 100: 'c', 400: 'cd', 500: 'd', 900: 'cm', 1000: 'm'\n    }\n    \n    result = []\n    for value in sorted(roman_numerals.keys(), reverse=True):\n        while number >= value:\n            result.append(roman_numerals[value])\n            number -= value\n    return ''.join(result).lower()"}
{"idx": 157, "completion": "# Check if the squares of the two smaller sides sum to the square of the largest side\n    sides = sorted([a, b, c])\n    return sides[0] ** 2 + sides[1] ** 2 == sides[2] ** 2"}
{"idx": 158, "completion": "max_unique = 0\n    max_word = \"\"\n    for word in words:\n        unique = len(set(word))\n        if unique > max_unique:\n            max_unique = unique\n            max_word = word\n        elif unique == max_unique:\n            if word < max_word:\n                max_word = word\n    return max_word"}
{"idx": 159, "completion": "# Calculate the total carrots eaten after fulfilling the need\n    total_eaten = number + min(need, remaining)\n    # Calculate the remaining carrots after eating\n    remaining_after_eating = max(0, remaining - need)\n    return [total_eaten, remaining_after_eating]"}
{"idx": 160, "completion": "expression = str(operand[0])\n    for oprt, oprd in zip(operator, operand[1:]):\n        expression += oprt + str(oprd)\n    return eval(expression)"}
{"idx": 161, "completion": "if not any(c.isalpha() for c in s):\n        return s[::-1]\n    else:\n        return ''.join([c.upper() if c.islower() else c.lower() if c.isupper() else c for c in s])"}
{"idx": 162, "completion": "if not text:\n        return None\n    return hashlib.md5(text.encode('utf-8')).hexdigest()"}
{"idx": 163, "completion": "if a > b:\n        a, b = b, a\n    result = []\n    for num in range(a, b + 1):\n        if all(digit % 2 == 0 for digit in map(int, str(num))):\n            result.append(num)\n    return result"}
